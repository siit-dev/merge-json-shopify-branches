{"version":3,"file":"686.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;ACnxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA","sources":[".././node_modules/prettier/doc.mjs",".././node_modules/prettier/index.mjs"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/document/public.js\nvar public_exports = {};\n__export(public_exports, {\n  builders: () => builders,\n  printer: () => printer,\n  utils: () => utils\n});\n\n// src/document/constants.js\nvar DOC_TYPE_STRING = \"string\";\nvar DOC_TYPE_ARRAY = \"array\";\nvar DOC_TYPE_CURSOR = \"cursor\";\nvar DOC_TYPE_INDENT = \"indent\";\nvar DOC_TYPE_ALIGN = \"align\";\nvar DOC_TYPE_TRIM = \"trim\";\nvar DOC_TYPE_GROUP = \"group\";\nvar DOC_TYPE_FILL = \"fill\";\nvar DOC_TYPE_IF_BREAK = \"if-break\";\nvar DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";\nvar DOC_TYPE_LINE_SUFFIX = \"line-suffix\";\nvar DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";\nvar DOC_TYPE_LINE = \"line\";\nvar DOC_TYPE_LABEL = \"label\";\nvar DOC_TYPE_BREAK_PARENT = \"break-parent\";\nvar VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([\n  DOC_TYPE_CURSOR,\n  DOC_TYPE_INDENT,\n  DOC_TYPE_ALIGN,\n  DOC_TYPE_TRIM,\n  DOC_TYPE_GROUP,\n  DOC_TYPE_FILL,\n  DOC_TYPE_IF_BREAK,\n  DOC_TYPE_INDENT_IF_BREAK,\n  DOC_TYPE_LINE_SUFFIX,\n  DOC_TYPE_LINE_SUFFIX_BOUNDARY,\n  DOC_TYPE_LINE,\n  DOC_TYPE_LABEL,\n  DOC_TYPE_BREAK_PARENT\n]);\n\n// src/document/utils/get-doc-type.js\nfunction getDocType(doc) {\n  if (typeof doc === \"string\") {\n    return DOC_TYPE_STRING;\n  }\n  if (Array.isArray(doc)) {\n    return DOC_TYPE_ARRAY;\n  }\n  if (!doc) {\n    return;\n  }\n  const { type } = doc;\n  if (VALID_OBJECT_DOC_TYPES.has(type)) {\n    return type;\n  }\n}\nvar get_doc_type_default = getDocType;\n\n// src/document/invalid-doc-error.js\nvar disjunctionListFormat = (list) => new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);\nfunction getDocErrorMessage(doc) {\n  const type = doc === null ? \"null\" : typeof doc;\n  if (type !== \"string\" && type !== \"object\") {\n    return `Unexpected doc '${type}', \nExpected it to be 'string' or 'object'.`;\n  }\n  if (get_doc_type_default(doc)) {\n    throw new Error(\"doc is valid.\");\n  }\n  const objectType = Object.prototype.toString.call(doc);\n  if (objectType !== \"[object Object]\") {\n    return `Unexpected doc '${objectType}'.`;\n  }\n  const EXPECTED_TYPE_VALUES = disjunctionListFormat(\n    [...VALID_OBJECT_DOC_TYPES].map((type2) => `'${type2}'`)\n  );\n  return `Unexpected doc.type '${doc.type}'.\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;\n}\nvar InvalidDocError = class extends Error {\n  name = \"InvalidDocError\";\n  constructor(doc) {\n    super(getDocErrorMessage(doc));\n    this.doc = doc;\n  }\n};\nvar invalid_doc_error_default = InvalidDocError;\n\n// src/document/utils/traverse-doc.js\nvar traverseDocOnExitStackMarker = {};\nfunction traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {\n  const docsStack = [doc];\n  while (docsStack.length > 0) {\n    const doc2 = docsStack.pop();\n    if (doc2 === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n    if (onExit) {\n      docsStack.push(doc2, traverseDocOnExitStackMarker);\n    }\n    const docType = get_doc_type_default(doc2);\n    if (!docType) {\n      throw new invalid_doc_error_default(doc2);\n    }\n    if ((onEnter == null ? void 0 : onEnter(doc2)) === false) {\n      continue;\n    }\n    switch (docType) {\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc2 : doc2.parts;\n        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(parts[i]);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n        docsStack.push(doc2.flatContents, doc2.breakContents);\n        break;\n      case DOC_TYPE_GROUP:\n        if (shouldTraverseConditionalGroups && doc2.expandedStates) {\n          for (let ic = doc2.expandedStates.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(doc2.expandedStates[i]);\n          }\n        } else {\n          docsStack.push(doc2.contents);\n        }\n        break;\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        docsStack.push(doc2.contents);\n        break;\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nvar traverse_doc_default = traverseDoc;\n\n// src/document/utils/assert-doc.js\nvar noop = () => {\n};\nvar assertDoc = true ? noop : function(doc) {\n  traverse_doc_default(doc, (doc2) => {\n    if (checked.has(doc2)) {\n      return false;\n    }\n    if (typeof doc2 !== \"string\") {\n      checked.add(doc2);\n    }\n  });\n};\nvar assertDocArray = true ? noop : function(docs, optional = false) {\n  if (optional && !docs) {\n    return;\n  }\n  if (!Array.isArray(docs)) {\n    throw new TypeError(\"Unexpected doc array.\");\n  }\n  for (const doc of docs) {\n    assertDoc(doc);\n  }\n};\n\n// src/document/builders.js\nfunction indent(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_INDENT, contents };\n}\nfunction align(widthOrString, contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };\n}\nfunction group(contents, opts = {}) {\n  assertDoc(contents);\n  assertDocArray(\n    opts.expandedStates,\n    /* optional */\n    true\n  );\n  return {\n    type: DOC_TYPE_GROUP,\n    id: opts.id,\n    contents,\n    break: Boolean(opts.shouldBreak),\n    expandedStates: opts.expandedStates\n  };\n}\nfunction dedentToRoot(contents) {\n  return align(Number.NEGATIVE_INFINITY, contents);\n}\nfunction markAsRoot(contents) {\n  return align({ type: \"root\" }, contents);\n}\nfunction dedent(contents) {\n  return align(-1, contents);\n}\nfunction conditionalGroup(states, opts) {\n  return group(states[0], { ...opts, expandedStates: states });\n}\nfunction fill(parts) {\n  assertDocArray(parts);\n  return { type: DOC_TYPE_FILL, parts };\n}\nfunction ifBreak(breakContents, flatContents = \"\", opts = {}) {\n  assertDoc(breakContents);\n  if (flatContents !== \"\") {\n    assertDoc(flatContents);\n  }\n  return {\n    type: DOC_TYPE_IF_BREAK,\n    breakContents,\n    flatContents,\n    groupId: opts.groupId\n  };\n}\nfunction indentIfBreak(contents, opts) {\n  assertDoc(contents);\n  return {\n    type: DOC_TYPE_INDENT_IF_BREAK,\n    contents,\n    groupId: opts.groupId,\n    negate: opts.negate\n  };\n}\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_LINE_SUFFIX, contents };\n}\nvar lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };\nvar breakParent = { type: DOC_TYPE_BREAK_PARENT };\nvar trim = { type: DOC_TYPE_TRIM };\nvar hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };\nvar literallineWithoutBreakParent = {\n  type: DOC_TYPE_LINE,\n  hard: true,\n  literal: true\n};\nvar line = { type: DOC_TYPE_LINE };\nvar softline = { type: DOC_TYPE_LINE, soft: true };\nvar hardline = [hardlineWithoutBreakParent, breakParent];\nvar literalline = [literallineWithoutBreakParent, breakParent];\nvar cursor = { type: DOC_TYPE_CURSOR };\nfunction join(separator, docs) {\n  assertDoc(separator);\n  assertDocArray(docs);\n  const parts = [];\n  for (let i = 0; i < docs.length; i++) {\n    if (i !== 0) {\n      parts.push(separator);\n    }\n    parts.push(docs[i]);\n  }\n  return parts;\n}\nfunction addAlignmentToDoc(doc, size, tabWidth) {\n  assertDoc(doc);\n  let aligned = doc;\n  if (size > 0) {\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    aligned = align(size % tabWidth, aligned);\n    aligned = align(Number.NEGATIVE_INFINITY, aligned);\n  }\n  return aligned;\n}\nfunction label(label2, contents) {\n  assertDoc(contents);\n  return label2 ? { type: DOC_TYPE_LABEL, label: label2, contents } : contents;\n}\n\n// scripts/build/shims/at.js\nvar at = (isOptionalObject, object, index) => {\n  if (isOptionalObject && (object === void 0 || object === null)) {\n    return;\n  }\n  if (Array.isArray(object) || typeof object === \"string\") {\n    return object[index < 0 ? object.length + index : index];\n  }\n  return object.at(index);\n};\nvar at_default = at;\n\n// scripts/build/shims/string-replace-all.js\nvar stringReplaceAll = (isOptionalObject, original, pattern, replacement) => {\n  if (isOptionalObject && (original === void 0 || original === null)) {\n    return;\n  }\n  if (original.replaceAll) {\n    return original.replaceAll(pattern, replacement);\n  }\n  if (pattern.global) {\n    return original.replace(pattern, replacement);\n  }\n  return original.split(pattern).join(replacement);\n};\nvar string_replace_all_default = stringReplaceAll;\n\n// src/common/end-of-line.js\nfunction convertEndOfLineToChars(value) {\n  switch (value) {\n    case \"cr\":\n      return \"\\r\";\n    case \"crlf\":\n      return \"\\r\\n\";\n    default:\n      return \"\\n\";\n  }\n}\n\n// node_modules/emoji-regex/index.mjs\nvar emoji_regex_default = () => {\n  return /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC2\\uDECE-\\uDEDB\\uDEE0-\\uDEE8]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n\n// node_modules/get-east-asian-width/lookup.js\nfunction isFullWidth(x) {\n  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;\n}\nfunction isWide(x) {\n  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;\n}\n\n// node_modules/get-east-asian-width/index.js\nvar _isNarrowWidth = (codePoint) => !(isFullWidth(codePoint) || isWide(codePoint));\n\n// src/utils/get-string-width.js\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n  text = text.replace(emoji_regex_default(), \"  \");\n  let width = 0;\n  for (const character of text) {\n    const codePoint = character.codePointAt(0);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    width += _isNarrowWidth(codePoint) ? 1 : 2;\n  }\n  return width;\n}\nvar get_string_width_default = getStringWidth;\n\n// src/document/utils.js\nvar getDocParts = (doc) => {\n  if (Array.isArray(doc)) {\n    return doc;\n  }\n  if (doc.type !== DOC_TYPE_FILL) {\n    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);\n  }\n  return doc.parts;\n};\nfunction mapDoc(doc, cb) {\n  if (typeof doc === \"string\") {\n    return cb(doc);\n  }\n  const mapped = /* @__PURE__ */ new Map();\n  return rec(doc);\n  function rec(doc2) {\n    if (mapped.has(doc2)) {\n      return mapped.get(doc2);\n    }\n    const result = process2(doc2);\n    mapped.set(doc2, result);\n    return result;\n  }\n  function process2(doc2) {\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_ARRAY:\n        return cb(doc2.map(rec));\n      case DOC_TYPE_FILL:\n        return cb({\n          ...doc2,\n          parts: doc2.parts.map(rec)\n        });\n      case DOC_TYPE_IF_BREAK:\n        return cb({\n          ...doc2,\n          breakContents: rec(doc2.breakContents),\n          flatContents: rec(doc2.flatContents)\n        });\n      case DOC_TYPE_GROUP: {\n        let {\n          expandedStates,\n          contents\n        } = doc2;\n        if (expandedStates) {\n          expandedStates = expandedStates.map(rec);\n          contents = expandedStates[0];\n        } else {\n          contents = rec(contents);\n        }\n        return cb({\n          ...doc2,\n          contents,\n          expandedStates\n        });\n      }\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        return cb({\n          ...doc2,\n          contents: rec(doc2.contents)\n        });\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        return cb(doc2);\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n  }\n}\nfunction findInDoc(doc, fn, defaultValue) {\n  let result = defaultValue;\n  let shouldSkipFurtherProcessing = false;\n  function findInDocOnEnterFn(doc2) {\n    if (shouldSkipFurtherProcessing) {\n      return false;\n    }\n    const maybeResult = fn(doc2);\n    if (maybeResult !== void 0) {\n      shouldSkipFurtherProcessing = true;\n      result = maybeResult;\n    }\n  }\n  traverse_doc_default(doc, findInDocOnEnterFn);\n  return result;\n}\nfunction willBreakFn(doc) {\n  if (doc.type === DOC_TYPE_GROUP && doc.break) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_LINE && doc.hard) {\n    return true;\n  }\n  if (doc.type === DOC_TYPE_BREAK_PARENT) {\n    return true;\n  }\n}\nfunction willBreak(doc) {\n  return findInDoc(doc, willBreakFn, false);\n}\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = at_default(\n      /* isOptionalObject*/\n      false,\n      groupStack,\n      -1\n    );\n    if (!parentGroup.expandedStates && !parentGroup.break) {\n      parentGroup.break = \"propagated\";\n    }\n  }\n  return null;\n}\nfunction propagateBreaks(doc) {\n  const alreadyVisitedSet = /* @__PURE__ */ new Set();\n  const groupStack = [];\n  function propagateBreaksOnEnterFn(doc2) {\n    if (doc2.type === DOC_TYPE_BREAK_PARENT) {\n      breakParentGroup(groupStack);\n    }\n    if (doc2.type === DOC_TYPE_GROUP) {\n      groupStack.push(doc2);\n      if (alreadyVisitedSet.has(doc2)) {\n        return false;\n      }\n      alreadyVisitedSet.add(doc2);\n    }\n  }\n  function propagateBreaksOnExitFn(doc2) {\n    if (doc2.type === DOC_TYPE_GROUP) {\n      const group2 = groupStack.pop();\n      if (group2.break) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n  traverse_doc_default(\n    doc,\n    propagateBreaksOnEnterFn,\n    propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true\n  );\n}\nfunction removeLinesFn(doc) {\n  if (doc.type === DOC_TYPE_LINE && !doc.hard) {\n    return doc.soft ? \"\" : \" \";\n  }\n  if (doc.type === DOC_TYPE_IF_BREAK) {\n    return doc.flatContents;\n  }\n  return doc;\n}\nfunction removeLines(doc) {\n  return mapDoc(doc, removeLinesFn);\n}\nfunction stripTrailingHardlineFromParts(parts) {\n  parts = [...parts];\n  while (parts.length >= 2 && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -2\n  ).type === DOC_TYPE_LINE && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -1\n  ).type === DOC_TYPE_BREAK_PARENT) {\n    parts.length -= 2;\n  }\n  if (parts.length > 0) {\n    const lastPart = stripTrailingHardlineFromDoc(at_default(\n      /* isOptionalObject*/\n      false,\n      parts,\n      -1\n    ));\n    parts[parts.length - 1] = lastPart;\n  }\n  return parts;\n}\nfunction stripTrailingHardlineFromDoc(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_GROUP:\n    case DOC_TYPE_LINE_SUFFIX:\n    case DOC_TYPE_LABEL: {\n      const contents = stripTrailingHardlineFromDoc(doc.contents);\n      return {\n        ...doc,\n        contents\n      };\n    }\n    case DOC_TYPE_IF_BREAK:\n      return {\n        ...doc,\n        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),\n        flatContents: stripTrailingHardlineFromDoc(doc.flatContents)\n      };\n    case DOC_TYPE_FILL:\n      return {\n        ...doc,\n        parts: stripTrailingHardlineFromParts(doc.parts)\n      };\n    case DOC_TYPE_ARRAY:\n      return stripTrailingHardlineFromParts(doc);\n    case DOC_TYPE_STRING:\n      return doc.replace(/[\\n\\r]*$/, \"\");\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction stripTrailingHardline(doc) {\n  return stripTrailingHardlineFromDoc(cleanDoc(doc));\n}\nfunction cleanDocFn(doc) {\n  switch (get_doc_type_default(doc)) {\n    case DOC_TYPE_FILL:\n      if (doc.parts.every((part) => part === \"\")) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_GROUP:\n      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {\n        return \"\";\n      }\n      if (doc.contents.type === DOC_TYPE_GROUP && doc.contents.id === doc.id && doc.contents.break === doc.break && doc.contents.expandedStates === doc.expandedStates) {\n        return doc.contents;\n      }\n      break;\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_LINE_SUFFIX:\n      if (!doc.contents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_IF_BREAK:\n      if (!doc.flatContents && !doc.breakContents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_ARRAY: {\n      const parts = [];\n      for (const part of doc) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];\n        if (typeof currentPart === \"string\" && typeof at_default(\n          /* isOptionalObject*/\n          false,\n          parts,\n          -1\n        ) === \"string\") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return \"\";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return parts;\n    }\n    case DOC_TYPE_STRING:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_LABEL:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc);\n  }\n  return doc;\n}\nfunction cleanDoc(doc) {\n  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));\n}\nfunction replaceEndOfLine(doc, replacement = literalline) {\n  return mapDoc(doc, (currentDoc) => typeof currentDoc === \"string\" ? join(replacement, currentDoc.split(\"\\n\")) : currentDoc);\n}\nfunction canBreakFn(doc) {\n  if (doc.type === DOC_TYPE_LINE) {\n    return true;\n  }\n}\nfunction canBreak(doc) {\n  return findInDoc(doc, canBreakFn, false);\n}\n\n// src/document/printer.js\nvar MODE_BREAK = Symbol(\"MODE_BREAK\");\nvar MODE_FLAT = Symbol(\"MODE_FLAT\");\nvar CURSOR_PLACEHOLDER = Symbol(\"cursor\");\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\nfunction makeIndent(ind, options) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options);\n}\nfunction makeAlign(indent2, widthOrDoc, options) {\n  if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n    return indent2.root || rootIndent();\n  }\n  if (widthOrDoc < 0) {\n    return generateInd(indent2, {\n      type: \"dedent\"\n    }, options);\n  }\n  if (!widthOrDoc) {\n    return indent2;\n  }\n  if (widthOrDoc.type === \"root\") {\n    return {\n      ...indent2,\n      root: indent2\n    };\n  }\n  const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n  return generateInd(indent2, {\n    type: alignType,\n    n: widthOrDoc\n  }, options);\n}\nfunction generateInd(ind, newPart, options) {\n  const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n  let value = \"\";\n  let length = 0;\n  let lastTabs = 0;\n  let lastSpaces = 0;\n  for (const part of queue) {\n    switch (part.type) {\n      case \"indent\":\n        flush();\n        if (options.useTabs) {\n          addTabs(1);\n        } else {\n          addSpaces(options.tabWidth);\n        }\n        break;\n      case \"stringAlign\":\n        flush();\n        value += part.n;\n        length += part.n.length;\n        break;\n      case \"numberAlign\":\n        lastTabs += 1;\n        lastSpaces += part.n;\n        break;\n      default:\n        throw new Error(`Unexpected type '${part.type}'`);\n    }\n  }\n  flushSpaces();\n  return {\n    ...ind,\n    value,\n    length,\n    queue\n  };\n  function addTabs(count) {\n    value += \"\t\".repeat(count);\n    length += options.tabWidth * count;\n  }\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n  function flush() {\n    if (options.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n    resetLast();\n  }\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n    resetLast();\n  }\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\nfunction trim2(out) {\n  let trimCount = 0;\n  let cursorCount = 0;\n  let outIndex = out.length;\n  outer:\n    while (outIndex--) {\n      const last = out[outIndex];\n      if (last === CURSOR_PLACEHOLDER) {\n        cursorCount++;\n        continue;\n      }\n      if (false) {\n        throw new Error(`Unexpected value in trim: '${typeof last}'`);\n      }\n      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {\n        const char = last[charIndex];\n        if (char === \" \" || char === \"\t\") {\n          trimCount++;\n        } else {\n          out[outIndex] = last.slice(0, charIndex + 1);\n          break outer;\n        }\n      }\n    }\n  if (trimCount > 0 || cursorCount > 0) {\n    out.length = outIndex + 1;\n    while (cursorCount-- > 0) {\n      out.push(CURSOR_PLACEHOLDER);\n    }\n  }\n  return trimCount;\n}\nfunction fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {\n  if (width === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  const out = [];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[--restIdx]);\n      continue;\n    }\n    const {\n      mode,\n      doc\n    } = cmds.pop();\n    switch (get_doc_type_default(doc)) {\n      case DOC_TYPE_STRING:\n        out.push(doc);\n        width -= get_string_width_default(doc);\n        break;\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = getDocParts(doc);\n        for (let i = parts.length - 1; i >= 0; i--) {\n          cmds.push({\n            mode,\n            doc: parts[i]\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          mode,\n          doc: doc.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        width += trim2(out);\n        break;\n      case DOC_TYPE_GROUP: {\n        if (mustBeFlat && doc.break) {\n          return false;\n        }\n        const groupMode = doc.break ? MODE_BREAK : mode;\n        const contents = doc.expandedStates && groupMode === MODE_BREAK ? at_default(\n          /* isOptionalObject*/\n          false,\n          doc.expandedStates,\n          -1\n        ) : doc.contents;\n        cmds.push({\n          mode: groupMode,\n          doc: contents\n        });\n        break;\n      }\n      case DOC_TYPE_IF_BREAK: {\n        const groupMode = doc.groupId ? groupModeMap[doc.groupId] || MODE_FLAT : mode;\n        const contents = groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;\n        if (contents) {\n          cmds.push({\n            mode,\n            doc: contents\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_LINE:\n        if (mode === MODE_BREAK || doc.hard) {\n          return true;\n        }\n        if (!doc.soft) {\n          out.push(\" \");\n          width--;\n        }\n        break;\n      case DOC_TYPE_LINE_SUFFIX:\n        hasLineSuffix = true;\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (hasLineSuffix) {\n          return false;\n        }\n        break;\n    }\n  }\n  return false;\n}\nfunction printDocToString(doc, options) {\n  const groupModeMap = {};\n  const width = options.printWidth;\n  const newLine = convertEndOfLineToChars(options.endOfLine);\n  let pos = 0;\n  const cmds = [{\n    ind: rootIndent(),\n    mode: MODE_BREAK,\n    doc\n  }];\n  const out = [];\n  let shouldRemeasure = false;\n  const lineSuffix2 = [];\n  let printedCursorCount = 0;\n  propagateBreaks(doc);\n  while (cmds.length > 0) {\n    const {\n      ind,\n      mode,\n      doc: doc2\n    } = cmds.pop();\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_STRING: {\n        const formatted = newLine !== \"\\n\" ? string_replace_all_default(\n          /* isOptionalObject*/\n          false,\n          doc2,\n          \"\\n\",\n          newLine\n        ) : doc2;\n        out.push(formatted);\n        if (cmds.length > 0) {\n          pos += get_string_width_default(formatted);\n        }\n        break;\n      }\n      case DOC_TYPE_ARRAY:\n        for (let i = doc2.length - 1; i >= 0; i--) {\n          cmds.push({\n            ind,\n            mode,\n            doc: doc2[i]\n          });\n        }\n        break;\n      case DOC_TYPE_CURSOR:\n        if (printedCursorCount >= 2) {\n          throw new Error(\"There are too many 'cursor' in doc.\");\n        }\n        out.push(CURSOR_PLACEHOLDER);\n        printedCursorCount++;\n        break;\n      case DOC_TYPE_INDENT:\n        cmds.push({\n          ind: makeIndent(ind, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_ALIGN:\n        cmds.push({\n          ind: makeAlign(ind, doc2.n, options),\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        pos -= trim2(out);\n        break;\n      case DOC_TYPE_GROUP:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!shouldRemeasure) {\n              cmds.push({\n                ind,\n                mode: doc2.break ? MODE_BREAK : MODE_FLAT,\n                doc: doc2.contents\n              });\n              break;\n            }\n          case MODE_BREAK: {\n            shouldRemeasure = false;\n            const next = {\n              ind,\n              mode: MODE_FLAT,\n              doc: doc2.contents\n            };\n            const rem = width - pos;\n            const hasLineSuffix = lineSuffix2.length > 0;\n            if (!doc2.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {\n              cmds.push(next);\n            } else {\n              if (doc2.expandedStates) {\n                const mostExpanded = at_default(\n                  /* isOptionalObject*/\n                  false,\n                  doc2.expandedStates,\n                  -1\n                );\n                if (doc2.break) {\n                  cmds.push({\n                    ind,\n                    mode: MODE_BREAK,\n                    doc: mostExpanded\n                  });\n                  break;\n                } else {\n                  for (let i = 1; i < doc2.expandedStates.length + 1; i++) {\n                    if (i >= doc2.expandedStates.length) {\n                      cmds.push({\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: mostExpanded\n                      });\n                      break;\n                    } else {\n                      const state = doc2.expandedStates[i];\n                      const cmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: state\n                      };\n                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {\n                        cmds.push(cmd);\n                        break;\n                      }\n                    }\n                  }\n                }\n              } else {\n                cmds.push({\n                  ind,\n                  mode: MODE_BREAK,\n                  doc: doc2.contents\n                });\n              }\n            }\n            break;\n          }\n        }\n        if (doc2.id) {\n          groupModeMap[doc2.id] = at_default(\n            /* isOptionalObject*/\n            false,\n            cmds,\n            -1\n          ).mode;\n        }\n        break;\n      case DOC_TYPE_FILL: {\n        const rem = width - pos;\n        const {\n          parts\n        } = doc2;\n        if (parts.length === 0) {\n          break;\n        }\n        const [content, whitespace] = parts;\n        const contentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: content\n        };\n        const contentBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: content\n        };\n        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (parts.length === 1) {\n          if (contentFits) {\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        const whitespaceFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: whitespace\n        };\n        const whitespaceBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: whitespace\n        };\n        if (parts.length === 2) {\n          if (contentFits) {\n            cmds.push(whitespaceFlatCmd, contentFlatCmd);\n          } else {\n            cmds.push(whitespaceBreakCmd, contentBreakCmd);\n          }\n          break;\n        }\n        parts.splice(0, 2);\n        const remainingCmd = {\n          ind,\n          mode,\n          doc: fill(parts)\n        };\n        const secondContent = parts[0];\n        const firstAndSecondContentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: [content, whitespace, secondContent]\n        };\n        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (firstAndSecondContentFits) {\n          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n        } else if (contentFits) {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n        } else {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n      case DOC_TYPE_INDENT_IF_BREAK: {\n        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] : mode;\n        if (groupMode === MODE_BREAK) {\n          const breakContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.breakContents : doc2.negate ? doc2.contents : indent(doc2.contents);\n          if (breakContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: breakContents\n            });\n          }\n        }\n        if (groupMode === MODE_FLAT) {\n          const flatContents = doc2.type === DOC_TYPE_IF_BREAK ? doc2.flatContents : doc2.negate ? indent(doc2.contents) : doc2.contents;\n          if (flatContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: flatContents\n            });\n          }\n        }\n        break;\n      }\n      case DOC_TYPE_LINE_SUFFIX:\n        lineSuffix2.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (lineSuffix2.length > 0) {\n          cmds.push({\n            ind,\n            mode,\n            doc: hardlineWithoutBreakParent\n          });\n        }\n        break;\n      case DOC_TYPE_LINE:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!doc2.hard) {\n              if (!doc2.soft) {\n                out.push(\" \");\n                pos += 1;\n              }\n              break;\n            } else {\n              shouldRemeasure = true;\n            }\n          case MODE_BREAK:\n            if (lineSuffix2.length > 0) {\n              cmds.push({\n                ind,\n                mode,\n                doc: doc2\n              }, ...lineSuffix2.reverse());\n              lineSuffix2.length = 0;\n              break;\n            }\n            if (doc2.literal) {\n              if (ind.root) {\n                out.push(newLine, ind.root.value);\n                pos = ind.root.length;\n              } else {\n                out.push(newLine);\n                pos = 0;\n              }\n            } else {\n              pos -= trim2(out);\n              out.push(newLine + ind.value);\n              pos = ind.length;\n            }\n            break;\n        }\n        break;\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          ind,\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc2);\n    }\n    if (cmds.length === 0 && lineSuffix2.length > 0) {\n      cmds.push(...lineSuffix2.reverse());\n      lineSuffix2.length = 0;\n    }\n  }\n  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);\n  if (cursorPlaceholderIndex !== -1) {\n    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\n// src/document/public.js\nvar builders = {\n  join,\n  line,\n  softline,\n  hardline,\n  literalline,\n  group,\n  conditionalGroup,\n  fill,\n  lineSuffix,\n  lineSuffixBoundary,\n  cursor,\n  breakParent,\n  ifBreak,\n  trim,\n  indent,\n  indentIfBreak,\n  align,\n  addAlignmentToDoc,\n  markAsRoot,\n  dedentToRoot,\n  dedent,\n  hardlineWithoutBreakParent,\n  literallineWithoutBreakParent,\n  label,\n  // TODO: Remove this in v4\n  concat: (parts) => parts\n};\nvar printer = { printDocToString };\nvar utils = {\n  willBreak,\n  traverseDoc: traverse_doc_default,\n  findInDoc,\n  mapDoc,\n  removeLines,\n  stripTrailingHardline,\n  replaceEndOfLine,\n  canBreak\n};\n\n// with-default-export:src/document/public.js\nvar public_default = public_exports;\nexport {\n  builders,\n  public_default as default,\n  printer,\n  utils\n};\n","import { createRequire as __prettierCreateRequire } from \"module\";\nimport { fileURLToPath as __prettierFileUrlToPath } from \"url\";\nimport { dirname as __prettierDirname } from \"path\";\nconst require = __prettierCreateRequire(import.meta.url);\nconst __filename = __prettierFileUrlToPath(import.meta.url);\nconst __dirname = __prettierDirname(__filename);\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;\nvar __require = /* @__PURE__ */ ((x) => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function(x) {\n  if (typeof require !== \"undefined\")\n    return require.apply(this, arguments);\n  throw Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __commonJS = (cb, mod) => function __require2() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key2 of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key2) && key2 !== except)\n        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key2, value) => {\n  __defNormalProp(obj, typeof key2 !== \"symbol\" ? key2 + \"\" : key2, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// node_modules/fast-glob/out/utils/array.js\nvar require_array = __commonJS({\n  \"node_modules/fast-glob/out/utils/array.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.splitWhen = exports.flatten = void 0;\n    function flatten(items) {\n      return items.reduce((collection, item) => [].concat(collection, item), []);\n    }\n    exports.flatten = flatten;\n    function splitWhen(items, predicate) {\n      const result = [[]];\n      let groupIndex = 0;\n      for (const item of items) {\n        if (predicate(item)) {\n          groupIndex++;\n          result[groupIndex] = [];\n        } else {\n          result[groupIndex].push(item);\n        }\n      }\n      return result;\n    }\n    exports.splitWhen = splitWhen;\n  }\n});\n\n// node_modules/fast-glob/out/utils/errno.js\nvar require_errno = __commonJS({\n  \"node_modules/fast-glob/out/utils/errno.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isEnoentCodeError = void 0;\n    function isEnoentCodeError(error) {\n      return error.code === \"ENOENT\";\n    }\n    exports.isEnoentCodeError = isEnoentCodeError;\n  }\n});\n\n// node_modules/fast-glob/out/utils/fs.js\nvar require_fs = __commonJS({\n  \"node_modules/fast-glob/out/utils/fs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.createDirentFromStats = void 0;\n    var DirentFromStats = class {\n      constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n      }\n    };\n    function createDirentFromStats(name, stats) {\n      return new DirentFromStats(name, stats);\n    }\n    exports.createDirentFromStats = createDirentFromStats;\n  }\n});\n\n// node_modules/fast-glob/out/utils/path.js\nvar require_path = __commonJS({\n  \"node_modules/fast-glob/out/utils/path.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.convertPosixPathToPattern = exports.convertWindowsPathToPattern = exports.convertPathToPattern = exports.escapePosixPath = exports.escapeWindowsPath = exports.escape = exports.removeLeadingDotSegment = exports.makeAbsolute = exports.unixify = void 0;\n    var os2 = __require(\"os\");\n    var path13 = __require(\"path\");\n    var IS_WINDOWS_PLATFORM = os2.platform() === \"win32\";\n    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;\n    var POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\()|\\\\(?![!()*+?@[\\]{|}]))/g;\n    var WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()[\\]{}]|^!|[!+@](?=\\())/g;\n    var DOS_DEVICE_PATH_RE = /^\\\\\\\\([.?])/;\n    var WINDOWS_BACKSLASHES_RE = /\\\\(?![!()+@[\\]{}])/g;\n    function unixify(filepath) {\n      return filepath.replace(/\\\\/g, \"/\");\n    }\n    exports.unixify = unixify;\n    function makeAbsolute(cwd, filepath) {\n      return path13.resolve(cwd, filepath);\n    }\n    exports.makeAbsolute = makeAbsolute;\n    function removeLeadingDotSegment(entry) {\n      if (entry.charAt(0) === \".\") {\n        const secondCharactery = entry.charAt(1);\n        if (secondCharactery === \"/\" || secondCharactery === \"\\\\\") {\n          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\n        }\n      }\n      return entry;\n    }\n    exports.removeLeadingDotSegment = removeLeadingDotSegment;\n    exports.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;\n    function escapeWindowsPath(pattern) {\n      return pattern.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, \"\\\\$2\");\n    }\n    exports.escapeWindowsPath = escapeWindowsPath;\n    function escapePosixPath(pattern) {\n      return pattern.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, \"\\\\$2\");\n    }\n    exports.escapePosixPath = escapePosixPath;\n    exports.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;\n    function convertWindowsPathToPattern(filepath) {\n      return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, \"//$1\").replace(WINDOWS_BACKSLASHES_RE, \"/\");\n    }\n    exports.convertWindowsPathToPattern = convertWindowsPathToPattern;\n    function convertPosixPathToPattern(filepath) {\n      return escapePosixPath(filepath);\n    }\n    exports.convertPosixPathToPattern = convertPosixPathToPattern;\n  }\n});\n\n// node_modules/is-extglob/index.js\nvar require_is_extglob = __commonJS({\n  \"node_modules/is-extglob/index.js\"(exports, module) {\n    module.exports = function isExtglob(str2) {\n      if (typeof str2 !== \"string\" || str2 === \"\") {\n        return false;\n      }\n      var match;\n      while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str2)) {\n        if (match[2])\n          return true;\n        str2 = str2.slice(match.index + match[0].length);\n      }\n      return false;\n    };\n  }\n});\n\n// node_modules/is-glob/index.js\nvar require_is_glob = __commonJS({\n  \"node_modules/is-glob/index.js\"(exports, module) {\n    var isExtglob = require_is_extglob();\n    var chars = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };\n    var strictCheck = function(str2) {\n      if (str2[0] === \"!\") {\n        return true;\n      }\n      var index = 0;\n      var pipeIndex = -2;\n      var closeSquareIndex = -2;\n      var closeCurlyIndex = -2;\n      var closeParenIndex = -2;\n      var backSlashIndex = -2;\n      while (index < str2.length) {\n        if (str2[index] === \"*\") {\n          return true;\n        }\n        if (str2[index + 1] === \"?\" && /[\\].+)]/.test(str2[index])) {\n          return true;\n        }\n        if (closeSquareIndex !== -1 && str2[index] === \"[\" && str2[index + 1] !== \"]\") {\n          if (closeSquareIndex < index) {\n            closeSquareIndex = str2.indexOf(\"]\", index);\n          }\n          if (closeSquareIndex > index) {\n            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n              return true;\n            }\n            backSlashIndex = str2.indexOf(\"\\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n              return true;\n            }\n          }\n        }\n        if (closeCurlyIndex !== -1 && str2[index] === \"{\" && str2[index + 1] !== \"}\") {\n          closeCurlyIndex = str2.indexOf(\"}\", index);\n          if (closeCurlyIndex > index) {\n            backSlashIndex = str2.indexOf(\"\\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n              return true;\n            }\n          }\n        }\n        if (closeParenIndex !== -1 && str2[index] === \"(\" && str2[index + 1] === \"?\" && /[:!=]/.test(str2[index + 2]) && str2[index + 3] !== \")\") {\n          closeParenIndex = str2.indexOf(\")\", index);\n          if (closeParenIndex > index) {\n            backSlashIndex = str2.indexOf(\"\\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n              return true;\n            }\n          }\n        }\n        if (pipeIndex !== -1 && str2[index] === \"(\" && str2[index + 1] !== \"|\") {\n          if (pipeIndex < index) {\n            pipeIndex = str2.indexOf(\"|\", index);\n          }\n          if (pipeIndex !== -1 && str2[pipeIndex + 1] !== \")\") {\n            closeParenIndex = str2.indexOf(\")\", pipeIndex);\n            if (closeParenIndex > pipeIndex) {\n              backSlashIndex = str2.indexOf(\"\\\\\", pipeIndex);\n              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n                return true;\n              }\n            }\n          }\n        }\n        if (str2[index] === \"\\\\\") {\n          var open = str2[index + 1];\n          index += 2;\n          var close = chars[open];\n          if (close) {\n            var n = str2.indexOf(close, index);\n            if (n !== -1) {\n              index = n + 1;\n            }\n          }\n          if (str2[index] === \"!\") {\n            return true;\n          }\n        } else {\n          index++;\n        }\n      }\n      return false;\n    };\n    var relaxedCheck = function(str2) {\n      if (str2[0] === \"!\") {\n        return true;\n      }\n      var index = 0;\n      while (index < str2.length) {\n        if (/[*?{}()[\\]]/.test(str2[index])) {\n          return true;\n        }\n        if (str2[index] === \"\\\\\") {\n          var open = str2[index + 1];\n          index += 2;\n          var close = chars[open];\n          if (close) {\n            var n = str2.indexOf(close, index);\n            if (n !== -1) {\n              index = n + 1;\n            }\n          }\n          if (str2[index] === \"!\") {\n            return true;\n          }\n        } else {\n          index++;\n        }\n      }\n      return false;\n    };\n    module.exports = function isGlob(str2, options8) {\n      if (typeof str2 !== \"string\" || str2 === \"\") {\n        return false;\n      }\n      if (isExtglob(str2)) {\n        return true;\n      }\n      var check2 = strictCheck;\n      if (options8 && options8.strict === false) {\n        check2 = relaxedCheck;\n      }\n      return check2(str2);\n    };\n  }\n});\n\n// node_modules/glob-parent/index.js\nvar require_glob_parent = __commonJS({\n  \"node_modules/glob-parent/index.js\"(exports, module) {\n    \"use strict\";\n    var isGlob = require_is_glob();\n    var pathPosixDirname = __require(\"path\").posix.dirname;\n    var isWin32 = __require(\"os\").platform() === \"win32\";\n    var slash2 = \"/\";\n    var backslash = /\\\\/g;\n    var enclosure = /[\\{\\[].*[\\}\\]]$/;\n    var globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\n    var escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n    module.exports = function globParent(str2, opts) {\n      var options8 = Object.assign({ flipBackslashes: true }, opts);\n      if (options8.flipBackslashes && isWin32 && str2.indexOf(slash2) < 0) {\n        str2 = str2.replace(backslash, slash2);\n      }\n      if (enclosure.test(str2)) {\n        str2 += slash2;\n      }\n      str2 += \"a\";\n      do {\n        str2 = pathPosixDirname(str2);\n      } while (isGlob(str2) || globby.test(str2));\n      return str2.replace(escaped, \"$1\");\n    };\n  }\n});\n\n// node_modules/braces/lib/utils.js\nvar require_utils = __commonJS({\n  \"node_modules/braces/lib/utils.js\"(exports) {\n    \"use strict\";\n    exports.isInteger = (num) => {\n      if (typeof num === \"number\") {\n        return Number.isInteger(num);\n      }\n      if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isInteger(Number(num));\n      }\n      return false;\n    };\n    exports.find = (node, type2) => node.nodes.find((node2) => node2.type === type2);\n    exports.exceedsLimit = (min, max, step = 1, limit) => {\n      if (limit === false)\n        return false;\n      if (!exports.isInteger(min) || !exports.isInteger(max))\n        return false;\n      return (Number(max) - Number(min)) / Number(step) >= limit;\n    };\n    exports.escapeNode = (block, n = 0, type2) => {\n      let node = block.nodes[n];\n      if (!node)\n        return;\n      if (type2 && node.type === type2 || node.type === \"open\" || node.type === \"close\") {\n        if (node.escaped !== true) {\n          node.value = \"\\\\\" + node.value;\n          node.escaped = true;\n        }\n      }\n    };\n    exports.encloseBrace = (node) => {\n      if (node.type !== \"brace\")\n        return false;\n      if (node.commas >> 0 + node.ranges >> 0 === 0) {\n        node.invalid = true;\n        return true;\n      }\n      return false;\n    };\n    exports.isInvalidBrace = (block) => {\n      if (block.type !== \"brace\")\n        return false;\n      if (block.invalid === true || block.dollar)\n        return true;\n      if (block.commas >> 0 + block.ranges >> 0 === 0) {\n        block.invalid = true;\n        return true;\n      }\n      if (block.open !== true || block.close !== true) {\n        block.invalid = true;\n        return true;\n      }\n      return false;\n    };\n    exports.isOpenOrClose = (node) => {\n      if (node.type === \"open\" || node.type === \"close\") {\n        return true;\n      }\n      return node.open === true || node.close === true;\n    };\n    exports.reduce = (nodes) => nodes.reduce((acc, node) => {\n      if (node.type === \"text\")\n        acc.push(node.value);\n      if (node.type === \"range\")\n        node.type = \"text\";\n      return acc;\n    }, []);\n    exports.flatten = (...args) => {\n      const result = [];\n      const flat = (arr) => {\n        for (let i = 0; i < arr.length; i++) {\n          let ele = arr[i];\n          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n        }\n        return result;\n      };\n      flat(args);\n      return result;\n    };\n  }\n});\n\n// node_modules/braces/lib/stringify.js\nvar require_stringify = __commonJS({\n  \"node_modules/braces/lib/stringify.js\"(exports, module) {\n    \"use strict\";\n    var utils = require_utils();\n    module.exports = (ast, options8 = {}) => {\n      let stringify = (node, parent = {}) => {\n        let invalidBlock = options8.escapeInvalid && utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options8.escapeInvalid === true;\n        let output = \"\";\n        if (node.value) {\n          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n            return \"\\\\\" + node.value;\n          }\n          return node.value;\n        }\n        if (node.value) {\n          return node.value;\n        }\n        if (node.nodes) {\n          for (let child of node.nodes) {\n            output += stringify(child);\n          }\n        }\n        return output;\n      };\n      return stringify(ast);\n    };\n  }\n});\n\n// node_modules/is-number/index.js\nvar require_is_number = __commonJS({\n  \"node_modules/is-number/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = function(num) {\n      if (typeof num === \"number\") {\n        return num - num === 0;\n      }\n      if (typeof num === \"string\" && num.trim() !== \"\") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n      }\n      return false;\n    };\n  }\n});\n\n// node_modules/to-regex-range/index.js\nvar require_to_regex_range = __commonJS({\n  \"node_modules/to-regex-range/index.js\"(exports, module) {\n    \"use strict\";\n    var isNumber = require_is_number();\n    var toRegexRange = (min, max, options8) => {\n      if (isNumber(min) === false) {\n        throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n      }\n      if (max === void 0 || min === max) {\n        return String(min);\n      }\n      if (isNumber(max) === false) {\n        throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n      }\n      let opts = { relaxZeros: true, ...options8 };\n      if (typeof opts.strictZeros === \"boolean\") {\n        opts.relaxZeros = opts.strictZeros === false;\n      }\n      let relax = String(opts.relaxZeros);\n      let shorthand = String(opts.shorthand);\n      let capture = String(opts.capture);\n      let wrap = String(opts.wrap);\n      let cacheKey = min + \":\" + max + \"=\" + relax + shorthand + capture + wrap;\n      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n        return toRegexRange.cache[cacheKey].result;\n      }\n      let a = Math.min(min, max);\n      let b = Math.max(min, max);\n      if (Math.abs(a - b) === 1) {\n        let result = min + \"|\" + max;\n        if (opts.capture) {\n          return `(${result})`;\n        }\n        if (opts.wrap === false) {\n          return result;\n        }\n        return `(?:${result})`;\n      }\n      let isPadded = hasPadding(min) || hasPadding(max);\n      let state = { min, max, a, b };\n      let positives = [];\n      let negatives = [];\n      if (isPadded) {\n        state.isPadded = isPadded;\n        state.maxLen = String(state.max).length;\n      }\n      if (a < 0) {\n        let newMin = b < 0 ? Math.abs(b) : 1;\n        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n        a = state.a = 0;\n      }\n      if (b >= 0) {\n        positives = splitToPatterns(a, b, state, opts);\n      }\n      state.negatives = negatives;\n      state.positives = positives;\n      state.result = collatePatterns(negatives, positives, opts);\n      if (opts.capture === true) {\n        state.result = `(${state.result})`;\n      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n        state.result = `(?:${state.result})`;\n      }\n      toRegexRange.cache[cacheKey] = state;\n      return state.result;\n    };\n    function collatePatterns(neg, pos2, options8) {\n      let onlyNegative = filterPatterns(neg, pos2, \"-\", false, options8) || [];\n      let onlyPositive = filterPatterns(pos2, neg, \"\", false, options8) || [];\n      let intersected = filterPatterns(neg, pos2, \"-?\", true, options8) || [];\n      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n      return subpatterns.join(\"|\");\n    }\n    function splitToRanges(min, max) {\n      let nines = 1;\n      let zeros = 1;\n      let stop = countNines(min, nines);\n      let stops = /* @__PURE__ */ new Set([max]);\n      while (min <= stop && stop <= max) {\n        stops.add(stop);\n        nines += 1;\n        stop = countNines(min, nines);\n      }\n      stop = countZeros(max + 1, zeros) - 1;\n      while (min < stop && stop <= max) {\n        stops.add(stop);\n        zeros += 1;\n        stop = countZeros(max + 1, zeros) - 1;\n      }\n      stops = [...stops];\n      stops.sort(compare);\n      return stops;\n    }\n    function rangeToPattern(start, stop, options8) {\n      if (start === stop) {\n        return { pattern: start, count: [], digits: 0 };\n      }\n      let zipped = zip(start, stop);\n      let digits = zipped.length;\n      let pattern = \"\";\n      let count = 0;\n      for (let i = 0; i < digits; i++) {\n        let [startDigit, stopDigit] = zipped[i];\n        if (startDigit === stopDigit) {\n          pattern += startDigit;\n        } else if (startDigit !== \"0\" || stopDigit !== \"9\") {\n          pattern += toCharacterClass(startDigit, stopDigit, options8);\n        } else {\n          count++;\n        }\n      }\n      if (count) {\n        pattern += options8.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n      }\n      return { pattern, count: [count], digits };\n    }\n    function splitToPatterns(min, max, tok, options8) {\n      let ranges = splitToRanges(min, max);\n      let tokens = [];\n      let start = min;\n      let prev;\n      for (let i = 0; i < ranges.length; i++) {\n        let max2 = ranges[i];\n        let obj = rangeToPattern(String(start), String(max2), options8);\n        let zeros = \"\";\n        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n          if (prev.count.length > 1) {\n            prev.count.pop();\n          }\n          prev.count.push(obj.count[0]);\n          prev.string = prev.pattern + toQuantifier(prev.count);\n          start = max2 + 1;\n          continue;\n        }\n        if (tok.isPadded) {\n          zeros = padZeros(max2, tok, options8);\n        }\n        obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n        tokens.push(obj);\n        start = max2 + 1;\n        prev = obj;\n      }\n      return tokens;\n    }\n    function filterPatterns(arr, comparison, prefix, intersection, options8) {\n      let result = [];\n      for (let ele of arr) {\n        let { string } = ele;\n        if (!intersection && !contains(comparison, \"string\", string)) {\n          result.push(prefix + string);\n        }\n        if (intersection && contains(comparison, \"string\", string)) {\n          result.push(prefix + string);\n        }\n      }\n      return result;\n    }\n    function zip(a, b) {\n      let arr = [];\n      for (let i = 0; i < a.length; i++)\n        arr.push([a[i], b[i]]);\n      return arr;\n    }\n    function compare(a, b) {\n      return a > b ? 1 : b > a ? -1 : 0;\n    }\n    function contains(arr, key2, val) {\n      return arr.some((ele) => ele[key2] === val);\n    }\n    function countNines(min, len) {\n      return Number(String(min).slice(0, -len) + \"9\".repeat(len));\n    }\n    function countZeros(integer, zeros) {\n      return integer - integer % Math.pow(10, zeros);\n    }\n    function toQuantifier(digits) {\n      let [start = 0, stop = \"\"] = digits;\n      if (stop || start > 1) {\n        return `{${start + (stop ? \",\" + stop : \"\")}}`;\n      }\n      return \"\";\n    }\n    function toCharacterClass(a, b, options8) {\n      return `[${a}${b - a === 1 ? \"\" : \"-\"}${b}]`;\n    }\n    function hasPadding(str2) {\n      return /^-?(0+)\\d/.test(str2);\n    }\n    function padZeros(value, tok, options8) {\n      if (!tok.isPadded) {\n        return value;\n      }\n      let diff = Math.abs(tok.maxLen - String(value).length);\n      let relax = options8.relaxZeros !== false;\n      switch (diff) {\n        case 0:\n          return \"\";\n        case 1:\n          return relax ? \"0?\" : \"0\";\n        case 2:\n          return relax ? \"0{0,2}\" : \"00\";\n        default: {\n          return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n      }\n    }\n    toRegexRange.cache = {};\n    toRegexRange.clearCache = () => toRegexRange.cache = {};\n    module.exports = toRegexRange;\n  }\n});\n\n// node_modules/fill-range/index.js\nvar require_fill_range = __commonJS({\n  \"node_modules/fill-range/index.js\"(exports, module) {\n    \"use strict\";\n    var util2 = __require(\"util\");\n    var toRegexRange = require_to_regex_range();\n    var isObject3 = (val) => val !== null && typeof val === \"object\" && !Array.isArray(val);\n    var transform = (toNumber) => {\n      return (value) => toNumber === true ? Number(value) : String(value);\n    };\n    var isValidValue = (value) => {\n      return typeof value === \"number\" || typeof value === \"string\" && value !== \"\";\n    };\n    var isNumber = (num) => Number.isInteger(+num);\n    var zeros = (input) => {\n      let value = `${input}`;\n      let index = -1;\n      if (value[0] === \"-\")\n        value = value.slice(1);\n      if (value === \"0\")\n        return false;\n      while (value[++index] === \"0\")\n        ;\n      return index > 0;\n    };\n    var stringify = (start, end, options8) => {\n      if (typeof start === \"string\" || typeof end === \"string\") {\n        return true;\n      }\n      return options8.stringify === true;\n    };\n    var pad = (input, maxLength, toNumber) => {\n      if (maxLength > 0) {\n        let dash = input[0] === \"-\" ? \"-\" : \"\";\n        if (dash)\n          input = input.slice(1);\n        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, \"0\");\n      }\n      if (toNumber === false) {\n        return String(input);\n      }\n      return input;\n    };\n    var toMaxLen = (input, maxLength) => {\n      let negative = input[0] === \"-\" ? \"-\" : \"\";\n      if (negative) {\n        input = input.slice(1);\n        maxLength--;\n      }\n      while (input.length < maxLength)\n        input = \"0\" + input;\n      return negative ? \"-\" + input : input;\n    };\n    var toSequence = (parts, options8) => {\n      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n      let prefix = options8.capture ? \"\" : \"?:\";\n      let positives = \"\";\n      let negatives = \"\";\n      let result;\n      if (parts.positives.length) {\n        positives = parts.positives.join(\"|\");\n      }\n      if (parts.negatives.length) {\n        negatives = `-(${prefix}${parts.negatives.join(\"|\")})`;\n      }\n      if (positives && negatives) {\n        result = `${positives}|${negatives}`;\n      } else {\n        result = positives || negatives;\n      }\n      if (options8.wrap) {\n        return `(${prefix}${result})`;\n      }\n      return result;\n    };\n    var toRange = (a, b, isNumbers, options8) => {\n      if (isNumbers) {\n        return toRegexRange(a, b, { wrap: false, ...options8 });\n      }\n      let start = String.fromCharCode(a);\n      if (a === b)\n        return start;\n      let stop = String.fromCharCode(b);\n      return `[${start}-${stop}]`;\n    };\n    var toRegex = (start, end, options8) => {\n      if (Array.isArray(start)) {\n        let wrap = options8.wrap === true;\n        let prefix = options8.capture ? \"\" : \"?:\";\n        return wrap ? `(${prefix}${start.join(\"|\")})` : start.join(\"|\");\n      }\n      return toRegexRange(start, end, options8);\n    };\n    var rangeError = (...args) => {\n      return new RangeError(\"Invalid range arguments: \" + util2.inspect(...args));\n    };\n    var invalidRange = (start, end, options8) => {\n      if (options8.strictRanges === true)\n        throw rangeError([start, end]);\n      return [];\n    };\n    var invalidStep = (step, options8) => {\n      if (options8.strictRanges === true) {\n        throw new TypeError(`Expected step \"${step}\" to be a number`);\n      }\n      return [];\n    };\n    var fillNumbers = (start, end, step = 1, options8 = {}) => {\n      let a = Number(start);\n      let b = Number(end);\n      if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        if (options8.strictRanges === true)\n          throw rangeError([start, end]);\n        return [];\n      }\n      if (a === 0)\n        a = 0;\n      if (b === 0)\n        b = 0;\n      let descending = a > b;\n      let startString = String(start);\n      let endString = String(end);\n      let stepString = String(step);\n      step = Math.max(Math.abs(step), 1);\n      let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n      let toNumber = padded === false && stringify(start, end, options8) === false;\n      let format3 = options8.transform || transform(toNumber);\n      if (options8.toRegex && step === 1) {\n        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options8);\n      }\n      let parts = { negatives: [], positives: [] };\n      let push2 = (num) => parts[num < 0 ? \"negatives\" : \"positives\"].push(Math.abs(num));\n      let range = [];\n      let index = 0;\n      while (descending ? a >= b : a <= b) {\n        if (options8.toRegex === true && step > 1) {\n          push2(a);\n        } else {\n          range.push(pad(format3(a, index), maxLen, toNumber));\n        }\n        a = descending ? a - step : a + step;\n        index++;\n      }\n      if (options8.toRegex === true) {\n        return step > 1 ? toSequence(parts, options8) : toRegex(range, null, { wrap: false, ...options8 });\n      }\n      return range;\n    };\n    var fillLetters = (start, end, step = 1, options8 = {}) => {\n      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n        return invalidRange(start, end, options8);\n      }\n      let format3 = options8.transform || ((val) => String.fromCharCode(val));\n      let a = `${start}`.charCodeAt(0);\n      let b = `${end}`.charCodeAt(0);\n      let descending = a > b;\n      let min = Math.min(a, b);\n      let max = Math.max(a, b);\n      if (options8.toRegex && step === 1) {\n        return toRange(min, max, false, options8);\n      }\n      let range = [];\n      let index = 0;\n      while (descending ? a >= b : a <= b) {\n        range.push(format3(a, index));\n        a = descending ? a - step : a + step;\n        index++;\n      }\n      if (options8.toRegex === true) {\n        return toRegex(range, null, { wrap: false, options: options8 });\n      }\n      return range;\n    };\n    var fill2 = (start, end, step, options8 = {}) => {\n      if (end == null && isValidValue(start)) {\n        return [start];\n      }\n      if (!isValidValue(start) || !isValidValue(end)) {\n        return invalidRange(start, end, options8);\n      }\n      if (typeof step === \"function\") {\n        return fill2(start, end, 1, { transform: step });\n      }\n      if (isObject3(step)) {\n        return fill2(start, end, 0, step);\n      }\n      let opts = { ...options8 };\n      if (opts.capture === true)\n        opts.wrap = true;\n      step = step || opts.step || 1;\n      if (!isNumber(step)) {\n        if (step != null && !isObject3(step))\n          return invalidStep(step, opts);\n        return fill2(start, end, 1, step);\n      }\n      if (isNumber(start) && isNumber(end)) {\n        return fillNumbers(start, end, step, opts);\n      }\n      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n    };\n    module.exports = fill2;\n  }\n});\n\n// node_modules/braces/lib/compile.js\nvar require_compile = __commonJS({\n  \"node_modules/braces/lib/compile.js\"(exports, module) {\n    \"use strict\";\n    var fill2 = require_fill_range();\n    var utils = require_utils();\n    var compile = (ast, options8 = {}) => {\n      let walk = (node, parent = {}) => {\n        let invalidBlock = utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options8.escapeInvalid === true;\n        let invalid = invalidBlock === true || invalidNode === true;\n        let prefix = options8.escapeInvalid === true ? \"\\\\\" : \"\";\n        let output = \"\";\n        if (node.isOpen === true) {\n          return prefix + node.value;\n        }\n        if (node.isClose === true) {\n          return prefix + node.value;\n        }\n        if (node.type === \"open\") {\n          return invalid ? prefix + node.value : \"(\";\n        }\n        if (node.type === \"close\") {\n          return invalid ? prefix + node.value : \")\";\n        }\n        if (node.type === \"comma\") {\n          return node.prev.type === \"comma\" ? \"\" : invalid ? node.value : \"|\";\n        }\n        if (node.value) {\n          return node.value;\n        }\n        if (node.nodes && node.ranges > 0) {\n          let args = utils.reduce(node.nodes);\n          let range = fill2(...args, { ...options8, wrap: false, toRegex: true });\n          if (range.length !== 0) {\n            return args.length > 1 && range.length > 1 ? `(${range})` : range;\n          }\n        }\n        if (node.nodes) {\n          for (let child of node.nodes) {\n            output += walk(child, node);\n          }\n        }\n        return output;\n      };\n      return walk(ast);\n    };\n    module.exports = compile;\n  }\n});\n\n// node_modules/braces/lib/expand.js\nvar require_expand = __commonJS({\n  \"node_modules/braces/lib/expand.js\"(exports, module) {\n    \"use strict\";\n    var fill2 = require_fill_range();\n    var stringify = require_stringify();\n    var utils = require_utils();\n    var append = (queue = \"\", stash = \"\", enclose = false) => {\n      let result = [];\n      queue = [].concat(queue);\n      stash = [].concat(stash);\n      if (!stash.length)\n        return queue;\n      if (!queue.length) {\n        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;\n      }\n      for (let item of queue) {\n        if (Array.isArray(item)) {\n          for (let value of item) {\n            result.push(append(value, stash, enclose));\n          }\n        } else {\n          for (let ele of stash) {\n            if (enclose === true && typeof ele === \"string\")\n              ele = `{${ele}}`;\n            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n          }\n        }\n      }\n      return utils.flatten(result);\n    };\n    var expand = (ast, options8 = {}) => {\n      let rangeLimit = options8.rangeLimit === void 0 ? 1e3 : options8.rangeLimit;\n      let walk = (node, parent = {}) => {\n        node.queue = [];\n        let p = parent;\n        let q = parent.queue;\n        while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {\n          p = p.parent;\n          q = p.queue;\n        }\n        if (node.invalid || node.dollar) {\n          q.push(append(q.pop(), stringify(node, options8)));\n          return;\n        }\n        if (node.type === \"brace\" && node.invalid !== true && node.nodes.length === 2) {\n          q.push(append(q.pop(), [\"{}\"]));\n          return;\n        }\n        if (node.nodes && node.ranges > 0) {\n          let args = utils.reduce(node.nodes);\n          if (utils.exceedsLimit(...args, options8.step, rangeLimit)) {\n            throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n          }\n          let range = fill2(...args, options8);\n          if (range.length === 0) {\n            range = stringify(node, options8);\n          }\n          q.push(append(q.pop(), range));\n          node.nodes = [];\n          return;\n        }\n        let enclose = utils.encloseBrace(node);\n        let queue = node.queue;\n        let block = node;\n        while (block.type !== \"brace\" && block.type !== \"root\" && block.parent) {\n          block = block.parent;\n          queue = block.queue;\n        }\n        for (let i = 0; i < node.nodes.length; i++) {\n          let child = node.nodes[i];\n          if (child.type === \"comma\" && node.type === \"brace\") {\n            if (i === 1)\n              queue.push(\"\");\n            queue.push(\"\");\n            continue;\n          }\n          if (child.type === \"close\") {\n            q.push(append(q.pop(), queue, enclose));\n            continue;\n          }\n          if (child.value && child.type !== \"open\") {\n            queue.push(append(queue.pop(), child.value));\n            continue;\n          }\n          if (child.nodes) {\n            walk(child, node);\n          }\n        }\n        return queue;\n      };\n      return utils.flatten(walk(ast));\n    };\n    module.exports = expand;\n  }\n});\n\n// node_modules/braces/lib/constants.js\nvar require_constants = __commonJS({\n  \"node_modules/braces/lib/constants.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      MAX_LENGTH: 1024 * 64,\n      // Digits\n      CHAR_0: \"0\",\n      /* 0 */\n      CHAR_9: \"9\",\n      /* 9 */\n      // Alphabet chars.\n      CHAR_UPPERCASE_A: \"A\",\n      /* A */\n      CHAR_LOWERCASE_A: \"a\",\n      /* a */\n      CHAR_UPPERCASE_Z: \"Z\",\n      /* Z */\n      CHAR_LOWERCASE_Z: \"z\",\n      /* z */\n      CHAR_LEFT_PARENTHESES: \"(\",\n      /* ( */\n      CHAR_RIGHT_PARENTHESES: \")\",\n      /* ) */\n      CHAR_ASTERISK: \"*\",\n      /* * */\n      // Non-alphabetic chars.\n      CHAR_AMPERSAND: \"&\",\n      /* & */\n      CHAR_AT: \"@\",\n      /* @ */\n      CHAR_BACKSLASH: \"\\\\\",\n      /* \\ */\n      CHAR_BACKTICK: \"`\",\n      /* ` */\n      CHAR_CARRIAGE_RETURN: \"\\r\",\n      /* \\r */\n      CHAR_CIRCUMFLEX_ACCENT: \"^\",\n      /* ^ */\n      CHAR_COLON: \":\",\n      /* : */\n      CHAR_COMMA: \",\",\n      /* , */\n      CHAR_DOLLAR: \"$\",\n      /* . */\n      CHAR_DOT: \".\",\n      /* . */\n      CHAR_DOUBLE_QUOTE: '\"',\n      /* \" */\n      CHAR_EQUAL: \"=\",\n      /* = */\n      CHAR_EXCLAMATION_MARK: \"!\",\n      /* ! */\n      CHAR_FORM_FEED: \"\\f\",\n      /* \\f */\n      CHAR_FORWARD_SLASH: \"/\",\n      /* / */\n      CHAR_HASH: \"#\",\n      /* # */\n      CHAR_HYPHEN_MINUS: \"-\",\n      /* - */\n      CHAR_LEFT_ANGLE_BRACKET: \"<\",\n      /* < */\n      CHAR_LEFT_CURLY_BRACE: \"{\",\n      /* { */\n      CHAR_LEFT_SQUARE_BRACKET: \"[\",\n      /* [ */\n      CHAR_LINE_FEED: \"\\n\",\n      /* \\n */\n      CHAR_NO_BREAK_SPACE: \"\\xA0\",\n      /* \\u00A0 */\n      CHAR_PERCENT: \"%\",\n      /* % */\n      CHAR_PLUS: \"+\",\n      /* + */\n      CHAR_QUESTION_MARK: \"?\",\n      /* ? */\n      CHAR_RIGHT_ANGLE_BRACKET: \">\",\n      /* > */\n      CHAR_RIGHT_CURLY_BRACE: \"}\",\n      /* } */\n      CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n      /* ] */\n      CHAR_SEMICOLON: \";\",\n      /* ; */\n      CHAR_SINGLE_QUOTE: \"'\",\n      /* ' */\n      CHAR_SPACE: \" \",\n      /*   */\n      CHAR_TAB: \"\t\",\n      /* \\t */\n      CHAR_UNDERSCORE: \"_\",\n      /* _ */\n      CHAR_VERTICAL_LINE: \"|\",\n      /* | */\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\"\n      /* \\uFEFF */\n    };\n  }\n});\n\n// node_modules/braces/lib/parse.js\nvar require_parse = __commonJS({\n  \"node_modules/braces/lib/parse.js\"(exports, module) {\n    \"use strict\";\n    var stringify = require_stringify();\n    var {\n      MAX_LENGTH,\n      CHAR_BACKSLASH,\n      /* \\ */\n      CHAR_BACKTICK,\n      /* ` */\n      CHAR_COMMA,\n      /* , */\n      CHAR_DOT,\n      /* . */\n      CHAR_LEFT_PARENTHESES,\n      /* ( */\n      CHAR_RIGHT_PARENTHESES,\n      /* ) */\n      CHAR_LEFT_CURLY_BRACE,\n      /* { */\n      CHAR_RIGHT_CURLY_BRACE,\n      /* } */\n      CHAR_LEFT_SQUARE_BRACKET,\n      /* [ */\n      CHAR_RIGHT_SQUARE_BRACKET,\n      /* ] */\n      CHAR_DOUBLE_QUOTE,\n      /* \" */\n      CHAR_SINGLE_QUOTE,\n      /* ' */\n      CHAR_NO_BREAK_SPACE,\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE\n    } = require_constants();\n    var parse6 = (input, options8 = {}) => {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n      }\n      let opts = options8 || {};\n      let max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      if (input.length > max) {\n        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n      }\n      let ast = { type: \"root\", input, nodes: [] };\n      let stack2 = [ast];\n      let block = ast;\n      let prev = ast;\n      let brackets = 0;\n      let length = input.length;\n      let index = 0;\n      let depth = 0;\n      let value;\n      let memo = {};\n      const advance = () => input[index++];\n      const push2 = (node) => {\n        if (node.type === \"text\" && prev.type === \"dot\") {\n          prev.type = \"text\";\n        }\n        if (prev && prev.type === \"text\" && node.type === \"text\") {\n          prev.value += node.value;\n          return;\n        }\n        block.nodes.push(node);\n        node.parent = block;\n        node.prev = prev;\n        prev = node;\n        return node;\n      };\n      push2({ type: \"bos\" });\n      while (index < length) {\n        block = stack2[stack2.length - 1];\n        value = advance();\n        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n          continue;\n        }\n        if (value === CHAR_BACKSLASH) {\n          push2({ type: \"text\", value: (options8.keepEscaping ? value : \"\") + advance() });\n          continue;\n        }\n        if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n          push2({ type: \"text\", value: \"\\\\\" + value });\n          continue;\n        }\n        if (value === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          let closed = true;\n          let next;\n          while (index < length && (next = advance())) {\n            value += next;\n            if (next === CHAR_LEFT_SQUARE_BRACKET) {\n              brackets++;\n              continue;\n            }\n            if (next === CHAR_BACKSLASH) {\n              value += advance();\n              continue;\n            }\n            if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n              brackets--;\n              if (brackets === 0) {\n                break;\n              }\n            }\n          }\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (value === CHAR_LEFT_PARENTHESES) {\n          block = push2({ type: \"paren\", nodes: [] });\n          stack2.push(block);\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (value === CHAR_RIGHT_PARENTHESES) {\n          if (block.type !== \"paren\") {\n            push2({ type: \"text\", value });\n            continue;\n          }\n          block = stack2.pop();\n          push2({ type: \"text\", value });\n          block = stack2[stack2.length - 1];\n          continue;\n        }\n        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n          let open = value;\n          let next;\n          if (options8.keepQuotes !== true) {\n            value = \"\";\n          }\n          while (index < length && (next = advance())) {\n            if (next === CHAR_BACKSLASH) {\n              value += next + advance();\n              continue;\n            }\n            if (next === open) {\n              if (options8.keepQuotes === true)\n                value += next;\n              break;\n            }\n            value += next;\n          }\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (value === CHAR_LEFT_CURLY_BRACE) {\n          depth++;\n          let dollar = prev.value && prev.value.slice(-1) === \"$\" || block.dollar === true;\n          let brace = {\n            type: \"brace\",\n            open: true,\n            close: false,\n            dollar,\n            depth,\n            commas: 0,\n            ranges: 0,\n            nodes: []\n          };\n          block = push2(brace);\n          stack2.push(block);\n          push2({ type: \"open\", value });\n          continue;\n        }\n        if (value === CHAR_RIGHT_CURLY_BRACE) {\n          if (block.type !== \"brace\") {\n            push2({ type: \"text\", value });\n            continue;\n          }\n          let type2 = \"close\";\n          block = stack2.pop();\n          block.close = true;\n          push2({ type: type2, value });\n          depth--;\n          block = stack2[stack2.length - 1];\n          continue;\n        }\n        if (value === CHAR_COMMA && depth > 0) {\n          if (block.ranges > 0) {\n            block.ranges = 0;\n            let open = block.nodes.shift();\n            block.nodes = [open, { type: \"text\", value: stringify(block) }];\n          }\n          push2({ type: \"comma\", value });\n          block.commas++;\n          continue;\n        }\n        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n          let siblings = block.nodes;\n          if (depth === 0 || siblings.length === 0) {\n            push2({ type: \"text\", value });\n            continue;\n          }\n          if (prev.type === \"dot\") {\n            block.range = [];\n            prev.value += value;\n            prev.type = \"range\";\n            if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n              block.invalid = true;\n              block.ranges = 0;\n              prev.type = \"text\";\n              continue;\n            }\n            block.ranges++;\n            block.args = [];\n            continue;\n          }\n          if (prev.type === \"range\") {\n            siblings.pop();\n            let before = siblings[siblings.length - 1];\n            before.value += prev.value + value;\n            prev = before;\n            block.ranges--;\n            continue;\n          }\n          push2({ type: \"dot\", value });\n          continue;\n        }\n        push2({ type: \"text\", value });\n      }\n      do {\n        block = stack2.pop();\n        if (block.type !== \"root\") {\n          block.nodes.forEach((node) => {\n            if (!node.nodes) {\n              if (node.type === \"open\")\n                node.isOpen = true;\n              if (node.type === \"close\")\n                node.isClose = true;\n              if (!node.nodes)\n                node.type = \"text\";\n              node.invalid = true;\n            }\n          });\n          let parent = stack2[stack2.length - 1];\n          let index2 = parent.nodes.indexOf(block);\n          parent.nodes.splice(index2, 1, ...block.nodes);\n        }\n      } while (stack2.length > 0);\n      push2({ type: \"eos\" });\n      return ast;\n    };\n    module.exports = parse6;\n  }\n});\n\n// node_modules/braces/index.js\nvar require_braces = __commonJS({\n  \"node_modules/braces/index.js\"(exports, module) {\n    \"use strict\";\n    var stringify = require_stringify();\n    var compile = require_compile();\n    var expand = require_expand();\n    var parse6 = require_parse();\n    var braces = (input, options8 = {}) => {\n      let output = [];\n      if (Array.isArray(input)) {\n        for (let pattern of input) {\n          let result = braces.create(pattern, options8);\n          if (Array.isArray(result)) {\n            output.push(...result);\n          } else {\n            output.push(result);\n          }\n        }\n      } else {\n        output = [].concat(braces.create(input, options8));\n      }\n      if (options8 && options8.expand === true && options8.nodupes === true) {\n        output = [...new Set(output)];\n      }\n      return output;\n    };\n    braces.parse = (input, options8 = {}) => parse6(input, options8);\n    braces.stringify = (input, options8 = {}) => {\n      if (typeof input === \"string\") {\n        return stringify(braces.parse(input, options8), options8);\n      }\n      return stringify(input, options8);\n    };\n    braces.compile = (input, options8 = {}) => {\n      if (typeof input === \"string\") {\n        input = braces.parse(input, options8);\n      }\n      return compile(input, options8);\n    };\n    braces.expand = (input, options8 = {}) => {\n      if (typeof input === \"string\") {\n        input = braces.parse(input, options8);\n      }\n      let result = expand(input, options8);\n      if (options8.noempty === true) {\n        result = result.filter(Boolean);\n      }\n      if (options8.nodupes === true) {\n        result = [...new Set(result)];\n      }\n      return result;\n    };\n    braces.create = (input, options8 = {}) => {\n      if (input === \"\" || input.length < 3) {\n        return [input];\n      }\n      return options8.expand !== true ? braces.compile(input, options8) : braces.expand(input, options8);\n    };\n    module.exports = braces;\n  }\n});\n\n// node_modules/picomatch/lib/constants.js\nvar require_constants2 = __commonJS({\n  \"node_modules/picomatch/lib/constants.js\"(exports, module) {\n    \"use strict\";\n    var path13 = __require(\"path\");\n    var WIN_SLASH = \"\\\\\\\\/\";\n    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n    var DOT_LITERAL = \"\\\\.\";\n    var PLUS_LITERAL = \"\\\\+\";\n    var QMARK_LITERAL = \"\\\\?\";\n    var SLASH_LITERAL = \"\\\\/\";\n    var ONE_CHAR = \"(?=.)\";\n    var QMARK = \"[^/]\";\n    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n    var NO_DOT = `(?!${DOT_LITERAL})`;\n    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n    var STAR = `${QMARK}*?`;\n    var POSIX_CHARS = {\n      DOT_LITERAL,\n      PLUS_LITERAL,\n      QMARK_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      QMARK,\n      END_ANCHOR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOTS,\n      NO_DOT_SLASH,\n      NO_DOTS_SLASH,\n      QMARK_NO_DOT,\n      STAR,\n      START_ANCHOR\n    };\n    var WINDOWS_CHARS = {\n      ...POSIX_CHARS,\n      SLASH_LITERAL: `[${WIN_SLASH}]`,\n      QMARK: WIN_NO_SLASH,\n      STAR: `${WIN_NO_SLASH}*?`,\n      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n      NO_DOT: `(?!${DOT_LITERAL})`,\n      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n    };\n    var POSIX_REGEX_SOURCE = {\n      alnum: \"a-zA-Z0-9\",\n      alpha: \"a-zA-Z\",\n      ascii: \"\\\\x00-\\\\x7F\",\n      blank: \" \\\\t\",\n      cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n      digit: \"0-9\",\n      graph: \"\\\\x21-\\\\x7E\",\n      lower: \"a-z\",\n      print: \"\\\\x20-\\\\x7E \",\n      punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n      space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n      upper: \"A-Z\",\n      word: \"A-Za-z0-9_\",\n      xdigit: \"A-Fa-f0-9\"\n    };\n    module.exports = {\n      MAX_LENGTH: 1024 * 64,\n      POSIX_REGEX_SOURCE,\n      // regular expressions\n      REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n      REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n      REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n      REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n      // Replace globs with equivalent patterns to reduce parsing time.\n      REPLACEMENTS: {\n        \"***\": \"*\",\n        \"**/**\": \"**\",\n        \"**/**/**\": \"**\"\n      },\n      // Digits\n      CHAR_0: 48,\n      /* 0 */\n      CHAR_9: 57,\n      /* 9 */\n      // Alphabet chars.\n      CHAR_UPPERCASE_A: 65,\n      /* A */\n      CHAR_LOWERCASE_A: 97,\n      /* a */\n      CHAR_UPPERCASE_Z: 90,\n      /* Z */\n      CHAR_LOWERCASE_Z: 122,\n      /* z */\n      CHAR_LEFT_PARENTHESES: 40,\n      /* ( */\n      CHAR_RIGHT_PARENTHESES: 41,\n      /* ) */\n      CHAR_ASTERISK: 42,\n      /* * */\n      // Non-alphabetic chars.\n      CHAR_AMPERSAND: 38,\n      /* & */\n      CHAR_AT: 64,\n      /* @ */\n      CHAR_BACKWARD_SLASH: 92,\n      /* \\ */\n      CHAR_CARRIAGE_RETURN: 13,\n      /* \\r */\n      CHAR_CIRCUMFLEX_ACCENT: 94,\n      /* ^ */\n      CHAR_COLON: 58,\n      /* : */\n      CHAR_COMMA: 44,\n      /* , */\n      CHAR_DOT: 46,\n      /* . */\n      CHAR_DOUBLE_QUOTE: 34,\n      /* \" */\n      CHAR_EQUAL: 61,\n      /* = */\n      CHAR_EXCLAMATION_MARK: 33,\n      /* ! */\n      CHAR_FORM_FEED: 12,\n      /* \\f */\n      CHAR_FORWARD_SLASH: 47,\n      /* / */\n      CHAR_GRAVE_ACCENT: 96,\n      /* ` */\n      CHAR_HASH: 35,\n      /* # */\n      CHAR_HYPHEN_MINUS: 45,\n      /* - */\n      CHAR_LEFT_ANGLE_BRACKET: 60,\n      /* < */\n      CHAR_LEFT_CURLY_BRACE: 123,\n      /* { */\n      CHAR_LEFT_SQUARE_BRACKET: 91,\n      /* [ */\n      CHAR_LINE_FEED: 10,\n      /* \\n */\n      CHAR_NO_BREAK_SPACE: 160,\n      /* \\u00A0 */\n      CHAR_PERCENT: 37,\n      /* % */\n      CHAR_PLUS: 43,\n      /* + */\n      CHAR_QUESTION_MARK: 63,\n      /* ? */\n      CHAR_RIGHT_ANGLE_BRACKET: 62,\n      /* > */\n      CHAR_RIGHT_CURLY_BRACE: 125,\n      /* } */\n      CHAR_RIGHT_SQUARE_BRACKET: 93,\n      /* ] */\n      CHAR_SEMICOLON: 59,\n      /* ; */\n      CHAR_SINGLE_QUOTE: 39,\n      /* ' */\n      CHAR_SPACE: 32,\n      /*   */\n      CHAR_TAB: 9,\n      /* \\t */\n      CHAR_UNDERSCORE: 95,\n      /* _ */\n      CHAR_VERTICAL_LINE: 124,\n      /* | */\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n      /* \\uFEFF */\n      SEP: path13.sep,\n      /**\n       * Create EXTGLOB_CHARS\n       */\n      extglobChars(chars) {\n        return {\n          \"!\": { type: \"negate\", open: \"(?:(?!(?:\", close: `))${chars.STAR})` },\n          \"?\": { type: \"qmark\", open: \"(?:\", close: \")?\" },\n          \"+\": { type: \"plus\", open: \"(?:\", close: \")+\" },\n          \"*\": { type: \"star\", open: \"(?:\", close: \")*\" },\n          \"@\": { type: \"at\", open: \"(?:\", close: \")\" }\n        };\n      },\n      /**\n       * Create GLOB_CHARS\n       */\n      globChars(win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n      }\n    };\n  }\n});\n\n// node_modules/picomatch/lib/utils.js\nvar require_utils2 = __commonJS({\n  \"node_modules/picomatch/lib/utils.js\"(exports) {\n    \"use strict\";\n    var path13 = __require(\"path\");\n    var win32 = process.platform === \"win32\";\n    var {\n      REGEX_BACKSLASH,\n      REGEX_REMOVE_BACKSLASH,\n      REGEX_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_GLOBAL\n    } = require_constants2();\n    exports.isObject = (val) => val !== null && typeof val === \"object\" && !Array.isArray(val);\n    exports.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);\n    exports.isRegexChar = (str2) => str2.length === 1 && exports.hasRegexChars(str2);\n    exports.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, \"\\\\$1\");\n    exports.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, \"/\");\n    exports.removeBackslashes = (str2) => {\n      return str2.replace(REGEX_REMOVE_BACKSLASH, (match) => {\n        return match === \"\\\\\" ? \"\" : match;\n      });\n    };\n    exports.supportsLookbehinds = () => {\n      const segs = process.version.slice(1).split(\".\").map(Number);\n      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n        return true;\n      }\n      return false;\n    };\n    exports.isWindows = (options8) => {\n      if (options8 && typeof options8.windows === \"boolean\") {\n        return options8.windows;\n      }\n      return win32 === true || path13.sep === \"\\\\\";\n    };\n    exports.escapeLast = (input, char, lastIdx) => {\n      const idx = input.lastIndexOf(char, lastIdx);\n      if (idx === -1)\n        return input;\n      if (input[idx - 1] === \"\\\\\")\n        return exports.escapeLast(input, char, idx - 1);\n      return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n    };\n    exports.removePrefix = (input, state = {}) => {\n      let output = input;\n      if (output.startsWith(\"./\")) {\n        output = output.slice(2);\n        state.prefix = \"./\";\n      }\n      return output;\n    };\n    exports.wrapOutput = (input, state = {}, options8 = {}) => {\n      const prepend = options8.contains ? \"\" : \"^\";\n      const append = options8.contains ? \"\" : \"$\";\n      let output = `${prepend}(?:${input})${append}`;\n      if (state.negated === true) {\n        output = `(?:^(?!${output}).*$)`;\n      }\n      return output;\n    };\n  }\n});\n\n// node_modules/picomatch/lib/scan.js\nvar require_scan = __commonJS({\n  \"node_modules/picomatch/lib/scan.js\"(exports, module) {\n    \"use strict\";\n    var utils = require_utils2();\n    var {\n      CHAR_ASTERISK,\n      /* * */\n      CHAR_AT,\n      /* @ */\n      CHAR_BACKWARD_SLASH,\n      /* \\ */\n      CHAR_COMMA,\n      /* , */\n      CHAR_DOT,\n      /* . */\n      CHAR_EXCLAMATION_MARK,\n      /* ! */\n      CHAR_FORWARD_SLASH,\n      /* / */\n      CHAR_LEFT_CURLY_BRACE,\n      /* { */\n      CHAR_LEFT_PARENTHESES,\n      /* ( */\n      CHAR_LEFT_SQUARE_BRACKET,\n      /* [ */\n      CHAR_PLUS,\n      /* + */\n      CHAR_QUESTION_MARK,\n      /* ? */\n      CHAR_RIGHT_CURLY_BRACE,\n      /* } */\n      CHAR_RIGHT_PARENTHESES,\n      /* ) */\n      CHAR_RIGHT_SQUARE_BRACKET\n      /* ] */\n    } = require_constants2();\n    var isPathSeparator = (code) => {\n      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n    };\n    var depth = (token2) => {\n      if (token2.isPrefix !== true) {\n        token2.depth = token2.isGlobstar ? Infinity : 1;\n      }\n    };\n    var scan = (input, options8) => {\n      const opts = options8 || {};\n      const length = input.length - 1;\n      const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n      const slashes = [];\n      const tokens = [];\n      const parts = [];\n      let str2 = input;\n      let index = -1;\n      let start = 0;\n      let lastIndex = 0;\n      let isBrace = false;\n      let isBracket = false;\n      let isGlob = false;\n      let isExtglob = false;\n      let isGlobstar = false;\n      let braceEscaped = false;\n      let backslashes = false;\n      let negated = false;\n      let negatedExtglob = false;\n      let finished = false;\n      let braces = 0;\n      let prev;\n      let code;\n      let token2 = { value: \"\", depth: 0, isGlob: false };\n      const eos = () => index >= length;\n      const peek2 = () => str2.charCodeAt(index + 1);\n      const advance = () => {\n        prev = code;\n        return str2.charCodeAt(++index);\n      };\n      while (index < length) {\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token2.backslashes = true;\n          code = advance();\n          if (code === CHAR_LEFT_CURLY_BRACE) {\n            braceEscaped = true;\n          }\n          continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token2.backslashes = true;\n              advance();\n              continue;\n            }\n            if (code === CHAR_LEFT_CURLY_BRACE) {\n              braces++;\n              continue;\n            }\n            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n              isBrace = token2.isBrace = true;\n              isGlob = token2.isGlob = true;\n              finished = true;\n              if (scanToEnd === true) {\n                continue;\n              }\n              break;\n            }\n            if (braceEscaped !== true && code === CHAR_COMMA) {\n              isBrace = token2.isBrace = true;\n              isGlob = token2.isGlob = true;\n              finished = true;\n              if (scanToEnd === true) {\n                continue;\n              }\n              break;\n            }\n            if (code === CHAR_RIGHT_CURLY_BRACE) {\n              braces--;\n              if (braces === 0) {\n                braceEscaped = false;\n                isBrace = token2.isBrace = true;\n                finished = true;\n                break;\n              }\n            }\n          }\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n          slashes.push(index);\n          tokens.push(token2);\n          token2 = { value: \"\", depth: 0, isGlob: false };\n          if (finished === true)\n            continue;\n          if (prev === CHAR_DOT && index === start + 1) {\n            start += 2;\n            continue;\n          }\n          lastIndex = index + 1;\n          continue;\n        }\n        if (opts.noext !== true) {\n          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n          if (isExtglobChar === true && peek2() === CHAR_LEFT_PARENTHESES) {\n            isGlob = token2.isGlob = true;\n            isExtglob = token2.isExtglob = true;\n            finished = true;\n            if (code === CHAR_EXCLAMATION_MARK && index === start) {\n              negatedExtglob = true;\n            }\n            if (scanToEnd === true) {\n              while (eos() !== true && (code = advance())) {\n                if (code === CHAR_BACKWARD_SLASH) {\n                  backslashes = token2.backslashes = true;\n                  code = advance();\n                  continue;\n                }\n                if (code === CHAR_RIGHT_PARENTHESES) {\n                  isGlob = token2.isGlob = true;\n                  finished = true;\n                  break;\n                }\n              }\n              continue;\n            }\n            break;\n          }\n        }\n        if (code === CHAR_ASTERISK) {\n          if (prev === CHAR_ASTERISK)\n            isGlobstar = token2.isGlobstar = true;\n          isGlob = token2.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_QUESTION_MARK) {\n          isGlob = token2.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET) {\n          while (eos() !== true && (next = advance())) {\n            if (next === CHAR_BACKWARD_SLASH) {\n              backslashes = token2.backslashes = true;\n              advance();\n              continue;\n            }\n            if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n              isBracket = token2.isBracket = true;\n              isGlob = token2.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n          negated = token2.negated = true;\n          start++;\n          continue;\n        }\n        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n          isGlob = token2.isGlob = true;\n          if (scanToEnd === true) {\n            while (eos() !== true && (code = advance())) {\n              if (code === CHAR_LEFT_PARENTHESES) {\n                backslashes = token2.backslashes = true;\n                code = advance();\n                continue;\n              }\n              if (code === CHAR_RIGHT_PARENTHESES) {\n                finished = true;\n                break;\n              }\n            }\n            continue;\n          }\n          break;\n        }\n        if (isGlob === true) {\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n      if (opts.noext === true) {\n        isExtglob = false;\n        isGlob = false;\n      }\n      let base = str2;\n      let prefix = \"\";\n      let glob = \"\";\n      if (start > 0) {\n        prefix = str2.slice(0, start);\n        str2 = str2.slice(start);\n        lastIndex -= start;\n      }\n      if (base && isGlob === true && lastIndex > 0) {\n        base = str2.slice(0, lastIndex);\n        glob = str2.slice(lastIndex);\n      } else if (isGlob === true) {\n        base = \"\";\n        glob = str2;\n      } else {\n        base = str2;\n      }\n      if (base && base !== \"\" && base !== \"/\" && base !== str2) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n          base = base.slice(0, -1);\n        }\n      }\n      if (opts.unescape === true) {\n        if (glob)\n          glob = utils.removeBackslashes(glob);\n        if (base && backslashes === true) {\n          base = utils.removeBackslashes(base);\n        }\n      }\n      const state = {\n        prefix,\n        input,\n        start,\n        base,\n        glob,\n        isBrace,\n        isBracket,\n        isGlob,\n        isExtglob,\n        isGlobstar,\n        negated,\n        negatedExtglob\n      };\n      if (opts.tokens === true) {\n        state.maxDepth = 0;\n        if (!isPathSeparator(code)) {\n          tokens.push(token2);\n        }\n        state.tokens = tokens;\n      }\n      if (opts.parts === true || opts.tokens === true) {\n        let prevIndex;\n        for (let idx = 0; idx < slashes.length; idx++) {\n          const n = prevIndex ? prevIndex + 1 : start;\n          const i = slashes[idx];\n          const value = input.slice(n, i);\n          if (opts.tokens) {\n            if (idx === 0 && start !== 0) {\n              tokens[idx].isPrefix = true;\n              tokens[idx].value = prefix;\n            } else {\n              tokens[idx].value = value;\n            }\n            depth(tokens[idx]);\n            state.maxDepth += tokens[idx].depth;\n          }\n          if (idx !== 0 || value !== \"\") {\n            parts.push(value);\n          }\n          prevIndex = i;\n        }\n        if (prevIndex && prevIndex + 1 < input.length) {\n          const value = input.slice(prevIndex + 1);\n          parts.push(value);\n          if (opts.tokens) {\n            tokens[tokens.length - 1].value = value;\n            depth(tokens[tokens.length - 1]);\n            state.maxDepth += tokens[tokens.length - 1].depth;\n          }\n        }\n        state.slashes = slashes;\n        state.parts = parts;\n      }\n      return state;\n    };\n    module.exports = scan;\n  }\n});\n\n// node_modules/picomatch/lib/parse.js\nvar require_parse2 = __commonJS({\n  \"node_modules/picomatch/lib/parse.js\"(exports, module) {\n    \"use strict\";\n    var constants = require_constants2();\n    var utils = require_utils2();\n    var {\n      MAX_LENGTH,\n      POSIX_REGEX_SOURCE,\n      REGEX_NON_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_BACKREF,\n      REPLACEMENTS\n    } = constants;\n    var expandRange = (args, options8) => {\n      if (typeof options8.expandRange === \"function\") {\n        return options8.expandRange(...args, options8);\n      }\n      args.sort();\n      const value = `[${args.join(\"-\")}]`;\n      try {\n        new RegExp(value);\n      } catch (ex) {\n        return args.map((v) => utils.escapeRegex(v)).join(\"..\");\n      }\n      return value;\n    };\n    var syntaxError2 = (type2, char) => {\n      return `Missing ${type2}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n    };\n    var parse6 = (input, options8) => {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n      }\n      input = REPLACEMENTS[input] || input;\n      const opts = { ...options8 };\n      const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      let len = input.length;\n      if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n      }\n      const bos = { type: \"bos\", value: \"\", output: opts.prepend || \"\" };\n      const tokens = [bos];\n      const capture = opts.capture ? \"\" : \"?:\";\n      const win32 = utils.isWindows(options8);\n      const PLATFORM_CHARS = constants.globChars(win32);\n      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n      const {\n        DOT_LITERAL,\n        PLUS_LITERAL,\n        SLASH_LITERAL,\n        ONE_CHAR,\n        DOTS_SLASH,\n        NO_DOT,\n        NO_DOT_SLASH,\n        NO_DOTS_SLASH,\n        QMARK,\n        QMARK_NO_DOT,\n        STAR,\n        START_ANCHOR\n      } = PLATFORM_CHARS;\n      const globstar = (opts2) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n      };\n      const nodot = opts.dot ? \"\" : NO_DOT;\n      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n      let star = opts.bash === true ? globstar(opts) : STAR;\n      if (opts.capture) {\n        star = `(${star})`;\n      }\n      if (typeof opts.noext === \"boolean\") {\n        opts.noextglob = opts.noext;\n      }\n      const state = {\n        input,\n        index: -1,\n        start: 0,\n        dot: opts.dot === true,\n        consumed: \"\",\n        output: \"\",\n        prefix: \"\",\n        backtrack: false,\n        negated: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        globstar: false,\n        tokens\n      };\n      input = utils.removePrefix(input, state);\n      len = input.length;\n      const extglobs = [];\n      const braces = [];\n      const stack2 = [];\n      let prev = bos;\n      let value;\n      const eos = () => state.index === len - 1;\n      const peek2 = state.peek = (n = 1) => input[state.index + n];\n      const advance = state.advance = () => input[++state.index] || \"\";\n      const remaining = () => input.slice(state.index + 1);\n      const consume = (value2 = \"\", num = 0) => {\n        state.consumed += value2;\n        state.index += num;\n      };\n      const append = (token2) => {\n        state.output += token2.output != null ? token2.output : token2.value;\n        consume(token2.value);\n      };\n      const negate = () => {\n        let count = 1;\n        while (peek2() === \"!\" && (peek2(2) !== \"(\" || peek2(3) === \"?\")) {\n          advance();\n          state.start++;\n          count++;\n        }\n        if (count % 2 === 0) {\n          return false;\n        }\n        state.negated = true;\n        state.start++;\n        return true;\n      };\n      const increment = (type2) => {\n        state[type2]++;\n        stack2.push(type2);\n      };\n      const decrement = (type2) => {\n        state[type2]--;\n        stack2.pop();\n      };\n      const push2 = (tok) => {\n        if (prev.type === \"globstar\") {\n          const isBrace = state.braces > 0 && (tok.type === \"comma\" || tok.type === \"brace\");\n          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === \"pipe\" || tok.type === \"paren\");\n          if (tok.type !== \"slash\" && tok.type !== \"paren\" && !isBrace && !isExtglob) {\n            state.output = state.output.slice(0, -prev.output.length);\n            prev.type = \"star\";\n            prev.value = \"*\";\n            prev.output = star;\n            state.output += prev.output;\n          }\n        }\n        if (extglobs.length && tok.type !== \"paren\") {\n          extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output)\n          append(tok);\n        if (prev && prev.type === \"text\" && tok.type === \"text\") {\n          prev.value += tok.value;\n          prev.output = (prev.output || \"\") + tok.value;\n          return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n      };\n      const extglobOpen = (type2, value2) => {\n        const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: \"\" };\n        token2.prev = prev;\n        token2.parens = state.parens;\n        token2.output = state.output;\n        const output = (opts.capture ? \"(\" : \"\") + token2.open;\n        increment(\"parens\");\n        push2({ type: type2, value: value2, output: state.output ? \"\" : ONE_CHAR });\n        push2({ type: \"paren\", extglob: true, value: advance(), output });\n        extglobs.push(token2);\n      };\n      const extglobClose = (token2) => {\n        let output = token2.close + (opts.capture ? \")\" : \"\");\n        let rest;\n        if (token2.type === \"negate\") {\n          let extglobStar = star;\n          if (token2.inner && token2.inner.length > 1 && token2.inner.includes(\"/\")) {\n            extglobStar = globstar(opts);\n          }\n          if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n            output = token2.close = `)$))${extglobStar}`;\n          }\n          if (token2.inner.includes(\"*\") && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n            const expression = parse6(rest, { ...options8, fastpaths: false }).output;\n            output = token2.close = `)${expression})${extglobStar})`;\n          }\n          if (token2.prev.type === \"bos\") {\n            state.negatedExtglob = true;\n          }\n        }\n        push2({ type: \"paren\", extglob: true, value, output });\n        decrement(\"parens\");\n      };\n      if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n          if (first === \"\\\\\") {\n            backslashes = true;\n            return m;\n          }\n          if (first === \"?\") {\n            if (esc) {\n              return esc + first + (rest ? QMARK.repeat(rest.length) : \"\");\n            }\n            if (index === 0) {\n              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : \"\");\n            }\n            return QMARK.repeat(chars.length);\n          }\n          if (first === \".\") {\n            return DOT_LITERAL.repeat(chars.length);\n          }\n          if (first === \"*\") {\n            if (esc) {\n              return esc + first + (rest ? star : \"\");\n            }\n            return star;\n          }\n          return esc ? m : `\\\\${m}`;\n        });\n        if (backslashes === true) {\n          if (opts.unescape === true) {\n            output = output.replace(/\\\\/g, \"\");\n          } else {\n            output = output.replace(/\\\\+/g, (m) => {\n              return m.length % 2 === 0 ? \"\\\\\\\\\" : m ? \"\\\\\" : \"\";\n            });\n          }\n        }\n        if (output === input && opts.contains === true) {\n          state.output = input;\n          return state;\n        }\n        state.output = utils.wrapOutput(output, state, options8);\n        return state;\n      }\n      while (!eos()) {\n        value = advance();\n        if (value === \"\\0\") {\n          continue;\n        }\n        if (value === \"\\\\\") {\n          const next = peek2();\n          if (next === \"/\" && opts.bash !== true) {\n            continue;\n          }\n          if (next === \".\" || next === \";\") {\n            continue;\n          }\n          if (!next) {\n            value += \"\\\\\";\n            push2({ type: \"text\", value });\n            continue;\n          }\n          const match = /^\\\\+/.exec(remaining());\n          let slashes = 0;\n          if (match && match[0].length > 2) {\n            slashes = match[0].length;\n            state.index += slashes;\n            if (slashes % 2 !== 0) {\n              value += \"\\\\\";\n            }\n          }\n          if (opts.unescape === true) {\n            value = advance();\n          } else {\n            value += advance();\n          }\n          if (state.brackets === 0) {\n            push2({ type: \"text\", value });\n            continue;\n          }\n        }\n        if (state.brackets > 0 && (value !== \"]\" || prev.value === \"[\" || prev.value === \"[^\")) {\n          if (opts.posix !== false && value === \":\") {\n            const inner = prev.value.slice(1);\n            if (inner.includes(\"[\")) {\n              prev.posix = true;\n              if (inner.includes(\":\")) {\n                const idx = prev.value.lastIndexOf(\"[\");\n                const pre = prev.value.slice(0, idx);\n                const rest2 = prev.value.slice(idx + 2);\n                const posix = POSIX_REGEX_SOURCE[rest2];\n                if (posix) {\n                  prev.value = pre + posix;\n                  state.backtrack = true;\n                  advance();\n                  if (!bos.output && tokens.indexOf(prev) === 1) {\n                    bos.output = ONE_CHAR;\n                  }\n                  continue;\n                }\n              }\n            }\n          }\n          if (value === \"[\" && peek2() !== \":\" || value === \"-\" && peek2() === \"]\") {\n            value = `\\\\${value}`;\n          }\n          if (value === \"]\" && (prev.value === \"[\" || prev.value === \"[^\")) {\n            value = `\\\\${value}`;\n          }\n          if (opts.posix === true && value === \"!\" && prev.value === \"[\") {\n            value = \"^\";\n          }\n          prev.value += value;\n          append({ value });\n          continue;\n        }\n        if (state.quotes === 1 && value !== '\"') {\n          value = utils.escapeRegex(value);\n          prev.value += value;\n          append({ value });\n          continue;\n        }\n        if (value === '\"') {\n          state.quotes = state.quotes === 1 ? 0 : 1;\n          if (opts.keepQuotes === true) {\n            push2({ type: \"text\", value });\n          }\n          continue;\n        }\n        if (value === \"(\") {\n          increment(\"parens\");\n          push2({ type: \"paren\", value });\n          continue;\n        }\n        if (value === \")\") {\n          if (state.parens === 0 && opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError2(\"opening\", \"(\"));\n          }\n          const extglob = extglobs[extglobs.length - 1];\n          if (extglob && state.parens === extglob.parens + 1) {\n            extglobClose(extglobs.pop());\n            continue;\n          }\n          push2({ type: \"paren\", value, output: state.parens ? \")\" : \"\\\\)\" });\n          decrement(\"parens\");\n          continue;\n        }\n        if (value === \"[\") {\n          if (opts.nobracket === true || !remaining().includes(\"]\")) {\n            if (opts.nobracket !== true && opts.strictBrackets === true) {\n              throw new SyntaxError(syntaxError2(\"closing\", \"]\"));\n            }\n            value = `\\\\${value}`;\n          } else {\n            increment(\"brackets\");\n          }\n          push2({ type: \"bracket\", value });\n          continue;\n        }\n        if (value === \"]\") {\n          if (opts.nobracket === true || prev && prev.type === \"bracket\" && prev.value.length === 1) {\n            push2({ type: \"text\", value, output: `\\\\${value}` });\n            continue;\n          }\n          if (state.brackets === 0) {\n            if (opts.strictBrackets === true) {\n              throw new SyntaxError(syntaxError2(\"opening\", \"[\"));\n            }\n            push2({ type: \"text\", value, output: `\\\\${value}` });\n            continue;\n          }\n          decrement(\"brackets\");\n          const prevValue = prev.value.slice(1);\n          if (prev.posix !== true && prevValue[0] === \"^\" && !prevValue.includes(\"/\")) {\n            value = `/${value}`;\n          }\n          prev.value += value;\n          append({ value });\n          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n            continue;\n          }\n          const escaped = utils.escapeRegex(prev.value);\n          state.output = state.output.slice(0, -prev.value.length);\n          if (opts.literalBrackets === true) {\n            state.output += escaped;\n            prev.value = escaped;\n            continue;\n          }\n          prev.value = `(${capture}${escaped}|${prev.value})`;\n          state.output += prev.value;\n          continue;\n        }\n        if (value === \"{\" && opts.nobrace !== true) {\n          increment(\"braces\");\n          const open = {\n            type: \"brace\",\n            value,\n            output: \"(\",\n            outputIndex: state.output.length,\n            tokensIndex: state.tokens.length\n          };\n          braces.push(open);\n          push2(open);\n          continue;\n        }\n        if (value === \"}\") {\n          const brace = braces[braces.length - 1];\n          if (opts.nobrace === true || !brace) {\n            push2({ type: \"text\", value, output: value });\n            continue;\n          }\n          let output = \")\";\n          if (brace.dots === true) {\n            const arr = tokens.slice();\n            const range = [];\n            for (let i = arr.length - 1; i >= 0; i--) {\n              tokens.pop();\n              if (arr[i].type === \"brace\") {\n                break;\n              }\n              if (arr[i].type !== \"dots\") {\n                range.unshift(arr[i].value);\n              }\n            }\n            output = expandRange(range, opts);\n            state.backtrack = true;\n          }\n          if (brace.comma !== true && brace.dots !== true) {\n            const out = state.output.slice(0, brace.outputIndex);\n            const toks = state.tokens.slice(brace.tokensIndex);\n            brace.value = brace.output = \"\\\\{\";\n            value = output = \"\\\\}\";\n            state.output = out;\n            for (const t of toks) {\n              state.output += t.output || t.value;\n            }\n          }\n          push2({ type: \"brace\", value, output });\n          decrement(\"braces\");\n          braces.pop();\n          continue;\n        }\n        if (value === \"|\") {\n          if (extglobs.length > 0) {\n            extglobs[extglobs.length - 1].conditions++;\n          }\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (value === \",\") {\n          let output = value;\n          const brace = braces[braces.length - 1];\n          if (brace && stack2[stack2.length - 1] === \"braces\") {\n            brace.comma = true;\n            output = \"|\";\n          }\n          push2({ type: \"comma\", value, output });\n          continue;\n        }\n        if (value === \"/\") {\n          if (prev.type === \"dot\" && state.index === state.start + 1) {\n            state.start = state.index + 1;\n            state.consumed = \"\";\n            state.output = \"\";\n            tokens.pop();\n            prev = bos;\n            continue;\n          }\n          push2({ type: \"slash\", value, output: SLASH_LITERAL });\n          continue;\n        }\n        if (value === \".\") {\n          if (state.braces > 0 && prev.type === \"dot\") {\n            if (prev.value === \".\")\n              prev.output = DOT_LITERAL;\n            const brace = braces[braces.length - 1];\n            prev.type = \"dots\";\n            prev.output += value;\n            prev.value += value;\n            brace.dots = true;\n            continue;\n          }\n          if (state.braces + state.parens === 0 && prev.type !== \"bos\" && prev.type !== \"slash\") {\n            push2({ type: \"text\", value, output: DOT_LITERAL });\n            continue;\n          }\n          push2({ type: \"dot\", value, output: DOT_LITERAL });\n          continue;\n        }\n        if (value === \"?\") {\n          const isGroup = prev && prev.value === \"(\";\n          if (!isGroup && opts.noextglob !== true && peek2() === \"(\" && peek2(2) !== \"?\") {\n            extglobOpen(\"qmark\", value);\n            continue;\n          }\n          if (prev && prev.type === \"paren\") {\n            const next = peek2();\n            let output = value;\n            if (next === \"<\" && !utils.supportsLookbehinds()) {\n              throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n            }\n            if (prev.value === \"(\" && !/[!=<:]/.test(next) || next === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n              output = `\\\\${value}`;\n            }\n            push2({ type: \"text\", value, output });\n            continue;\n          }\n          if (opts.dot !== true && (prev.type === \"slash\" || prev.type === \"bos\")) {\n            push2({ type: \"qmark\", value, output: QMARK_NO_DOT });\n            continue;\n          }\n          push2({ type: \"qmark\", value, output: QMARK });\n          continue;\n        }\n        if (value === \"!\") {\n          if (opts.noextglob !== true && peek2() === \"(\") {\n            if (peek2(2) !== \"?\" || !/[!=<:]/.test(peek2(3))) {\n              extglobOpen(\"negate\", value);\n              continue;\n            }\n          }\n          if (opts.nonegate !== true && state.index === 0) {\n            negate();\n            continue;\n          }\n        }\n        if (value === \"+\") {\n          if (opts.noextglob !== true && peek2() === \"(\" && peek2(2) !== \"?\") {\n            extglobOpen(\"plus\", value);\n            continue;\n          }\n          if (prev && prev.value === \"(\" || opts.regex === false) {\n            push2({ type: \"plus\", value, output: PLUS_LITERAL });\n            continue;\n          }\n          if (prev && (prev.type === \"bracket\" || prev.type === \"paren\" || prev.type === \"brace\") || state.parens > 0) {\n            push2({ type: \"plus\", value });\n            continue;\n          }\n          push2({ type: \"plus\", value: PLUS_LITERAL });\n          continue;\n        }\n        if (value === \"@\") {\n          if (opts.noextglob !== true && peek2() === \"(\" && peek2(2) !== \"?\") {\n            push2({ type: \"at\", extglob: true, value, output: \"\" });\n            continue;\n          }\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (value !== \"*\") {\n          if (value === \"$\" || value === \"^\") {\n            value = `\\\\${value}`;\n          }\n          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n          if (match) {\n            value += match[0];\n            state.index += match[0].length;\n          }\n          push2({ type: \"text\", value });\n          continue;\n        }\n        if (prev && (prev.type === \"globstar\" || prev.star === true)) {\n          prev.type = \"star\";\n          prev.star = true;\n          prev.value += value;\n          prev.output = star;\n          state.backtrack = true;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        let rest = remaining();\n        if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n          extglobOpen(\"star\", value);\n          continue;\n        }\n        if (prev.type === \"star\") {\n          if (opts.noglobstar === true) {\n            consume(value);\n            continue;\n          }\n          const prior = prev.prev;\n          const before = prior.prev;\n          const isStart = prior.type === \"slash\" || prior.type === \"bos\";\n          const afterStar = before && (before.type === \"star\" || before.type === \"globstar\");\n          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== \"/\")) {\n            push2({ type: \"star\", value, output: \"\" });\n            continue;\n          }\n          const isBrace = state.braces > 0 && (prior.type === \"comma\" || prior.type === \"brace\");\n          const isExtglob = extglobs.length && (prior.type === \"pipe\" || prior.type === \"paren\");\n          if (!isStart && prior.type !== \"paren\" && !isBrace && !isExtglob) {\n            push2({ type: \"star\", value, output: \"\" });\n            continue;\n          }\n          while (rest.slice(0, 3) === \"/**\") {\n            const after = input[state.index + 4];\n            if (after && after !== \"/\") {\n              break;\n            }\n            rest = rest.slice(3);\n            consume(\"/**\", 3);\n          }\n          if (prior.type === \"bos\" && eos()) {\n            prev.type = \"globstar\";\n            prev.value += value;\n            prev.output = globstar(opts);\n            state.output = prev.output;\n            state.globstar = true;\n            consume(value);\n            continue;\n          }\n          if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && !afterStar && eos()) {\n            state.output = state.output.slice(0, -(prior.output + prev.output).length);\n            prior.output = `(?:${prior.output}`;\n            prev.type = \"globstar\";\n            prev.output = globstar(opts) + (opts.strictSlashes ? \")\" : \"|$)\");\n            prev.value += value;\n            state.globstar = true;\n            state.output += prior.output + prev.output;\n            consume(value);\n            continue;\n          }\n          if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && rest[0] === \"/\") {\n            const end = rest[1] !== void 0 ? \"|$\" : \"\";\n            state.output = state.output.slice(0, -(prior.output + prev.output).length);\n            prior.output = `(?:${prior.output}`;\n            prev.type = \"globstar\";\n            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n            prev.value += value;\n            state.output += prior.output + prev.output;\n            state.globstar = true;\n            consume(value + advance());\n            push2({ type: \"slash\", value: \"/\", output: \"\" });\n            continue;\n          }\n          if (prior.type === \"bos\" && rest[0] === \"/\") {\n            prev.type = \"globstar\";\n            prev.value += value;\n            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n            state.output = prev.output;\n            state.globstar = true;\n            consume(value + advance());\n            push2({ type: \"slash\", value: \"/\", output: \"\" });\n            continue;\n          }\n          state.output = state.output.slice(0, -prev.output.length);\n          prev.type = \"globstar\";\n          prev.output = globstar(opts);\n          prev.value += value;\n          state.output += prev.output;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        const token2 = { type: \"star\", value, output: star };\n        if (opts.bash === true) {\n          token2.output = \".*?\";\n          if (prev.type === \"bos\" || prev.type === \"slash\") {\n            token2.output = nodot + token2.output;\n          }\n          push2(token2);\n          continue;\n        }\n        if (prev && (prev.type === \"bracket\" || prev.type === \"paren\") && opts.regex === true) {\n          token2.output = value;\n          push2(token2);\n          continue;\n        }\n        if (state.index === state.start || prev.type === \"slash\" || prev.type === \"dot\") {\n          if (prev.type === \"dot\") {\n            state.output += NO_DOT_SLASH;\n            prev.output += NO_DOT_SLASH;\n          } else if (opts.dot === true) {\n            state.output += NO_DOTS_SLASH;\n            prev.output += NO_DOTS_SLASH;\n          } else {\n            state.output += nodot;\n            prev.output += nodot;\n          }\n          if (peek2() !== \"*\") {\n            state.output += ONE_CHAR;\n            prev.output += ONE_CHAR;\n          }\n        }\n        push2(token2);\n      }\n      while (state.brackets > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError2(\"closing\", \"]\"));\n        state.output = utils.escapeLast(state.output, \"[\");\n        decrement(\"brackets\");\n      }\n      while (state.parens > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError2(\"closing\", \")\"));\n        state.output = utils.escapeLast(state.output, \"(\");\n        decrement(\"parens\");\n      }\n      while (state.braces > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError2(\"closing\", \"}\"));\n        state.output = utils.escapeLast(state.output, \"{\");\n        decrement(\"braces\");\n      }\n      if (opts.strictSlashes !== true && (prev.type === \"star\" || prev.type === \"bracket\")) {\n        push2({ type: \"maybe_slash\", value: \"\", output: `${SLASH_LITERAL}?` });\n      }\n      if (state.backtrack === true) {\n        state.output = \"\";\n        for (const token2 of state.tokens) {\n          state.output += token2.output != null ? token2.output : token2.value;\n          if (token2.suffix) {\n            state.output += token2.suffix;\n          }\n        }\n      }\n      return state;\n    };\n    parse6.fastpaths = (input, options8) => {\n      const opts = { ...options8 };\n      const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      const len = input.length;\n      if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n      }\n      input = REPLACEMENTS[input] || input;\n      const win32 = utils.isWindows(options8);\n      const {\n        DOT_LITERAL,\n        SLASH_LITERAL,\n        ONE_CHAR,\n        DOTS_SLASH,\n        NO_DOT,\n        NO_DOTS,\n        NO_DOTS_SLASH,\n        STAR,\n        START_ANCHOR\n      } = constants.globChars(win32);\n      const nodot = opts.dot ? NO_DOTS : NO_DOT;\n      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n      const capture = opts.capture ? \"\" : \"?:\";\n      const state = { negated: false, prefix: \"\" };\n      let star = opts.bash === true ? \".*?\" : STAR;\n      if (opts.capture) {\n        star = `(${star})`;\n      }\n      const globstar = (opts2) => {\n        if (opts2.noglobstar === true)\n          return star;\n        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n      };\n      const create = (str2) => {\n        switch (str2) {\n          case \"*\":\n            return `${nodot}${ONE_CHAR}${star}`;\n          case \".*\":\n            return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case \"*.*\":\n            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case \"*/*\":\n            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n          case \"**\":\n            return nodot + globstar(opts);\n          case \"**/*\":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n          case \"**/*.*\":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case \"**/.*\":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n          default: {\n            const match = /^(.*?)\\.(\\w+)$/.exec(str2);\n            if (!match)\n              return;\n            const source3 = create(match[1]);\n            if (!source3)\n              return;\n            return source3 + DOT_LITERAL + match[2];\n          }\n        }\n      };\n      const output = utils.removePrefix(input, state);\n      let source2 = create(output);\n      if (source2 && opts.strictSlashes !== true) {\n        source2 += `${SLASH_LITERAL}?`;\n      }\n      return source2;\n    };\n    module.exports = parse6;\n  }\n});\n\n// node_modules/picomatch/lib/picomatch.js\nvar require_picomatch = __commonJS({\n  \"node_modules/picomatch/lib/picomatch.js\"(exports, module) {\n    \"use strict\";\n    var path13 = __require(\"path\");\n    var scan = require_scan();\n    var parse6 = require_parse2();\n    var utils = require_utils2();\n    var constants = require_constants2();\n    var isObject3 = (val) => val && typeof val === \"object\" && !Array.isArray(val);\n    var picomatch = (glob, options8, returnState = false) => {\n      if (Array.isArray(glob)) {\n        const fns = glob.map((input) => picomatch(input, options8, returnState));\n        const arrayMatcher = (str2) => {\n          for (const isMatch of fns) {\n            const state2 = isMatch(str2);\n            if (state2)\n              return state2;\n          }\n          return false;\n        };\n        return arrayMatcher;\n      }\n      const isState = isObject3(glob) && glob.tokens && glob.input;\n      if (glob === \"\" || typeof glob !== \"string\" && !isState) {\n        throw new TypeError(\"Expected pattern to be a non-empty string\");\n      }\n      const opts = options8 || {};\n      const posix = utils.isWindows(options8);\n      const regex = isState ? picomatch.compileRe(glob, options8) : picomatch.makeRe(glob, options8, false, true);\n      const state = regex.state;\n      delete regex.state;\n      let isIgnored2 = () => false;\n      if (opts.ignore) {\n        const ignoreOpts = { ...options8, ignore: null, onMatch: null, onResult: null };\n        isIgnored2 = picomatch(opts.ignore, ignoreOpts, returnState);\n      }\n      const matcher = (input, returnObject = false) => {\n        const { isMatch, match, output } = picomatch.test(input, regex, options8, { glob, posix });\n        const result = { glob, state, regex, posix, input, output, match, isMatch };\n        if (typeof opts.onResult === \"function\") {\n          opts.onResult(result);\n        }\n        if (isMatch === false) {\n          result.isMatch = false;\n          return returnObject ? result : false;\n        }\n        if (isIgnored2(input)) {\n          if (typeof opts.onIgnore === \"function\") {\n            opts.onIgnore(result);\n          }\n          result.isMatch = false;\n          return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === \"function\") {\n          opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n      };\n      if (returnState) {\n        matcher.state = state;\n      }\n      return matcher;\n    };\n    picomatch.test = (input, regex, options8, { glob, posix } = {}) => {\n      if (typeof input !== \"string\") {\n        throw new TypeError(\"Expected input to be a string\");\n      }\n      if (input === \"\") {\n        return { isMatch: false, output: \"\" };\n      }\n      const opts = options8 || {};\n      const format3 = opts.format || (posix ? utils.toPosixSlashes : null);\n      let match = input === glob;\n      let output = match && format3 ? format3(input) : input;\n      if (match === false) {\n        output = format3 ? format3(input) : input;\n        match = output === glob;\n      }\n      if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n          match = picomatch.matchBase(input, regex, options8, posix);\n        } else {\n          match = regex.exec(output);\n        }\n      }\n      return { isMatch: Boolean(match), match, output };\n    };\n    picomatch.matchBase = (input, glob, options8, posix = utils.isWindows(options8)) => {\n      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options8);\n      return regex.test(path13.basename(input));\n    };\n    picomatch.isMatch = (str2, patterns, options8) => picomatch(patterns, options8)(str2);\n    picomatch.parse = (pattern, options8) => {\n      if (Array.isArray(pattern))\n        return pattern.map((p) => picomatch.parse(p, options8));\n      return parse6(pattern, { ...options8, fastpaths: false });\n    };\n    picomatch.scan = (input, options8) => scan(input, options8);\n    picomatch.compileRe = (state, options8, returnOutput = false, returnState = false) => {\n      if (returnOutput === true) {\n        return state.output;\n      }\n      const opts = options8 || {};\n      const prepend = opts.contains ? \"\" : \"^\";\n      const append = opts.contains ? \"\" : \"$\";\n      let source2 = `${prepend}(?:${state.output})${append}`;\n      if (state && state.negated === true) {\n        source2 = `^(?!${source2}).*$`;\n      }\n      const regex = picomatch.toRegex(source2, options8);\n      if (returnState === true) {\n        regex.state = state;\n      }\n      return regex;\n    };\n    picomatch.makeRe = (input, options8 = {}, returnOutput = false, returnState = false) => {\n      if (!input || typeof input !== \"string\") {\n        throw new TypeError(\"Expected a non-empty string\");\n      }\n      let parsed = { negated: false, fastpaths: true };\n      if (options8.fastpaths !== false && (input[0] === \".\" || input[0] === \"*\")) {\n        parsed.output = parse6.fastpaths(input, options8);\n      }\n      if (!parsed.output) {\n        parsed = parse6(input, options8);\n      }\n      return picomatch.compileRe(parsed, options8, returnOutput, returnState);\n    };\n    picomatch.toRegex = (source2, options8) => {\n      try {\n        const opts = options8 || {};\n        return new RegExp(source2, opts.flags || (opts.nocase ? \"i\" : \"\"));\n      } catch (err) {\n        if (options8 && options8.debug === true)\n          throw err;\n        return /$^/;\n      }\n    };\n    picomatch.constants = constants;\n    module.exports = picomatch;\n  }\n});\n\n// node_modules/picomatch/index.js\nvar require_picomatch2 = __commonJS({\n  \"node_modules/picomatch/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = require_picomatch();\n  }\n});\n\n// node_modules/micromatch/index.js\nvar require_micromatch = __commonJS({\n  \"node_modules/micromatch/index.js\"(exports, module) {\n    \"use strict\";\n    var util2 = __require(\"util\");\n    var braces = require_braces();\n    var picomatch = require_picomatch2();\n    var utils = require_utils2();\n    var isEmptyString = (val) => val === \"\" || val === \"./\";\n    var micromatch2 = (list, patterns, options8) => {\n      patterns = [].concat(patterns);\n      list = [].concat(list);\n      let omit2 = /* @__PURE__ */ new Set();\n      let keep = /* @__PURE__ */ new Set();\n      let items = /* @__PURE__ */ new Set();\n      let negatives = 0;\n      let onResult = (state) => {\n        items.add(state.output);\n        if (options8 && options8.onResult) {\n          options8.onResult(state);\n        }\n      };\n      for (let i = 0; i < patterns.length; i++) {\n        let isMatch = picomatch(String(patterns[i]), { ...options8, onResult }, true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated)\n          negatives++;\n        for (let item of list) {\n          let matched = isMatch(item, true);\n          let match = negated ? !matched.isMatch : matched.isMatch;\n          if (!match)\n            continue;\n          if (negated) {\n            omit2.add(matched.output);\n          } else {\n            omit2.delete(matched.output);\n            keep.add(matched.output);\n          }\n        }\n      }\n      let result = negatives === patterns.length ? [...items] : [...keep];\n      let matches = result.filter((item) => !omit2.has(item));\n      if (options8 && matches.length === 0) {\n        if (options8.failglob === true) {\n          throw new Error(`No matches found for \"${patterns.join(\", \")}\"`);\n        }\n        if (options8.nonull === true || options8.nullglob === true) {\n          return options8.unescape ? patterns.map((p) => p.replace(/\\\\/g, \"\")) : patterns;\n        }\n      }\n      return matches;\n    };\n    micromatch2.match = micromatch2;\n    micromatch2.matcher = (pattern, options8) => picomatch(pattern, options8);\n    micromatch2.isMatch = (str2, patterns, options8) => picomatch(patterns, options8)(str2);\n    micromatch2.any = micromatch2.isMatch;\n    micromatch2.not = (list, patterns, options8 = {}) => {\n      patterns = [].concat(patterns).map(String);\n      let result = /* @__PURE__ */ new Set();\n      let items = [];\n      let onResult = (state) => {\n        if (options8.onResult)\n          options8.onResult(state);\n        items.push(state.output);\n      };\n      let matches = new Set(micromatch2(list, patterns, { ...options8, onResult }));\n      for (let item of items) {\n        if (!matches.has(item)) {\n          result.add(item);\n        }\n      }\n      return [...result];\n    };\n    micromatch2.contains = (str2, pattern, options8) => {\n      if (typeof str2 !== \"string\") {\n        throw new TypeError(`Expected a string: \"${util2.inspect(str2)}\"`);\n      }\n      if (Array.isArray(pattern)) {\n        return pattern.some((p) => micromatch2.contains(str2, p, options8));\n      }\n      if (typeof pattern === \"string\") {\n        if (isEmptyString(str2) || isEmptyString(pattern)) {\n          return false;\n        }\n        if (str2.includes(pattern) || str2.startsWith(\"./\") && str2.slice(2).includes(pattern)) {\n          return true;\n        }\n      }\n      return micromatch2.isMatch(str2, pattern, { ...options8, contains: true });\n    };\n    micromatch2.matchKeys = (obj, patterns, options8) => {\n      if (!utils.isObject(obj)) {\n        throw new TypeError(\"Expected the first argument to be an object\");\n      }\n      let keys = micromatch2(Object.keys(obj), patterns, options8);\n      let res = {};\n      for (let key2 of keys)\n        res[key2] = obj[key2];\n      return res;\n    };\n    micromatch2.some = (list, patterns, options8) => {\n      let items = [].concat(list);\n      for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch(String(pattern), options8);\n        if (items.some((item) => isMatch(item))) {\n          return true;\n        }\n      }\n      return false;\n    };\n    micromatch2.every = (list, patterns, options8) => {\n      let items = [].concat(list);\n      for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch(String(pattern), options8);\n        if (!items.every((item) => isMatch(item))) {\n          return false;\n        }\n      }\n      return true;\n    };\n    micromatch2.all = (str2, patterns, options8) => {\n      if (typeof str2 !== \"string\") {\n        throw new TypeError(`Expected a string: \"${util2.inspect(str2)}\"`);\n      }\n      return [].concat(patterns).every((p) => picomatch(p, options8)(str2));\n    };\n    micromatch2.capture = (glob, input, options8) => {\n      let posix = utils.isWindows(options8);\n      let regex = picomatch.makeRe(String(glob), { ...options8, capture: true });\n      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n      if (match) {\n        return match.slice(1).map((v) => v === void 0 ? \"\" : v);\n      }\n    };\n    micromatch2.makeRe = (...args) => picomatch.makeRe(...args);\n    micromatch2.scan = (...args) => picomatch.scan(...args);\n    micromatch2.parse = (patterns, options8) => {\n      let res = [];\n      for (let pattern of [].concat(patterns || [])) {\n        for (let str2 of braces(String(pattern), options8)) {\n          res.push(picomatch.parse(str2, options8));\n        }\n      }\n      return res;\n    };\n    micromatch2.braces = (pattern, options8) => {\n      if (typeof pattern !== \"string\")\n        throw new TypeError(\"Expected a string\");\n      if (options8 && options8.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n        return [pattern];\n      }\n      return braces(pattern, options8);\n    };\n    micromatch2.braceExpand = (pattern, options8) => {\n      if (typeof pattern !== \"string\")\n        throw new TypeError(\"Expected a string\");\n      return micromatch2.braces(pattern, { ...options8, expand: true });\n    };\n    module.exports = micromatch2;\n  }\n});\n\n// node_modules/fast-glob/out/utils/pattern.js\nvar require_pattern = __commonJS({\n  \"node_modules/fast-glob/out/utils/pattern.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.removeDuplicateSlashes = exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n    var path13 = __require(\"path\");\n    var globParent = require_glob_parent();\n    var micromatch2 = require_micromatch();\n    var GLOBSTAR = \"**\";\n    var ESCAPE_SYMBOL = \"\\\\\";\n    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\n    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\n    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\n    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\n    var BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n    var DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\n    function isStaticPattern(pattern, options8 = {}) {\n      return !isDynamicPattern(pattern, options8);\n    }\n    exports.isStaticPattern = isStaticPattern;\n    function isDynamicPattern(pattern, options8 = {}) {\n      if (pattern === \"\") {\n        return false;\n      }\n      if (options8.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n      }\n      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n      }\n      if (options8.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n      }\n      if (options8.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n      }\n      return false;\n    }\n    exports.isDynamicPattern = isDynamicPattern;\n    function hasBraceExpansion(pattern) {\n      const openingBraceIndex = pattern.indexOf(\"{\");\n      if (openingBraceIndex === -1) {\n        return false;\n      }\n      const closingBraceIndex = pattern.indexOf(\"}\", openingBraceIndex + 1);\n      if (closingBraceIndex === -1) {\n        return false;\n      }\n      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n    }\n    function convertToPositivePattern(pattern) {\n      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n    }\n    exports.convertToPositivePattern = convertToPositivePattern;\n    function convertToNegativePattern(pattern) {\n      return \"!\" + pattern;\n    }\n    exports.convertToNegativePattern = convertToNegativePattern;\n    function isNegativePattern(pattern) {\n      return pattern.startsWith(\"!\") && pattern[1] !== \"(\";\n    }\n    exports.isNegativePattern = isNegativePattern;\n    function isPositivePattern(pattern) {\n      return !isNegativePattern(pattern);\n    }\n    exports.isPositivePattern = isPositivePattern;\n    function getNegativePatterns(patterns) {\n      return patterns.filter(isNegativePattern);\n    }\n    exports.getNegativePatterns = getNegativePatterns;\n    function getPositivePatterns(patterns) {\n      return patterns.filter(isPositivePattern);\n    }\n    exports.getPositivePatterns = getPositivePatterns;\n    function getPatternsInsideCurrentDirectory(patterns) {\n      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n    }\n    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n    function getPatternsOutsideCurrentDirectory(patterns) {\n      return patterns.filter(isPatternRelatedToParentDirectory);\n    }\n    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n    function isPatternRelatedToParentDirectory(pattern) {\n      return pattern.startsWith(\"..\") || pattern.startsWith(\"./..\");\n    }\n    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n    function getBaseDirectory(pattern) {\n      return globParent(pattern, { flipBackslashes: false });\n    }\n    exports.getBaseDirectory = getBaseDirectory;\n    function hasGlobStar(pattern) {\n      return pattern.includes(GLOBSTAR);\n    }\n    exports.hasGlobStar = hasGlobStar;\n    function endsWithSlashGlobStar(pattern) {\n      return pattern.endsWith(\"/\" + GLOBSTAR);\n    }\n    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n    function isAffectDepthOfReadingPattern(pattern) {\n      const basename = path13.basename(pattern);\n      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n    }\n    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n    function expandPatternsWithBraceExpansion(patterns) {\n      return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n      }, []);\n    }\n    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n    function expandBraceExpansion(pattern) {\n      const patterns = micromatch2.braces(pattern, { expand: true, nodupes: true, keepEscaping: true });\n      patterns.sort((a, b) => a.length - b.length);\n      return patterns.filter((pattern2) => pattern2 !== \"\");\n    }\n    exports.expandBraceExpansion = expandBraceExpansion;\n    function getPatternParts(pattern, options8) {\n      let { parts } = micromatch2.scan(pattern, Object.assign(Object.assign({}, options8), { parts: true }));\n      if (parts.length === 0) {\n        parts = [pattern];\n      }\n      if (parts[0].startsWith(\"/\")) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift(\"\");\n      }\n      return parts;\n    }\n    exports.getPatternParts = getPatternParts;\n    function makeRe(pattern, options8) {\n      return micromatch2.makeRe(pattern, options8);\n    }\n    exports.makeRe = makeRe;\n    function convertPatternsToRe(patterns, options8) {\n      return patterns.map((pattern) => makeRe(pattern, options8));\n    }\n    exports.convertPatternsToRe = convertPatternsToRe;\n    function matchAny(entry, patternsRe) {\n      return patternsRe.some((patternRe) => patternRe.test(entry));\n    }\n    exports.matchAny = matchAny;\n    function removeDuplicateSlashes(pattern) {\n      return pattern.replace(DOUBLE_SLASH_RE, \"/\");\n    }\n    exports.removeDuplicateSlashes = removeDuplicateSlashes;\n  }\n});\n\n// node_modules/merge2/index.js\nvar require_merge2 = __commonJS({\n  \"node_modules/merge2/index.js\"(exports, module) {\n    \"use strict\";\n    var Stream = __require(\"stream\");\n    var PassThrough = Stream.PassThrough;\n    var slice = Array.prototype.slice;\n    module.exports = merge2;\n    function merge2() {\n      const streamsQueue = [];\n      const args = slice.call(arguments);\n      let merging = false;\n      let options8 = args[args.length - 1];\n      if (options8 && !Array.isArray(options8) && options8.pipe == null) {\n        args.pop();\n      } else {\n        options8 = {};\n      }\n      const doEnd = options8.end !== false;\n      const doPipeError = options8.pipeError === true;\n      if (options8.objectMode == null) {\n        options8.objectMode = true;\n      }\n      if (options8.highWaterMark == null) {\n        options8.highWaterMark = 64 * 1024;\n      }\n      const mergedStream = PassThrough(options8);\n      function addStream() {\n        for (let i = 0, len = arguments.length; i < len; i++) {\n          streamsQueue.push(pauseStreams(arguments[i], options8));\n        }\n        mergeStream();\n        return this;\n      }\n      function mergeStream() {\n        if (merging) {\n          return;\n        }\n        merging = true;\n        let streams = streamsQueue.shift();\n        if (!streams) {\n          process.nextTick(endStream);\n          return;\n        }\n        if (!Array.isArray(streams)) {\n          streams = [streams];\n        }\n        let pipesCount = streams.length + 1;\n        function next() {\n          if (--pipesCount > 0) {\n            return;\n          }\n          merging = false;\n          mergeStream();\n        }\n        function pipe(stream) {\n          function onend() {\n            stream.removeListener(\"merge2UnpipeEnd\", onend);\n            stream.removeListener(\"end\", onend);\n            if (doPipeError) {\n              stream.removeListener(\"error\", onerror);\n            }\n            next();\n          }\n          function onerror(err) {\n            mergedStream.emit(\"error\", err);\n          }\n          if (stream._readableState.endEmitted) {\n            return next();\n          }\n          stream.on(\"merge2UnpipeEnd\", onend);\n          stream.on(\"end\", onend);\n          if (doPipeError) {\n            stream.on(\"error\", onerror);\n          }\n          stream.pipe(mergedStream, { end: false });\n          stream.resume();\n        }\n        for (let i = 0; i < streams.length; i++) {\n          pipe(streams[i]);\n        }\n        next();\n      }\n      function endStream() {\n        merging = false;\n        mergedStream.emit(\"queueDrain\");\n        if (doEnd) {\n          mergedStream.end();\n        }\n      }\n      mergedStream.setMaxListeners(0);\n      mergedStream.add = addStream;\n      mergedStream.on(\"unpipe\", function(stream) {\n        stream.emit(\"merge2UnpipeEnd\");\n      });\n      if (args.length) {\n        addStream.apply(null, args);\n      }\n      return mergedStream;\n    }\n    function pauseStreams(streams, options8) {\n      if (!Array.isArray(streams)) {\n        if (!streams._readableState && streams.pipe) {\n          streams = streams.pipe(PassThrough(options8));\n        }\n        if (!streams._readableState || !streams.pause || !streams.pipe) {\n          throw new Error(\"Only readable stream can be merged.\");\n        }\n        streams.pause();\n      } else {\n        for (let i = 0, len = streams.length; i < len; i++) {\n          streams[i] = pauseStreams(streams[i], options8);\n        }\n      }\n      return streams;\n    }\n  }\n});\n\n// node_modules/fast-glob/out/utils/stream.js\nvar require_stream = __commonJS({\n  \"node_modules/fast-glob/out/utils/stream.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.merge = void 0;\n    var merge2 = require_merge2();\n    function merge3(streams) {\n      const mergedStream = merge2(streams);\n      streams.forEach((stream) => {\n        stream.once(\"error\", (error) => mergedStream.emit(\"error\", error));\n      });\n      mergedStream.once(\"close\", () => propagateCloseEventToSources(streams));\n      mergedStream.once(\"end\", () => propagateCloseEventToSources(streams));\n      return mergedStream;\n    }\n    exports.merge = merge3;\n    function propagateCloseEventToSources(streams) {\n      streams.forEach((stream) => stream.emit(\"close\"));\n    }\n  }\n});\n\n// node_modules/fast-glob/out/utils/string.js\nvar require_string = __commonJS({\n  \"node_modules/fast-glob/out/utils/string.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.isEmpty = exports.isString = void 0;\n    function isString(input) {\n      return typeof input === \"string\";\n    }\n    exports.isString = isString;\n    function isEmpty(input) {\n      return input === \"\";\n    }\n    exports.isEmpty = isEmpty;\n  }\n});\n\n// node_modules/fast-glob/out/utils/index.js\nvar require_utils3 = __commonJS({\n  \"node_modules/fast-glob/out/utils/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;\n    var array2 = require_array();\n    exports.array = array2;\n    var errno = require_errno();\n    exports.errno = errno;\n    var fs7 = require_fs();\n    exports.fs = fs7;\n    var path13 = require_path();\n    exports.path = path13;\n    var pattern = require_pattern();\n    exports.pattern = pattern;\n    var stream = require_stream();\n    exports.stream = stream;\n    var string = require_string();\n    exports.string = string;\n  }\n});\n\n// node_modules/fast-glob/out/managers/tasks.js\nvar require_tasks = __commonJS({\n  \"node_modules/fast-glob/out/managers/tasks.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;\n    var utils = require_utils3();\n    function generate(input, settings) {\n      const patterns = processPatterns(input, settings);\n      const ignore = processPatterns(settings.ignore, settings);\n      const positivePatterns = getPositivePatterns(patterns);\n      const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);\n      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\n      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\n      const staticTasks = convertPatternsToTasks(\n        staticPatterns,\n        negativePatterns,\n        /* dynamic */\n        false\n      );\n      const dynamicTasks = convertPatternsToTasks(\n        dynamicPatterns,\n        negativePatterns,\n        /* dynamic */\n        true\n      );\n      return staticTasks.concat(dynamicTasks);\n    }\n    exports.generate = generate;\n    function processPatterns(input, settings) {\n      let patterns = input;\n      if (settings.braceExpansion) {\n        patterns = utils.pattern.expandPatternsWithBraceExpansion(patterns);\n      }\n      if (settings.baseNameMatch) {\n        patterns = patterns.map((pattern) => pattern.includes(\"/\") ? pattern : `**/${pattern}`);\n      }\n      return patterns.map((pattern) => utils.pattern.removeDuplicateSlashes(pattern));\n    }\n    function convertPatternsToTasks(positive, negative, dynamic) {\n      const tasks = [];\n      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\n      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\n      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\n      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\n      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\n      if (\".\" in insideCurrentDirectoryGroup) {\n        tasks.push(convertPatternGroupToTask(\".\", patternsInsideCurrentDirectory, negative, dynamic));\n      } else {\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\n      }\n      return tasks;\n    }\n    exports.convertPatternsToTasks = convertPatternsToTasks;\n    function getPositivePatterns(patterns) {\n      return utils.pattern.getPositivePatterns(patterns);\n    }\n    exports.getPositivePatterns = getPositivePatterns;\n    function getNegativePatternsAsPositive(patterns, ignore) {\n      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\n      const positive = negative.map(utils.pattern.convertToPositivePattern);\n      return positive;\n    }\n    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\n    function groupPatternsByBaseDirectory(patterns) {\n      const group = {};\n      return patterns.reduce((collection, pattern) => {\n        const base = utils.pattern.getBaseDirectory(pattern);\n        if (base in collection) {\n          collection[base].push(pattern);\n        } else {\n          collection[base] = [pattern];\n        }\n        return collection;\n      }, group);\n    }\n    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\n    function convertPatternGroupsToTasks(positive, negative, dynamic) {\n      return Object.keys(positive).map((base) => {\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n      });\n    }\n    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\n    function convertPatternGroupToTask(base, positive, negative, dynamic) {\n      return {\n        dynamic,\n        positive,\n        negative,\n        base,\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\n      };\n    }\n    exports.convertPatternGroupToTask = convertPatternGroupToTask;\n  }\n});\n\n// node_modules/@nodelib/fs.stat/out/providers/async.js\nvar require_async = __commonJS({\n  \"node_modules/@nodelib/fs.stat/out/providers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.read = void 0;\n    function read3(path13, settings, callback) {\n      settings.fs.lstat(path13, (lstatError, lstat) => {\n        if (lstatError !== null) {\n          callFailureCallback(callback, lstatError);\n          return;\n        }\n        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n          callSuccessCallback(callback, lstat);\n          return;\n        }\n        settings.fs.stat(path13, (statError, stat) => {\n          if (statError !== null) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              callFailureCallback(callback, statError);\n              return;\n            }\n            callSuccessCallback(callback, lstat);\n            return;\n          }\n          if (settings.markSymbolicLink) {\n            stat.isSymbolicLink = () => true;\n          }\n          callSuccessCallback(callback, stat);\n        });\n      });\n    }\n    exports.read = read3;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, result) {\n      callback(null, result);\n    }\n  }\n});\n\n// node_modules/@nodelib/fs.stat/out/providers/sync.js\nvar require_sync = __commonJS({\n  \"node_modules/@nodelib/fs.stat/out/providers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.read = void 0;\n    function read3(path13, settings) {\n      const lstat = settings.fs.lstatSync(path13);\n      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n        return lstat;\n      }\n      try {\n        const stat = settings.fs.statSync(path13);\n        if (settings.markSymbolicLink) {\n          stat.isSymbolicLink = () => true;\n        }\n        return stat;\n      } catch (error) {\n        if (!settings.throwErrorOnBrokenSymbolicLink) {\n          return lstat;\n        }\n        throw error;\n      }\n    }\n    exports.read = read3;\n  }\n});\n\n// node_modules/@nodelib/fs.stat/out/adapters/fs.js\nvar require_fs2 = __commonJS({\n  \"node_modules/@nodelib/fs.stat/out/adapters/fs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\n    var fs7 = __require(\"fs\");\n    exports.FILE_SYSTEM_ADAPTER = {\n      lstat: fs7.lstat,\n      stat: fs7.stat,\n      lstatSync: fs7.lstatSync,\n      statSync: fs7.statSync\n    };\n    function createFileSystemAdapter(fsMethods) {\n      if (fsMethods === void 0) {\n        return exports.FILE_SYSTEM_ADAPTER;\n      }\n      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n    }\n    exports.createFileSystemAdapter = createFileSystemAdapter;\n  }\n});\n\n// node_modules/@nodelib/fs.stat/out/settings.js\nvar require_settings = __commonJS({\n  \"node_modules/@nodelib/fs.stat/out/settings.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fs7 = require_fs2();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\n        this.fs = fs7.createFileSystemAdapter(this._options.fs);\n        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports.default = Settings;\n  }\n});\n\n// node_modules/@nodelib/fs.stat/out/index.js\nvar require_out = __commonJS({\n  \"node_modules/@nodelib/fs.stat/out/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.statSync = exports.stat = exports.Settings = void 0;\n    var async = require_async();\n    var sync = require_sync();\n    var settings_1 = require_settings();\n    exports.Settings = settings_1.default;\n    function stat(path13, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === \"function\") {\n        async.read(path13, getSettings(), optionsOrSettingsOrCallback);\n        return;\n      }\n      async.read(path13, getSettings(optionsOrSettingsOrCallback), callback);\n    }\n    exports.stat = stat;\n    function statSync2(path13, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      return sync.read(path13, settings);\n    }\n    exports.statSync = statSync2;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\n\n// node_modules/queue-microtask/index.js\nvar require_queue_microtask = __commonJS({\n  \"node_modules/queue-microtask/index.js\"(exports, module) {\n    var promise;\n    module.exports = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n      throw err;\n    }, 0));\n  }\n});\n\n// node_modules/run-parallel/index.js\nvar require_run_parallel = __commonJS({\n  \"node_modules/run-parallel/index.js\"(exports, module) {\n    module.exports = runParallel;\n    var queueMicrotask2 = require_queue_microtask();\n    function runParallel(tasks, cb) {\n      let results, pending, keys;\n      let isSync = true;\n      if (Array.isArray(tasks)) {\n        results = [];\n        pending = tasks.length;\n      } else {\n        keys = Object.keys(tasks);\n        results = {};\n        pending = keys.length;\n      }\n      function done(err) {\n        function end() {\n          if (cb)\n            cb(err, results);\n          cb = null;\n        }\n        if (isSync)\n          queueMicrotask2(end);\n        else\n          end();\n      }\n      function each(i, err, result) {\n        results[i] = result;\n        if (--pending === 0 || err) {\n          done(err);\n        }\n      }\n      if (!pending) {\n        done(null);\n      } else if (keys) {\n        keys.forEach(function(key2) {\n          tasks[key2](function(err, result) {\n            each(key2, err, result);\n          });\n        });\n      } else {\n        tasks.forEach(function(task, i) {\n          task(function(err, result) {\n            each(i, err, result);\n          });\n        });\n      }\n      isSync = false;\n    }\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/constants.js\nvar require_constants3 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/constants.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;\n    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(\".\");\n    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {\n      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);\n    }\n    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\n    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\n    var SUPPORTED_MAJOR_VERSION = 10;\n    var SUPPORTED_MINOR_VERSION = 10;\n    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\n    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\n    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/utils/fs.js\nvar require_fs3 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/utils/fs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.createDirentFromStats = void 0;\n    var DirentFromStats = class {\n      constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n      }\n    };\n    function createDirentFromStats(name, stats) {\n      return new DirentFromStats(name, stats);\n    }\n    exports.createDirentFromStats = createDirentFromStats;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/utils/index.js\nvar require_utils4 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/utils/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.fs = void 0;\n    var fs7 = require_fs3();\n    exports.fs = fs7;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/providers/common.js\nvar require_common = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/providers/common.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.joinPathSegments = void 0;\n    function joinPathSegments(a, b, separator) {\n      if (a.endsWith(separator)) {\n        return a + b;\n      }\n      return a + separator + b;\n    }\n    exports.joinPathSegments = joinPathSegments;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/providers/async.js\nvar require_async2 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/providers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\n    var fsStat = require_out();\n    var rpl = require_run_parallel();\n    var constants_1 = require_constants3();\n    var utils = require_utils4();\n    var common2 = require_common();\n    function read3(directory, settings, callback) {\n      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        readdirWithFileTypes(directory, settings, callback);\n        return;\n      }\n      readdir(directory, settings, callback);\n    }\n    exports.read = read3;\n    function readdirWithFileTypes(directory, settings, callback) {\n      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {\n        if (readdirError !== null) {\n          callFailureCallback(callback, readdirError);\n          return;\n        }\n        const entries = dirents.map((dirent) => ({\n          dirent,\n          name: dirent.name,\n          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        }));\n        if (!settings.followSymbolicLinks) {\n          callSuccessCallback(callback, entries);\n          return;\n        }\n        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));\n        rpl(tasks, (rplError, rplEntries) => {\n          if (rplError !== null) {\n            callFailureCallback(callback, rplError);\n            return;\n          }\n          callSuccessCallback(callback, rplEntries);\n        });\n      });\n    }\n    exports.readdirWithFileTypes = readdirWithFileTypes;\n    function makeRplTaskEntry(entry, settings) {\n      return (done) => {\n        if (!entry.dirent.isSymbolicLink()) {\n          done(null, entry);\n          return;\n        }\n        settings.fs.stat(entry.path, (statError, stats) => {\n          if (statError !== null) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              done(statError);\n              return;\n            }\n            done(null, entry);\n            return;\n          }\n          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n          done(null, entry);\n        });\n      };\n    }\n    function readdir(directory, settings, callback) {\n      settings.fs.readdir(directory, (readdirError, names) => {\n        if (readdirError !== null) {\n          callFailureCallback(callback, readdirError);\n          return;\n        }\n        const tasks = names.map((name) => {\n          const path13 = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n          return (done) => {\n            fsStat.stat(path13, settings.fsStatSettings, (error, stats) => {\n              if (error !== null) {\n                done(error);\n                return;\n              }\n              const entry = {\n                name,\n                path: path13,\n                dirent: utils.fs.createDirentFromStats(name, stats)\n              };\n              if (settings.stats) {\n                entry.stats = stats;\n              }\n              done(null, entry);\n            });\n          };\n        });\n        rpl(tasks, (rplError, entries) => {\n          if (rplError !== null) {\n            callFailureCallback(callback, rplError);\n            return;\n          }\n          callSuccessCallback(callback, entries);\n        });\n      });\n    }\n    exports.readdir = readdir;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, result) {\n      callback(null, result);\n    }\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/providers/sync.js\nvar require_sync2 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/providers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;\n    var fsStat = require_out();\n    var constants_1 = require_constants3();\n    var utils = require_utils4();\n    var common2 = require_common();\n    function read3(directory, settings) {\n      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        return readdirWithFileTypes(directory, settings);\n      }\n      return readdir(directory, settings);\n    }\n    exports.read = read3;\n    function readdirWithFileTypes(directory, settings) {\n      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });\n      return dirents.map((dirent) => {\n        const entry = {\n          dirent,\n          name: dirent.name,\n          path: common2.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        };\n        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\n          try {\n            const stats = settings.fs.statSync(entry.path);\n            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n          } catch (error) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              throw error;\n            }\n          }\n        }\n        return entry;\n      });\n    }\n    exports.readdirWithFileTypes = readdirWithFileTypes;\n    function readdir(directory, settings) {\n      const names = settings.fs.readdirSync(directory);\n      return names.map((name) => {\n        const entryPath = common2.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\n        const entry = {\n          name,\n          path: entryPath,\n          dirent: utils.fs.createDirentFromStats(name, stats)\n        };\n        if (settings.stats) {\n          entry.stats = stats;\n        }\n        return entry;\n      });\n    }\n    exports.readdir = readdir;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/adapters/fs.js\nvar require_fs4 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/adapters/fs.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;\n    var fs7 = __require(\"fs\");\n    exports.FILE_SYSTEM_ADAPTER = {\n      lstat: fs7.lstat,\n      stat: fs7.stat,\n      lstatSync: fs7.lstatSync,\n      statSync: fs7.statSync,\n      readdir: fs7.readdir,\n      readdirSync: fs7.readdirSync\n    };\n    function createFileSystemAdapter(fsMethods) {\n      if (fsMethods === void 0) {\n        return exports.FILE_SYSTEM_ADAPTER;\n      }\n      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);\n    }\n    exports.createFileSystemAdapter = createFileSystemAdapter;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/settings.js\nvar require_settings2 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/settings.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var path13 = __require(\"path\");\n    var fsStat = require_out();\n    var fs7 = require_fs4();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\n        this.fs = fs7.createFileSystemAdapter(this._options.fs);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path13.sep);\n        this.stats = this._getValue(this._options.stats, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n        this.fsStatSettings = new fsStat.Settings({\n          followSymbolicLink: this.followSymbolicLinks,\n          fs: this.fs,\n          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\n        });\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports.default = Settings;\n  }\n});\n\n// node_modules/@nodelib/fs.scandir/out/index.js\nvar require_out2 = __commonJS({\n  \"node_modules/@nodelib/fs.scandir/out/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Settings = exports.scandirSync = exports.scandir = void 0;\n    var async = require_async2();\n    var sync = require_sync2();\n    var settings_1 = require_settings2();\n    exports.Settings = settings_1.default;\n    function scandir(path13, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === \"function\") {\n        async.read(path13, getSettings(), optionsOrSettingsOrCallback);\n        return;\n      }\n      async.read(path13, getSettings(optionsOrSettingsOrCallback), callback);\n    }\n    exports.scandir = scandir;\n    function scandirSync(path13, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      return sync.read(path13, settings);\n    }\n    exports.scandirSync = scandirSync;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\n\n// node_modules/reusify/reusify.js\nvar require_reusify = __commonJS({\n  \"node_modules/reusify/reusify.js\"(exports, module) {\n    \"use strict\";\n    function reusify(Constructor) {\n      var head = new Constructor();\n      var tail = head;\n      function get() {\n        var current = head;\n        if (current.next) {\n          head = current.next;\n        } else {\n          head = new Constructor();\n          tail = head;\n        }\n        current.next = null;\n        return current;\n      }\n      function release(obj) {\n        tail.next = obj;\n        tail = obj;\n      }\n      return {\n        get,\n        release\n      };\n    }\n    module.exports = reusify;\n  }\n});\n\n// node_modules/fastq/queue.js\nvar require_queue = __commonJS({\n  \"node_modules/fastq/queue.js\"(exports, module) {\n    \"use strict\";\n    var reusify = require_reusify();\n    function fastqueue(context, worker, concurrency) {\n      if (typeof context === \"function\") {\n        concurrency = worker;\n        worker = context;\n        context = null;\n      }\n      if (concurrency < 1) {\n        throw new Error(\"fastqueue concurrency must be greater than 1\");\n      }\n      var cache3 = reusify(Task);\n      var queueHead = null;\n      var queueTail = null;\n      var _running = 0;\n      var errorHandler = null;\n      var self = {\n        push: push2,\n        drain: noop2,\n        saturated: noop2,\n        pause,\n        paused: false,\n        concurrency,\n        running,\n        resume,\n        idle,\n        length,\n        getQueue,\n        unshift,\n        empty: noop2,\n        kill,\n        killAndDrain,\n        error\n      };\n      return self;\n      function running() {\n        return _running;\n      }\n      function pause() {\n        self.paused = true;\n      }\n      function length() {\n        var current = queueHead;\n        var counter = 0;\n        while (current) {\n          current = current.next;\n          counter++;\n        }\n        return counter;\n      }\n      function getQueue() {\n        var current = queueHead;\n        var tasks = [];\n        while (current) {\n          tasks.push(current.value);\n          current = current.next;\n        }\n        return tasks;\n      }\n      function resume() {\n        if (!self.paused)\n          return;\n        self.paused = false;\n        for (var i = 0; i < self.concurrency; i++) {\n          _running++;\n          release();\n        }\n      }\n      function idle() {\n        return _running === 0 && self.length() === 0;\n      }\n      function push2(value, done) {\n        var current = cache3.get();\n        current.context = context;\n        current.release = release;\n        current.value = value;\n        current.callback = done || noop2;\n        current.errorHandler = errorHandler;\n        if (_running === self.concurrency || self.paused) {\n          if (queueTail) {\n            queueTail.next = current;\n            queueTail = current;\n          } else {\n            queueHead = current;\n            queueTail = current;\n            self.saturated();\n          }\n        } else {\n          _running++;\n          worker.call(context, current.value, current.worked);\n        }\n      }\n      function unshift(value, done) {\n        var current = cache3.get();\n        current.context = context;\n        current.release = release;\n        current.value = value;\n        current.callback = done || noop2;\n        if (_running === self.concurrency || self.paused) {\n          if (queueHead) {\n            current.next = queueHead;\n            queueHead = current;\n          } else {\n            queueHead = current;\n            queueTail = current;\n            self.saturated();\n          }\n        } else {\n          _running++;\n          worker.call(context, current.value, current.worked);\n        }\n      }\n      function release(holder) {\n        if (holder) {\n          cache3.release(holder);\n        }\n        var next = queueHead;\n        if (next) {\n          if (!self.paused) {\n            if (queueTail === queueHead) {\n              queueTail = null;\n            }\n            queueHead = next.next;\n            next.next = null;\n            worker.call(context, next.value, next.worked);\n            if (queueTail === null) {\n              self.empty();\n            }\n          } else {\n            _running--;\n          }\n        } else if (--_running === 0) {\n          self.drain();\n        }\n      }\n      function kill() {\n        queueHead = null;\n        queueTail = null;\n        self.drain = noop2;\n      }\n      function killAndDrain() {\n        queueHead = null;\n        queueTail = null;\n        self.drain();\n        self.drain = noop2;\n      }\n      function error(handler) {\n        errorHandler = handler;\n      }\n    }\n    function noop2() {\n    }\n    function Task() {\n      this.value = null;\n      this.callback = noop2;\n      this.next = null;\n      this.release = noop2;\n      this.context = null;\n      this.errorHandler = null;\n      var self = this;\n      this.worked = function worked(err, result) {\n        var callback = self.callback;\n        var errorHandler = self.errorHandler;\n        var val = self.value;\n        self.value = null;\n        self.callback = noop2;\n        if (self.errorHandler) {\n          errorHandler(err, val);\n        }\n        callback.call(self.context, err, result);\n        self.release(self);\n      };\n    }\n    function queueAsPromised(context, worker, concurrency) {\n      if (typeof context === \"function\") {\n        concurrency = worker;\n        worker = context;\n        context = null;\n      }\n      function asyncWrapper(arg, cb) {\n        worker.call(this, arg).then(function(res) {\n          cb(null, res);\n        }, cb);\n      }\n      var queue = fastqueue(context, asyncWrapper, concurrency);\n      var pushCb = queue.push;\n      var unshiftCb = queue.unshift;\n      queue.push = push2;\n      queue.unshift = unshift;\n      queue.drained = drained;\n      return queue;\n      function push2(value) {\n        var p = new Promise(function(resolve3, reject) {\n          pushCb(value, function(err, result) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve3(result);\n          });\n        });\n        p.catch(noop2);\n        return p;\n      }\n      function unshift(value) {\n        var p = new Promise(function(resolve3, reject) {\n          unshiftCb(value, function(err, result) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve3(result);\n          });\n        });\n        p.catch(noop2);\n        return p;\n      }\n      function drained() {\n        if (queue.idle()) {\n          return new Promise(function(resolve3) {\n            resolve3();\n          });\n        }\n        var previousDrain = queue.drain;\n        var p = new Promise(function(resolve3) {\n          queue.drain = function() {\n            previousDrain();\n            resolve3();\n          };\n        });\n        return p;\n      }\n    }\n    module.exports = fastqueue;\n    module.exports.promise = queueAsPromised;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/readers/common.js\nvar require_common2 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/readers/common.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;\n    function isFatalError(settings, error) {\n      if (settings.errorFilter === null) {\n        return true;\n      }\n      return !settings.errorFilter(error);\n    }\n    exports.isFatalError = isFatalError;\n    function isAppliedFilter(filter2, value) {\n      return filter2 === null || filter2(value);\n    }\n    exports.isAppliedFilter = isAppliedFilter;\n    function replacePathSegmentSeparator(filepath, separator) {\n      return filepath.split(/[/\\\\]/).join(separator);\n    }\n    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;\n    function joinPathSegments(a, b, separator) {\n      if (a === \"\") {\n        return b;\n      }\n      if (a.endsWith(separator)) {\n        return a + b;\n      }\n      return a + separator + b;\n    }\n    exports.joinPathSegments = joinPathSegments;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/readers/reader.js\nvar require_reader = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/readers/reader.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var common2 = require_common2();\n    var Reader = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._root = common2.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\n      }\n    };\n    exports.default = Reader;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/readers/async.js\nvar require_async3 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/readers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var events_1 = __require(\"events\");\n    var fsScandir = require_out2();\n    var fastq = require_queue();\n    var common2 = require_common2();\n    var reader_1 = require_reader();\n    var AsyncReader = class extends reader_1.default {\n      constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n          if (!this._isFatalError) {\n            this._emitter.emit(\"end\");\n          }\n        };\n      }\n      read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n          this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n      }\n      get isDestroyed() {\n        return this._isDestroyed;\n      }\n      destroy() {\n        if (this._isDestroyed) {\n          throw new Error(\"The reader is already destroyed\");\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n      }\n      onEntry(callback) {\n        this._emitter.on(\"entry\", callback);\n      }\n      onError(callback) {\n        this._emitter.once(\"error\", callback);\n      }\n      onEnd(callback) {\n        this._emitter.once(\"end\", callback);\n      }\n      _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n          if (error !== null) {\n            this._handleError(error);\n          }\n        });\n      }\n      _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n          if (error !== null) {\n            done(error, void 0);\n            return;\n          }\n          for (const entry of entries) {\n            this._handleEntry(entry, item.base);\n          }\n          done(null, void 0);\n        });\n      }\n      _handleError(error) {\n        if (this._isDestroyed || !common2.isFatalError(this._settings, error)) {\n          return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit(\"error\", error);\n      }\n      _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n          return;\n        }\n        const fullpath = entry.path;\n        if (base !== void 0) {\n          entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common2.isAppliedFilter(this._settings.entryFilter, entry)) {\n          this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry)) {\n          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);\n        }\n      }\n      _emitEntry(entry) {\n        this._emitter.emit(\"entry\", entry);\n      }\n    };\n    exports.default = AsyncReader;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/providers/async.js\nvar require_async4 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/providers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var async_1 = require_async3();\n    var AsyncProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._storage = [];\n      }\n      read(callback) {\n        this._reader.onError((error) => {\n          callFailureCallback(callback, error);\n        });\n        this._reader.onEntry((entry) => {\n          this._storage.push(entry);\n        });\n        this._reader.onEnd(() => {\n          callSuccessCallback(callback, this._storage);\n        });\n        this._reader.read();\n      }\n    };\n    exports.default = AsyncProvider;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, entries) {\n      callback(null, entries);\n    }\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/providers/stream.js\nvar require_stream2 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/providers/stream.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var stream_1 = __require(\"stream\");\n    var async_1 = require_async3();\n    var StreamProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._stream = new stream_1.Readable({\n          objectMode: true,\n          read: () => {\n          },\n          destroy: () => {\n            if (!this._reader.isDestroyed) {\n              this._reader.destroy();\n            }\n          }\n        });\n      }\n      read() {\n        this._reader.onError((error) => {\n          this._stream.emit(\"error\", error);\n        });\n        this._reader.onEntry((entry) => {\n          this._stream.push(entry);\n        });\n        this._reader.onEnd(() => {\n          this._stream.push(null);\n        });\n        this._reader.read();\n        return this._stream;\n      }\n    };\n    exports.default = StreamProvider;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/readers/sync.js\nvar require_sync3 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/readers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fsScandir = require_out2();\n    var common2 = require_common2();\n    var reader_1 = require_reader();\n    var SyncReader = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._scandir = fsScandir.scandirSync;\n        this._storage = [];\n        this._queue = /* @__PURE__ */ new Set();\n      }\n      read() {\n        this._pushToQueue(this._root, this._settings.basePath);\n        this._handleQueue();\n        return this._storage;\n      }\n      _pushToQueue(directory, base) {\n        this._queue.add({ directory, base });\n      }\n      _handleQueue() {\n        for (const item of this._queue.values()) {\n          this._handleDirectory(item.directory, item.base);\n        }\n      }\n      _handleDirectory(directory, base) {\n        try {\n          const entries = this._scandir(directory, this._settings.fsScandirSettings);\n          for (const entry of entries) {\n            this._handleEntry(entry, base);\n          }\n        } catch (error) {\n          this._handleError(error);\n        }\n      }\n      _handleError(error) {\n        if (!common2.isFatalError(this._settings, error)) {\n          return;\n        }\n        throw error;\n      }\n      _handleEntry(entry, base) {\n        const fullpath = entry.path;\n        if (base !== void 0) {\n          entry.path = common2.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common2.isAppliedFilter(this._settings.entryFilter, entry)) {\n          this._pushToStorage(entry);\n        }\n        if (entry.dirent.isDirectory() && common2.isAppliedFilter(this._settings.deepFilter, entry)) {\n          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);\n        }\n      }\n      _pushToStorage(entry) {\n        this._storage.push(entry);\n      }\n    };\n    exports.default = SyncReader;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/providers/sync.js\nvar require_sync4 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/providers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var sync_1 = require_sync3();\n    var SyncProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new sync_1.default(this._root, this._settings);\n      }\n      read() {\n        return this._reader.read();\n      }\n    };\n    exports.default = SyncProvider;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/settings.js\nvar require_settings3 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/settings.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var path13 = __require(\"path\");\n    var fsScandir = require_out2();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.basePath = this._getValue(this._options.basePath, void 0);\n        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);\n        this.deepFilter = this._getValue(this._options.deepFilter, null);\n        this.entryFilter = this._getValue(this._options.entryFilter, null);\n        this.errorFilter = this._getValue(this._options.errorFilter, null);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path13.sep);\n        this.fsScandirSettings = new fsScandir.Settings({\n          followSymbolicLinks: this._options.followSymbolicLinks,\n          fs: this._options.fs,\n          pathSegmentSeparator: this._options.pathSegmentSeparator,\n          stats: this._options.stats,\n          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\n        });\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports.default = Settings;\n  }\n});\n\n// node_modules/@nodelib/fs.walk/out/index.js\nvar require_out3 = __commonJS({\n  \"node_modules/@nodelib/fs.walk/out/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;\n    var async_1 = require_async4();\n    var stream_1 = require_stream2();\n    var sync_1 = require_sync4();\n    var settings_1 = require_settings3();\n    exports.Settings = settings_1.default;\n    function walk(directory, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === \"function\") {\n        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\n        return;\n      }\n      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\n    }\n    exports.walk = walk;\n    function walkSync(directory, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      const provider = new sync_1.default(directory, settings);\n      return provider.read();\n    }\n    exports.walkSync = walkSync;\n    function walkStream(directory, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      const provider = new stream_1.default(directory, settings);\n      return provider.read();\n    }\n    exports.walkStream = walkStream;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\n\n// node_modules/fast-glob/out/readers/reader.js\nvar require_reader2 = __commonJS({\n  \"node_modules/fast-glob/out/readers/reader.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var path13 = __require(\"path\");\n    var fsStat = require_out();\n    var utils = require_utils3();\n    var Reader = class {\n      constructor(_settings) {\n        this._settings = _settings;\n        this._fsStatSettings = new fsStat.Settings({\n          followSymbolicLink: this._settings.followSymbolicLinks,\n          fs: this._settings.fs,\n          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\n        });\n      }\n      _getFullEntryPath(filepath) {\n        return path13.resolve(this._settings.cwd, filepath);\n      }\n      _makeEntry(stats, pattern) {\n        const entry = {\n          name: pattern,\n          path: pattern,\n          dirent: utils.fs.createDirentFromStats(pattern, stats)\n        };\n        if (this._settings.stats) {\n          entry.stats = stats;\n        }\n        return entry;\n      }\n      _isFatalError(error) {\n        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\n      }\n    };\n    exports.default = Reader;\n  }\n});\n\n// node_modules/fast-glob/out/readers/stream.js\nvar require_stream3 = __commonJS({\n  \"node_modules/fast-glob/out/readers/stream.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var stream_1 = __require(\"stream\");\n    var fsStat = require_out();\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var ReaderStream = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkStream = fsWalk.walkStream;\n        this._stat = fsStat.stat;\n      }\n      dynamic(root2, options8) {\n        return this._walkStream(root2, options8);\n      }\n      static(patterns, options8) {\n        const filepaths = patterns.map(this._getFullEntryPath, this);\n        const stream = new stream_1.PassThrough({ objectMode: true });\n        stream._write = (index, _enc, done) => {\n          return this._getEntry(filepaths[index], patterns[index], options8).then((entry) => {\n            if (entry !== null && options8.entryFilter(entry)) {\n              stream.push(entry);\n            }\n            if (index === filepaths.length - 1) {\n              stream.end();\n            }\n            done();\n          }).catch(done);\n        };\n        for (let i = 0; i < filepaths.length; i++) {\n          stream.write(i);\n        }\n        return stream;\n      }\n      _getEntry(filepath, pattern, options8) {\n        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {\n          if (options8.errorFilter(error)) {\n            return null;\n          }\n          throw error;\n        });\n      }\n      _getStat(filepath) {\n        return new Promise((resolve3, reject) => {\n          this._stat(filepath, this._fsStatSettings, (error, stats) => {\n            return error === null ? resolve3(stats) : reject(error);\n          });\n        });\n      }\n    };\n    exports.default = ReaderStream;\n  }\n});\n\n// node_modules/fast-glob/out/readers/async.js\nvar require_async5 = __commonJS({\n  \"node_modules/fast-glob/out/readers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var stream_1 = require_stream3();\n    var ReaderAsync = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkAsync = fsWalk.walk;\n        this._readerStream = new stream_1.default(this._settings);\n      }\n      dynamic(root2, options8) {\n        return new Promise((resolve3, reject) => {\n          this._walkAsync(root2, options8, (error, entries) => {\n            if (error === null) {\n              resolve3(entries);\n            } else {\n              reject(error);\n            }\n          });\n        });\n      }\n      async static(patterns, options8) {\n        const entries = [];\n        const stream = this._readerStream.static(patterns, options8);\n        return new Promise((resolve3, reject) => {\n          stream.once(\"error\", reject);\n          stream.on(\"data\", (entry) => entries.push(entry));\n          stream.once(\"end\", () => resolve3(entries));\n        });\n      }\n    };\n    exports.default = ReaderAsync;\n  }\n});\n\n// node_modules/fast-glob/out/providers/matchers/matcher.js\nvar require_matcher = __commonJS({\n  \"node_modules/fast-glob/out/providers/matchers/matcher.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var utils = require_utils3();\n    var Matcher = class {\n      constructor(_patterns, _settings, _micromatchOptions) {\n        this._patterns = _patterns;\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this._storage = [];\n        this._fillStorage();\n      }\n      _fillStorage() {\n        for (const pattern of this._patterns) {\n          const segments = this._getPatternSegments(pattern);\n          const sections = this._splitSegmentsIntoSections(segments);\n          this._storage.push({\n            complete: sections.length <= 1,\n            pattern,\n            segments,\n            sections\n          });\n        }\n      }\n      _getPatternSegments(pattern) {\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n        return parts.map((part) => {\n          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n          if (!dynamic) {\n            return {\n              dynamic: false,\n              pattern: part\n            };\n          }\n          return {\n            dynamic: true,\n            pattern: part,\n            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n          };\n        });\n      }\n      _splitSegmentsIntoSections(segments) {\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n      }\n    };\n    exports.default = Matcher;\n  }\n});\n\n// node_modules/fast-glob/out/providers/matchers/partial.js\nvar require_partial = __commonJS({\n  \"node_modules/fast-glob/out/providers/matchers/partial.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var matcher_1 = require_matcher();\n    var PartialMatcher = class extends matcher_1.default {\n      match(filepath) {\n        const parts = filepath.split(\"/\");\n        const levels = parts.length;\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\n        for (const pattern of patterns) {\n          const section = pattern.sections[0];\n          if (!pattern.complete && levels > section.length) {\n            return true;\n          }\n          const match = parts.every((part, index) => {\n            const segment = pattern.segments[index];\n            if (segment.dynamic && segment.patternRe.test(part)) {\n              return true;\n            }\n            if (!segment.dynamic && segment.pattern === part) {\n              return true;\n            }\n            return false;\n          });\n          if (match) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    exports.default = PartialMatcher;\n  }\n});\n\n// node_modules/fast-glob/out/providers/filters/deep.js\nvar require_deep = __commonJS({\n  \"node_modules/fast-glob/out/providers/filters/deep.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var utils = require_utils3();\n    var partial_1 = require_partial();\n    var DeepFilter = class {\n      constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n      }\n      getFilter(basePath, positive, negative) {\n        const matcher = this._getMatcher(positive);\n        const negativeRe = this._getNegativePatternsRe(negative);\n        return (entry) => this._filter(basePath, entry, matcher, negativeRe);\n      }\n      _getMatcher(patterns) {\n        return new partial_1.default(patterns, this._settings, this._micromatchOptions);\n      }\n      _getNegativePatternsRe(patterns) {\n        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\n        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\n      }\n      _filter(basePath, entry, matcher, negativeRe) {\n        if (this._isSkippedByDeep(basePath, entry.path)) {\n          return false;\n        }\n        if (this._isSkippedSymbolicLink(entry)) {\n          return false;\n        }\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\n        if (this._isSkippedByPositivePatterns(filepath, matcher)) {\n          return false;\n        }\n        return this._isSkippedByNegativePatterns(filepath, negativeRe);\n      }\n      _isSkippedByDeep(basePath, entryPath) {\n        if (this._settings.deep === Infinity) {\n          return false;\n        }\n        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\n      }\n      _getEntryLevel(basePath, entryPath) {\n        const entryPathDepth = entryPath.split(\"/\").length;\n        if (basePath === \"\") {\n          return entryPathDepth;\n        }\n        const basePathDepth = basePath.split(\"/\").length;\n        return entryPathDepth - basePathDepth;\n      }\n      _isSkippedSymbolicLink(entry) {\n        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\n      }\n      _isSkippedByPositivePatterns(entryPath, matcher) {\n        return !this._settings.baseNameMatch && !matcher.match(entryPath);\n      }\n      _isSkippedByNegativePatterns(entryPath, patternsRe) {\n        return !utils.pattern.matchAny(entryPath, patternsRe);\n      }\n    };\n    exports.default = DeepFilter;\n  }\n});\n\n// node_modules/fast-glob/out/providers/filters/entry.js\nvar require_entry = __commonJS({\n  \"node_modules/fast-glob/out/providers/filters/entry.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var utils = require_utils3();\n    var EntryFilter = class {\n      constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this.index = /* @__PURE__ */ new Map();\n      }\n      getFilter(positive, negative) {\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\n      }\n      _filter(entry, positiveRe, negativeRe) {\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\n        if (this._settings.unique && this._isDuplicateEntry(filepath)) {\n          return false;\n        }\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n          return false;\n        }\n        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {\n          return false;\n        }\n        const isDirectory2 = entry.dirent.isDirectory();\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);\n        if (this._settings.unique && isMatched) {\n          this._createIndexRecord(filepath);\n        }\n        return isMatched;\n      }\n      _isDuplicateEntry(filepath) {\n        return this.index.has(filepath);\n      }\n      _createIndexRecord(filepath) {\n        this.index.set(filepath, void 0);\n      }\n      _onlyFileFilter(entry) {\n        return this._settings.onlyFiles && !entry.dirent.isFile();\n      }\n      _onlyDirectoryFilter(entry) {\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n      }\n      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n        if (!this._settings.absolute) {\n          return false;\n        }\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n        return utils.pattern.matchAny(fullpath, patternsRe);\n      }\n      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n        if (!isMatched && isDirectory2) {\n          return utils.pattern.matchAny(filepath + \"/\", patternsRe);\n        }\n        return isMatched;\n      }\n    };\n    exports.default = EntryFilter;\n  }\n});\n\n// node_modules/fast-glob/out/providers/filters/error.js\nvar require_error = __commonJS({\n  \"node_modules/fast-glob/out/providers/filters/error.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var utils = require_utils3();\n    var ErrorFilter = class {\n      constructor(_settings) {\n        this._settings = _settings;\n      }\n      getFilter() {\n        return (error) => this._isNonFatalError(error);\n      }\n      _isNonFatalError(error) {\n        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\n      }\n    };\n    exports.default = ErrorFilter;\n  }\n});\n\n// node_modules/fast-glob/out/providers/transformers/entry.js\nvar require_entry2 = __commonJS({\n  \"node_modules/fast-glob/out/providers/transformers/entry.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var utils = require_utils3();\n    var EntryTransformer = class {\n      constructor(_settings) {\n        this._settings = _settings;\n      }\n      getTransformer() {\n        return (entry) => this._transform(entry);\n      }\n      _transform(entry) {\n        let filepath = entry.path;\n        if (this._settings.absolute) {\n          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\n          filepath = utils.path.unixify(filepath);\n        }\n        if (this._settings.markDirectories && entry.dirent.isDirectory()) {\n          filepath += \"/\";\n        }\n        if (!this._settings.objectMode) {\n          return filepath;\n        }\n        return Object.assign(Object.assign({}, entry), { path: filepath });\n      }\n    };\n    exports.default = EntryTransformer;\n  }\n});\n\n// node_modules/fast-glob/out/providers/provider.js\nvar require_provider = __commonJS({\n  \"node_modules/fast-glob/out/providers/provider.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var path13 = __require(\"path\");\n    var deep_1 = require_deep();\n    var entry_1 = require_entry();\n    var error_1 = require_error();\n    var entry_2 = require_entry2();\n    var Provider = class {\n      constructor(_settings) {\n        this._settings = _settings;\n        this.errorFilter = new error_1.default(this._settings);\n        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\n        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\n        this.entryTransformer = new entry_2.default(this._settings);\n      }\n      _getRootDirectory(task) {\n        return path13.resolve(this._settings.cwd, task.base);\n      }\n      _getReaderOptions(task) {\n        const basePath = task.base === \".\" ? \"\" : task.base;\n        return {\n          basePath,\n          pathSegmentSeparator: \"/\",\n          concurrency: this._settings.concurrency,\n          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\n          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\n          errorFilter: this.errorFilter.getFilter(),\n          followSymbolicLinks: this._settings.followSymbolicLinks,\n          fs: this._settings.fs,\n          stats: this._settings.stats,\n          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\n          transform: this.entryTransformer.getTransformer()\n        };\n      }\n      _getMicromatchOptions() {\n        return {\n          dot: this._settings.dot,\n          matchBase: this._settings.baseNameMatch,\n          nobrace: !this._settings.braceExpansion,\n          nocase: !this._settings.caseSensitiveMatch,\n          noext: !this._settings.extglob,\n          noglobstar: !this._settings.globstar,\n          posix: true,\n          strictSlashes: false\n        };\n      }\n    };\n    exports.default = Provider;\n  }\n});\n\n// node_modules/fast-glob/out/providers/async.js\nvar require_async6 = __commonJS({\n  \"node_modules/fast-glob/out/providers/async.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var async_1 = require_async5();\n    var provider_1 = require_provider();\n    var ProviderAsync = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new async_1.default(this._settings);\n      }\n      async read(task) {\n        const root2 = this._getRootDirectory(task);\n        const options8 = this._getReaderOptions(task);\n        const entries = await this.api(root2, task, options8);\n        return entries.map((entry) => options8.transform(entry));\n      }\n      api(root2, task, options8) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root2, options8);\n        }\n        return this._reader.static(task.patterns, options8);\n      }\n    };\n    exports.default = ProviderAsync;\n  }\n});\n\n// node_modules/fast-glob/out/providers/stream.js\nvar require_stream4 = __commonJS({\n  \"node_modules/fast-glob/out/providers/stream.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var stream_1 = __require(\"stream\");\n    var stream_2 = require_stream3();\n    var provider_1 = require_provider();\n    var ProviderStream = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new stream_2.default(this._settings);\n      }\n      read(task) {\n        const root2 = this._getRootDirectory(task);\n        const options8 = this._getReaderOptions(task);\n        const source2 = this.api(root2, task, options8);\n        const destination = new stream_1.Readable({ objectMode: true, read: () => {\n        } });\n        source2.once(\"error\", (error) => destination.emit(\"error\", error)).on(\"data\", (entry) => destination.emit(\"data\", options8.transform(entry))).once(\"end\", () => destination.emit(\"end\"));\n        destination.once(\"close\", () => source2.destroy());\n        return destination;\n      }\n      api(root2, task, options8) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root2, options8);\n        }\n        return this._reader.static(task.patterns, options8);\n      }\n    };\n    exports.default = ProviderStream;\n  }\n});\n\n// node_modules/fast-glob/out/readers/sync.js\nvar require_sync5 = __commonJS({\n  \"node_modules/fast-glob/out/readers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fsStat = require_out();\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var ReaderSync = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkSync = fsWalk.walkSync;\n        this._statSync = fsStat.statSync;\n      }\n      dynamic(root2, options8) {\n        return this._walkSync(root2, options8);\n      }\n      static(patterns, options8) {\n        const entries = [];\n        for (const pattern of patterns) {\n          const filepath = this._getFullEntryPath(pattern);\n          const entry = this._getEntry(filepath, pattern, options8);\n          if (entry === null || !options8.entryFilter(entry)) {\n            continue;\n          }\n          entries.push(entry);\n        }\n        return entries;\n      }\n      _getEntry(filepath, pattern, options8) {\n        try {\n          const stats = this._getStat(filepath);\n          return this._makeEntry(stats, pattern);\n        } catch (error) {\n          if (options8.errorFilter(error)) {\n            return null;\n          }\n          throw error;\n        }\n      }\n      _getStat(filepath) {\n        return this._statSync(filepath, this._fsStatSettings);\n      }\n    };\n    exports.default = ReaderSync;\n  }\n});\n\n// node_modules/fast-glob/out/providers/sync.js\nvar require_sync6 = __commonJS({\n  \"node_modules/fast-glob/out/providers/sync.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var sync_1 = require_sync5();\n    var provider_1 = require_provider();\n    var ProviderSync = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new sync_1.default(this._settings);\n      }\n      read(task) {\n        const root2 = this._getRootDirectory(task);\n        const options8 = this._getReaderOptions(task);\n        const entries = this.api(root2, task, options8);\n        return entries.map(options8.transform);\n      }\n      api(root2, task, options8) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root2, options8);\n        }\n        return this._reader.static(task.patterns, options8);\n      }\n    };\n    exports.default = ProviderSync;\n  }\n});\n\n// node_modules/fast-glob/out/settings.js\nvar require_settings4 = __commonJS({\n  \"node_modules/fast-glob/out/settings.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\n    var fs7 = __require(\"fs\");\n    var os2 = __require(\"os\");\n    var CPU_COUNT = Math.max(os2.cpus().length, 1);\n    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {\n      lstat: fs7.lstat,\n      lstatSync: fs7.lstatSync,\n      stat: fs7.stat,\n      statSync: fs7.statSync,\n      readdir: fs7.readdir,\n      readdirSync: fs7.readdirSync\n    };\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.absolute = this._getValue(this._options.absolute, false);\n        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\n        this.braceExpansion = this._getValue(this._options.braceExpansion, true);\n        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\n        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\n        this.cwd = this._getValue(this._options.cwd, process.cwd());\n        this.deep = this._getValue(this._options.deep, Infinity);\n        this.dot = this._getValue(this._options.dot, false);\n        this.extglob = this._getValue(this._options.extglob, true);\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\n        this.fs = this._getFileSystemMethods(this._options.fs);\n        this.globstar = this._getValue(this._options.globstar, true);\n        this.ignore = this._getValue(this._options.ignore, []);\n        this.markDirectories = this._getValue(this._options.markDirectories, false);\n        this.objectMode = this._getValue(this._options.objectMode, false);\n        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\n        this.onlyFiles = this._getValue(this._options.onlyFiles, true);\n        this.stats = this._getValue(this._options.stats, false);\n        this.suppressErrors = this._getValue(this._options.suppressErrors, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\n        this.unique = this._getValue(this._options.unique, true);\n        if (this.onlyDirectories) {\n          this.onlyFiles = false;\n        }\n        if (this.stats) {\n          this.objectMode = true;\n        }\n        this.ignore = [].concat(this.ignore);\n      }\n      _getValue(option, value) {\n        return option === void 0 ? value : option;\n      }\n      _getFileSystemMethods(methods = {}) {\n        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\n      }\n    };\n    exports.default = Settings;\n  }\n});\n\n// node_modules/fast-glob/out/index.js\nvar require_out4 = __commonJS({\n  \"node_modules/fast-glob/out/index.js\"(exports, module) {\n    \"use strict\";\n    var taskManager = require_tasks();\n    var async_1 = require_async6();\n    var stream_1 = require_stream4();\n    var sync_1 = require_sync6();\n    var settings_1 = require_settings4();\n    var utils = require_utils3();\n    async function FastGlob(source2, options8) {\n      assertPatternsInput(source2);\n      const works = getWorks(source2, async_1.default, options8);\n      const result = await Promise.all(works);\n      return utils.array.flatten(result);\n    }\n    (function(FastGlob2) {\n      FastGlob2.glob = FastGlob2;\n      FastGlob2.globSync = sync;\n      FastGlob2.globStream = stream;\n      FastGlob2.async = FastGlob2;\n      function sync(source2, options8) {\n        assertPatternsInput(source2);\n        const works = getWorks(source2, sync_1.default, options8);\n        return utils.array.flatten(works);\n      }\n      FastGlob2.sync = sync;\n      function stream(source2, options8) {\n        assertPatternsInput(source2);\n        const works = getWorks(source2, stream_1.default, options8);\n        return utils.stream.merge(works);\n      }\n      FastGlob2.stream = stream;\n      function generateTasks(source2, options8) {\n        assertPatternsInput(source2);\n        const patterns = [].concat(source2);\n        const settings = new settings_1.default(options8);\n        return taskManager.generate(patterns, settings);\n      }\n      FastGlob2.generateTasks = generateTasks;\n      function isDynamicPattern(source2, options8) {\n        assertPatternsInput(source2);\n        const settings = new settings_1.default(options8);\n        return utils.pattern.isDynamicPattern(source2, settings);\n      }\n      FastGlob2.isDynamicPattern = isDynamicPattern;\n      function escapePath(source2) {\n        assertPatternsInput(source2);\n        return utils.path.escape(source2);\n      }\n      FastGlob2.escapePath = escapePath;\n      function convertPathToPattern(source2) {\n        assertPatternsInput(source2);\n        return utils.path.convertPathToPattern(source2);\n      }\n      FastGlob2.convertPathToPattern = convertPathToPattern;\n      let posix;\n      (function(posix2) {\n        function escapePath2(source2) {\n          assertPatternsInput(source2);\n          return utils.path.escapePosixPath(source2);\n        }\n        posix2.escapePath = escapePath2;\n        function convertPathToPattern2(source2) {\n          assertPatternsInput(source2);\n          return utils.path.convertPosixPathToPattern(source2);\n        }\n        posix2.convertPathToPattern = convertPathToPattern2;\n      })(posix = FastGlob2.posix || (FastGlob2.posix = {}));\n      let win32;\n      (function(win322) {\n        function escapePath2(source2) {\n          assertPatternsInput(source2);\n          return utils.path.escapeWindowsPath(source2);\n        }\n        win322.escapePath = escapePath2;\n        function convertPathToPattern2(source2) {\n          assertPatternsInput(source2);\n          return utils.path.convertWindowsPathToPattern(source2);\n        }\n        win322.convertPathToPattern = convertPathToPattern2;\n      })(win32 = FastGlob2.win32 || (FastGlob2.win32 = {}));\n    })(FastGlob || (FastGlob = {}));\n    function getWorks(source2, _Provider, options8) {\n      const patterns = [].concat(source2);\n      const settings = new settings_1.default(options8);\n      const tasks = taskManager.generate(patterns, settings);\n      const provider = new _Provider(settings);\n      return tasks.map(provider.read, provider);\n    }\n    function assertPatternsInput(input) {\n      const source2 = [].concat(input);\n      const isValidSource = source2.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\n      if (!isValidSource) {\n        throw new TypeError(\"Patterns must be a string (non empty) or an array of strings\");\n      }\n    }\n    module.exports = FastGlob;\n  }\n});\n\n// node_modules/semver/internal/debug.js\nvar require_debug = __commonJS({\n  \"node_modules/semver/internal/debug.js\"(exports, module) {\n    var debug = typeof process === \"object\" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error(\"SEMVER\", ...args) : () => {\n    };\n    module.exports = debug;\n  }\n});\n\n// node_modules/semver/internal/constants.js\nvar require_constants4 = __commonJS({\n  \"node_modules/semver/internal/constants.js\"(exports, module) {\n    var SEMVER_SPEC_VERSION = \"2.0.0\";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */\n    9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;\n    var RELEASE_TYPES = [\n      \"major\",\n      \"premajor\",\n      \"minor\",\n      \"preminor\",\n      \"patch\",\n      \"prepatch\",\n      \"prerelease\"\n    ];\n    module.exports = {\n      MAX_LENGTH,\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_SAFE_INTEGER,\n      RELEASE_TYPES,\n      SEMVER_SPEC_VERSION,\n      FLAG_INCLUDE_PRERELEASE: 1,\n      FLAG_LOOSE: 2\n    };\n  }\n});\n\n// node_modules/semver/internal/re.js\nvar require_re = __commonJS({\n  \"node_modules/semver/internal/re.js\"(exports, module) {\n    var {\n      MAX_SAFE_COMPONENT_LENGTH,\n      MAX_SAFE_BUILD_LENGTH,\n      MAX_LENGTH\n    } = require_constants4();\n    var debug = require_debug();\n    exports = module.exports = {};\n    var re = exports.re = [];\n    var safeRe = exports.safeRe = [];\n    var src = exports.src = [];\n    var t = exports.t = {};\n    var R = 0;\n    var LETTERDASHNUMBER = \"[a-zA-Z0-9-]\";\n    var safeRegexReplacements = [\n      [\"\\\\s\", 1],\n      [\"\\\\d\", MAX_LENGTH],\n      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]\n    ];\n    var makeSafeRegex = (value) => {\n      for (const [token2, max] of safeRegexReplacements) {\n        value = value.split(`${token2}*`).join(`${token2}{0,${max}}`).split(`${token2}+`).join(`${token2}{1,${max}}`);\n      }\n      return value;\n    };\n    var createToken = (name, value, isGlobal) => {\n      const safe = makeSafeRegex(value);\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      re[index] = new RegExp(value, isGlobal ? \"g\" : void 0);\n      safeRe[index] = new RegExp(safe, isGlobal ? \"g\" : void 0);\n    };\n    createToken(\"NUMERICIDENTIFIER\", \"0|[1-9]\\\\d*\");\n    createToken(\"NUMERICIDENTIFIERLOOSE\", \"\\\\d+\");\n    createToken(\"NONNUMERICIDENTIFIER\", `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);\n    createToken(\"MAINVERSION\", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken(\"MAINVERSIONLOOSE\", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken(\"PRERELEASEIDENTIFIER\", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASEIDENTIFIERLOOSE\", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken(\"PRERELEASE\", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken(\"PRERELEASELOOSE\", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken(\"BUILDIDENTIFIER\", `${LETTERDASHNUMBER}+`);\n    createToken(\"BUILD\", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken(\"FULLPLAIN\", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken(\"FULL\", `^${src[t.FULLPLAIN]}$`);\n    createToken(\"LOOSEPLAIN\", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken(\"LOOSE\", `^${src[t.LOOSEPLAIN]}$`);\n    createToken(\"GTLT\", \"((?:<|>)?=?)\");\n    createToken(\"XRANGEIDENTIFIERLOOSE\", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken(\"XRANGEIDENTIFIER\", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken(\"XRANGEPLAIN\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGEPLAINLOOSE\", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken(\"XRANGE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken(\"XRANGELOOSE\", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COERCE\", `${\"(^|[^\\\\d])(\\\\d{1,\"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\\\d])`);\n    createToken(\"COERCERTL\", src[t.COERCE], true);\n    createToken(\"LONETILDE\", \"(?:~>?)\");\n    createToken(\"TILDETRIM\", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports.tildeTrimReplace = \"$1~\";\n    createToken(\"TILDE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"TILDELOOSE\", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"LONECARET\", \"(?:\\\\^)\");\n    createToken(\"CARETTRIM\", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports.caretTrimReplace = \"$1^\";\n    createToken(\"CARET\", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken(\"CARETLOOSE\", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken(\"COMPARATORLOOSE\", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken(\"COMPARATOR\", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken(\"COMPARATORTRIM\", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports.comparatorTrimReplace = \"$1$2$3\";\n    createToken(\"HYPHENRANGE\", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken(\"HYPHENRANGELOOSE\", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken(\"STAR\", \"(<|>)?=?\\\\s*\\\\*\");\n    createToken(\"GTE0\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$\");\n    createToken(\"GTE0PRE\", \"^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$\");\n  }\n});\n\n// node_modules/semver/internal/parse-options.js\nvar require_parse_options = __commonJS({\n  \"node_modules/semver/internal/parse-options.js\"(exports, module) {\n    var looseOption = Object.freeze({ loose: true });\n    var emptyOpts = Object.freeze({});\n    var parseOptions = (options8) => {\n      if (!options8) {\n        return emptyOpts;\n      }\n      if (typeof options8 !== \"object\") {\n        return looseOption;\n      }\n      return options8;\n    };\n    module.exports = parseOptions;\n  }\n});\n\n// node_modules/semver/internal/identifiers.js\nvar require_identifiers = __commonJS({\n  \"node_modules/semver/internal/identifiers.js\"(exports, module) {\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = (a, b) => {\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    };\n    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n    module.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\n\n// node_modules/semver/classes/semver.js\nvar require_semver = __commonJS({\n  \"node_modules/semver/classes/semver.js\"(exports, module) {\n    var debug = require_debug();\n    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants4();\n    var { safeRe: re, t } = require_re();\n    var parseOptions = require_parse_options();\n    var { compareIdentifiers } = require_identifiers();\n    var SemVer = class _SemVer {\n      constructor(version, options8) {\n        options8 = parseOptions(options8);\n        if (version instanceof _SemVer) {\n          if (version.loose === !!options8.loose && version.includePrerelease === !!options8.includePrerelease) {\n            return version;\n          } else {\n            version = version.version;\n          }\n        } else if (typeof version !== \"string\") {\n          throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`);\n        }\n        if (version.length > MAX_LENGTH) {\n          throw new TypeError(\n            `version is longer than ${MAX_LENGTH} characters`\n          );\n        }\n        debug(\"SemVer\", version, options8);\n        this.options = options8;\n        this.loose = !!options8.loose;\n        this.includePrerelease = !!options8.includePrerelease;\n        const m = version.trim().match(options8.loose ? re[t.LOOSE] : re[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version}`);\n        }\n        this.raw = version;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError(\"Invalid major version\");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError(\"Invalid minor version\");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError(\"Invalid patch version\");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(\".\").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(\".\") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(\".\")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug(\"SemVer.compare\", this.version, this.options, other);\n        if (!(other instanceof _SemVer)) {\n          if (typeof other === \"string\" && other === this.version) {\n            return 0;\n          }\n          other = new _SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n      }\n      comparePre(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof _SemVer)) {\n          other = new _SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug(\"prerelease compare\", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      // preminor will bump the version up to the next minor release, and immediately\n      // down to pre-release. premajor and prepatch work the same way.\n      inc(release, identifier, identifierBase) {\n        switch (release) {\n          case \"premajor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"preminor\":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prepatch\":\n            this.prerelease.length = 0;\n            this.inc(\"patch\", identifier, identifierBase);\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"prerelease\":\n            if (this.prerelease.length === 0) {\n              this.inc(\"patch\", identifier, identifierBase);\n            }\n            this.inc(\"pre\", identifier, identifierBase);\n            break;\n          case \"major\":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"minor\":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case \"patch\":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          case \"pre\": {\n            const base = Number(identifierBase) ? 1 : 0;\n            if (!identifier && identifierBase === false) {\n              throw new Error(\"invalid increment argument: identifier is empty\");\n            }\n            if (this.prerelease.length === 0) {\n              this.prerelease = [base];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === \"number\") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                if (identifier === this.prerelease.join(\".\") && identifierBase === false) {\n                  throw new Error(\"invalid increment argument: identifier already exists\");\n                }\n                this.prerelease.push(base);\n              }\n            }\n            if (identifier) {\n              let prerelease = [identifier, base];\n              if (identifierBase === false) {\n                prerelease = [identifier];\n              }\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = prerelease;\n                }\n              } else {\n                this.prerelease = prerelease;\n              }\n            }\n            break;\n          }\n          default:\n            throw new Error(`invalid increment argument: ${release}`);\n        }\n        this.raw = this.format();\n        if (this.build.length) {\n          this.raw += `+${this.build.join(\".\")}`;\n        }\n        return this;\n      }\n    };\n    module.exports = SemVer;\n  }\n});\n\n// node_modules/semver/functions/compare.js\nvar require_compare = __commonJS({\n  \"node_modules/semver/functions/compare.js\"(exports, module) {\n    var SemVer = require_semver();\n    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n    module.exports = compare;\n  }\n});\n\n// node_modules/semver/functions/gte.js\nvar require_gte = __commonJS({\n  \"node_modules/semver/functions/gte.js\"(exports, module) {\n    var compare = require_compare();\n    var gte = (a, b, loose) => compare(a, b, loose) >= 0;\n    module.exports = gte;\n  }\n});\n\n// node_modules/pseudomap/pseudomap.js\nvar require_pseudomap = __commonJS({\n  \"node_modules/pseudomap/pseudomap.js\"(exports, module) {\n    var hasOwnProperty3 = Object.prototype.hasOwnProperty;\n    module.exports = PseudoMap;\n    function PseudoMap(set3) {\n      if (!(this instanceof PseudoMap))\n        throw new TypeError(\"Constructor PseudoMap requires 'new'\");\n      this.clear();\n      if (set3) {\n        if (set3 instanceof PseudoMap || typeof Map === \"function\" && set3 instanceof Map)\n          set3.forEach(function(value, key2) {\n            this.set(key2, value);\n          }, this);\n        else if (Array.isArray(set3))\n          set3.forEach(function(kv) {\n            this.set(kv[0], kv[1]);\n          }, this);\n        else\n          throw new TypeError(\"invalid argument\");\n      }\n    }\n    PseudoMap.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      Object.keys(this._data).forEach(function(k) {\n        if (k !== \"size\")\n          fn.call(thisp, this._data[k].value, this._data[k].key);\n      }, this);\n    };\n    PseudoMap.prototype.has = function(k) {\n      return !!find(this._data, k);\n    };\n    PseudoMap.prototype.get = function(k) {\n      var res = find(this._data, k);\n      return res && res.value;\n    };\n    PseudoMap.prototype.set = function(k, v) {\n      set2(this._data, k, v);\n    };\n    PseudoMap.prototype.delete = function(k) {\n      var res = find(this._data, k);\n      if (res) {\n        delete this._data[res._index];\n        this._data.size--;\n      }\n    };\n    PseudoMap.prototype.clear = function() {\n      var data = /* @__PURE__ */ Object.create(null);\n      data.size = 0;\n      Object.defineProperty(this, \"_data\", {\n        value: data,\n        enumerable: false,\n        configurable: true,\n        writable: false\n      });\n    };\n    Object.defineProperty(PseudoMap.prototype, \"size\", {\n      get: function() {\n        return this._data.size;\n      },\n      set: function(n) {\n      },\n      enumerable: true,\n      configurable: true\n    });\n    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {\n      throw new Error(\"iterators are not implemented in this version\");\n    };\n    function same(a, b) {\n      return a === b || a !== a && b !== b;\n    }\n    function Entry(k, v, i) {\n      this.key = k;\n      this.value = v;\n      this._index = i;\n    }\n    function find(data, k) {\n      for (var i = 0, s = \"_\" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i++) {\n        if (same(data[key2].key, k))\n          return data[key2];\n      }\n    }\n    function set2(data, k, v) {\n      for (var i = 0, s = \"_\" + k, key2 = s; hasOwnProperty3.call(data, key2); key2 = s + i++) {\n        if (same(data[key2].key, k)) {\n          data[key2].value = v;\n          return;\n        }\n      }\n      data.size++;\n      data[key2] = new Entry(k, v, key2);\n    }\n  }\n});\n\n// node_modules/pseudomap/map.js\nvar require_map = __commonJS({\n  \"node_modules/pseudomap/map.js\"(exports, module) {\n    if (process.env.npm_package_name === \"pseudomap\" && process.env.npm_lifecycle_script === \"test\")\n      process.env.TEST_PSEUDOMAP = \"true\";\n    if (typeof Map === \"function\" && !process.env.TEST_PSEUDOMAP) {\n      module.exports = Map;\n    } else {\n      module.exports = require_pseudomap();\n    }\n  }\n});\n\n// node_modules/editorconfig/node_modules/yallist/yallist.js\nvar require_yallist = __commonJS({\n  \"node_modules/editorconfig/node_modules/yallist/yallist.js\"(exports, module) {\n    module.exports = Yallist;\n    Yallist.Node = Node;\n    Yallist.create = Yallist;\n    function Yallist(list) {\n      var self = this;\n      if (!(self instanceof Yallist)) {\n        self = new Yallist();\n      }\n      self.tail = null;\n      self.head = null;\n      self.length = 0;\n      if (list && typeof list.forEach === \"function\") {\n        list.forEach(function(item) {\n          self.push(item);\n        });\n      } else if (arguments.length > 0) {\n        for (var i = 0, l = arguments.length; i < l; i++) {\n          self.push(arguments[i]);\n        }\n      }\n      return self;\n    }\n    Yallist.prototype.removeNode = function(node) {\n      if (node.list !== this) {\n        throw new Error(\"removing node which does not belong to this list\");\n      }\n      var next = node.next;\n      var prev = node.prev;\n      if (next) {\n        next.prev = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      }\n      if (node === this.head) {\n        this.head = next;\n      }\n      if (node === this.tail) {\n        this.tail = prev;\n      }\n      node.list.length--;\n      node.next = null;\n      node.prev = null;\n      node.list = null;\n    };\n    Yallist.prototype.unshiftNode = function(node) {\n      if (node === this.head) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var head = this.head;\n      node.list = this;\n      node.next = head;\n      if (head) {\n        head.prev = node;\n      }\n      this.head = node;\n      if (!this.tail) {\n        this.tail = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.pushNode = function(node) {\n      if (node === this.tail) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var tail = this.tail;\n      node.list = this;\n      node.prev = tail;\n      if (tail) {\n        tail.next = node;\n      }\n      this.tail = node;\n      if (!this.head) {\n        this.head = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.push = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        push2(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.unshift = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        unshift(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.pop = function() {\n      if (!this.tail) {\n        return void 0;\n      }\n      var res = this.tail.value;\n      this.tail = this.tail.prev;\n      if (this.tail) {\n        this.tail.next = null;\n      } else {\n        this.head = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.shift = function() {\n      if (!this.head) {\n        return void 0;\n      }\n      var res = this.head.value;\n      this.head = this.head.next;\n      if (this.head) {\n        this.head.prev = null;\n      } else {\n        this.tail = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.head, i = 0; walker !== null; i++) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.next;\n      }\n    };\n    Yallist.prototype.forEachReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.prev;\n      }\n    };\n    Yallist.prototype.get = function(n) {\n      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n        walker = walker.next;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.getReverse = function(n) {\n      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n        walker = walker.prev;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.map = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.head; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.next;\n      }\n      return res;\n    };\n    Yallist.prototype.mapReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.tail; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.prev;\n      }\n      return res;\n    };\n    Yallist.prototype.reduce = function(fn, initial) {\n      var acc;\n      var walker = this.head;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.head) {\n        walker = this.head.next;\n        acc = this.head.value;\n      } else {\n        throw new TypeError(\"Reduce of empty list with no initial value\");\n      }\n      for (var i = 0; walker !== null; i++) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.next;\n      }\n      return acc;\n    };\n    Yallist.prototype.reduceReverse = function(fn, initial) {\n      var acc;\n      var walker = this.tail;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.tail) {\n        walker = this.tail.prev;\n        acc = this.tail.value;\n      } else {\n        throw new TypeError(\"Reduce of empty list with no initial value\");\n      }\n      for (var i = this.length - 1; walker !== null; i--) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.prev;\n      }\n      return acc;\n    };\n    Yallist.prototype.toArray = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.head; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.next;\n      }\n      return arr;\n    };\n    Yallist.prototype.toArrayReverse = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.tail; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.prev;\n      }\n      return arr;\n    };\n    Yallist.prototype.slice = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n        walker = walker.next;\n      }\n      for (; walker !== null && i < to; i++, walker = walker.next) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.sliceReverse = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n        walker = walker.prev;\n      }\n      for (; walker !== null && i > from; i--, walker = walker.prev) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.reverse = function() {\n      var head = this.head;\n      var tail = this.tail;\n      for (var walker = head; walker !== null; walker = walker.prev) {\n        var p = walker.prev;\n        walker.prev = walker.next;\n        walker.next = p;\n      }\n      this.head = tail;\n      this.tail = head;\n      return this;\n    };\n    function push2(self, item) {\n      self.tail = new Node(item, self.tail, null, self);\n      if (!self.head) {\n        self.head = self.tail;\n      }\n      self.length++;\n    }\n    function unshift(self, item) {\n      self.head = new Node(item, null, self.head, self);\n      if (!self.tail) {\n        self.tail = self.head;\n      }\n      self.length++;\n    }\n    function Node(value, prev, next, list) {\n      if (!(this instanceof Node)) {\n        return new Node(value, prev, next, list);\n      }\n      this.list = list;\n      this.value = value;\n      if (prev) {\n        prev.next = this;\n        this.prev = prev;\n      } else {\n        this.prev = null;\n      }\n      if (next) {\n        next.prev = this;\n        this.next = next;\n      } else {\n        this.next = null;\n      }\n    }\n  }\n});\n\n// node_modules/editorconfig/node_modules/lru-cache/index.js\nvar require_lru_cache = __commonJS({\n  \"node_modules/editorconfig/node_modules/lru-cache/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = LRUCache;\n    var Map2 = require_map();\n    var util2 = __require(\"util\");\n    var Yallist = require_yallist();\n    var hasSymbol = typeof Symbol === \"function\" && process.env._nodeLRUCacheForceNoSymbol !== \"1\";\n    var makeSymbol;\n    if (hasSymbol) {\n      makeSymbol = function(key2) {\n        return Symbol(key2);\n      };\n    } else {\n      makeSymbol = function(key2) {\n        return \"_\" + key2;\n      };\n    }\n    var MAX = makeSymbol(\"max\");\n    var LENGTH = makeSymbol(\"length\");\n    var LENGTH_CALCULATOR = makeSymbol(\"lengthCalculator\");\n    var ALLOW_STALE = makeSymbol(\"allowStale\");\n    var MAX_AGE = makeSymbol(\"maxAge\");\n    var DISPOSE = makeSymbol(\"dispose\");\n    var NO_DISPOSE_ON_SET = makeSymbol(\"noDisposeOnSet\");\n    var LRU_LIST = makeSymbol(\"lruList\");\n    var CACHE = makeSymbol(\"cache\");\n    function naiveLength() {\n      return 1;\n    }\n    function LRUCache(options8) {\n      if (!(this instanceof LRUCache)) {\n        return new LRUCache(options8);\n      }\n      if (typeof options8 === \"number\") {\n        options8 = { max: options8 };\n      }\n      if (!options8) {\n        options8 = {};\n      }\n      var max = this[MAX] = options8.max;\n      if (!max || !(typeof max === \"number\") || max <= 0) {\n        this[MAX] = Infinity;\n      }\n      var lc = options8.length || naiveLength;\n      if (typeof lc !== \"function\") {\n        lc = naiveLength;\n      }\n      this[LENGTH_CALCULATOR] = lc;\n      this[ALLOW_STALE] = options8.stale || false;\n      this[MAX_AGE] = options8.maxAge || 0;\n      this[DISPOSE] = options8.dispose;\n      this[NO_DISPOSE_ON_SET] = options8.noDisposeOnSet || false;\n      this.reset();\n    }\n    Object.defineProperty(LRUCache.prototype, \"max\", {\n      set: function(mL) {\n        if (!mL || !(typeof mL === \"number\") || mL <= 0) {\n          mL = Infinity;\n        }\n        this[MAX] = mL;\n        trim2(this);\n      },\n      get: function() {\n        return this[MAX];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"allowStale\", {\n      set: function(allowStale) {\n        this[ALLOW_STALE] = !!allowStale;\n      },\n      get: function() {\n        return this[ALLOW_STALE];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"maxAge\", {\n      set: function(mA) {\n        if (!mA || !(typeof mA === \"number\") || mA < 0) {\n          mA = 0;\n        }\n        this[MAX_AGE] = mA;\n        trim2(this);\n      },\n      get: function() {\n        return this[MAX_AGE];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"lengthCalculator\", {\n      set: function(lC) {\n        if (typeof lC !== \"function\") {\n          lC = naiveLength;\n        }\n        if (lC !== this[LENGTH_CALCULATOR]) {\n          this[LENGTH_CALCULATOR] = lC;\n          this[LENGTH] = 0;\n          this[LRU_LIST].forEach(function(hit) {\n            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n            this[LENGTH] += hit.length;\n          }, this);\n        }\n        trim2(this);\n      },\n      get: function() {\n        return this[LENGTH_CALCULATOR];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"length\", {\n      get: function() {\n        return this[LENGTH];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, \"itemCount\", {\n      get: function() {\n        return this[LRU_LIST].length;\n      },\n      enumerable: true\n    });\n    LRUCache.prototype.rforEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this[LRU_LIST].tail; walker !== null; ) {\n        var prev = walker.prev;\n        forEachStep(this, fn, walker, thisp);\n        walker = prev;\n      }\n    };\n    function forEachStep(self, fn, node, thisp) {\n      var hit = node.value;\n      if (isStale(self, hit)) {\n        del(self, node);\n        if (!self[ALLOW_STALE]) {\n          hit = void 0;\n        }\n      }\n      if (hit) {\n        fn.call(thisp, hit.value, hit.key, self);\n      }\n    }\n    LRUCache.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this[LRU_LIST].head; walker !== null; ) {\n        var next = walker.next;\n        forEachStep(this, fn, walker, thisp);\n        walker = next;\n      }\n    };\n    LRUCache.prototype.keys = function() {\n      return this[LRU_LIST].toArray().map(function(k) {\n        return k.key;\n      }, this);\n    };\n    LRUCache.prototype.values = function() {\n      return this[LRU_LIST].toArray().map(function(k) {\n        return k.value;\n      }, this);\n    };\n    LRUCache.prototype.reset = function() {\n      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n        this[LRU_LIST].forEach(function(hit) {\n          this[DISPOSE](hit.key, hit.value);\n        }, this);\n      }\n      this[CACHE] = new Map2();\n      this[LRU_LIST] = new Yallist();\n      this[LENGTH] = 0;\n    };\n    LRUCache.prototype.dump = function() {\n      return this[LRU_LIST].map(function(hit) {\n        if (!isStale(this, hit)) {\n          return {\n            k: hit.key,\n            v: hit.value,\n            e: hit.now + (hit.maxAge || 0)\n          };\n        }\n      }, this).toArray().filter(function(h) {\n        return h;\n      });\n    };\n    LRUCache.prototype.dumpLru = function() {\n      return this[LRU_LIST];\n    };\n    LRUCache.prototype.inspect = function(n, opts) {\n      var str2 = \"LRUCache {\";\n      var extras = false;\n      var as = this[ALLOW_STALE];\n      if (as) {\n        str2 += \"\\n  allowStale: true\";\n        extras = true;\n      }\n      var max = this[MAX];\n      if (max && max !== Infinity) {\n        if (extras) {\n          str2 += \",\";\n        }\n        str2 += \"\\n  max: \" + util2.inspect(max, opts);\n        extras = true;\n      }\n      var maxAge = this[MAX_AGE];\n      if (maxAge) {\n        if (extras) {\n          str2 += \",\";\n        }\n        str2 += \"\\n  maxAge: \" + util2.inspect(maxAge, opts);\n        extras = true;\n      }\n      var lc = this[LENGTH_CALCULATOR];\n      if (lc && lc !== naiveLength) {\n        if (extras) {\n          str2 += \",\";\n        }\n        str2 += \"\\n  length: \" + util2.inspect(this[LENGTH], opts);\n        extras = true;\n      }\n      var didFirst = false;\n      this[LRU_LIST].forEach(function(item) {\n        if (didFirst) {\n          str2 += \",\\n  \";\n        } else {\n          if (extras) {\n            str2 += \",\\n\";\n          }\n          didFirst = true;\n          str2 += \"\\n  \";\n        }\n        var key2 = util2.inspect(item.key).split(\"\\n\").join(\"\\n  \");\n        var val = { value: item.value };\n        if (item.maxAge !== maxAge) {\n          val.maxAge = item.maxAge;\n        }\n        if (lc !== naiveLength) {\n          val.length = item.length;\n        }\n        if (isStale(this, item)) {\n          val.stale = true;\n        }\n        val = util2.inspect(val, opts).split(\"\\n\").join(\"\\n  \");\n        str2 += key2 + \" => \" + val;\n      });\n      if (didFirst || extras) {\n        str2 += \"\\n\";\n      }\n      str2 += \"}\";\n      return str2;\n    };\n    LRUCache.prototype.set = function(key2, value, maxAge) {\n      maxAge = maxAge || this[MAX_AGE];\n      var now = maxAge ? Date.now() : 0;\n      var len = this[LENGTH_CALCULATOR](value, key2);\n      if (this[CACHE].has(key2)) {\n        if (len > this[MAX]) {\n          del(this, this[CACHE].get(key2));\n          return false;\n        }\n        var node = this[CACHE].get(key2);\n        var item = node.value;\n        if (this[DISPOSE]) {\n          if (!this[NO_DISPOSE_ON_SET]) {\n            this[DISPOSE](key2, item.value);\n          }\n        }\n        item.now = now;\n        item.maxAge = maxAge;\n        item.value = value;\n        this[LENGTH] += len - item.length;\n        item.length = len;\n        this.get(key2);\n        trim2(this);\n        return true;\n      }\n      var hit = new Entry(key2, value, len, now, maxAge);\n      if (hit.length > this[MAX]) {\n        if (this[DISPOSE]) {\n          this[DISPOSE](key2, value);\n        }\n        return false;\n      }\n      this[LENGTH] += hit.length;\n      this[LRU_LIST].unshift(hit);\n      this[CACHE].set(key2, this[LRU_LIST].head);\n      trim2(this);\n      return true;\n    };\n    LRUCache.prototype.has = function(key2) {\n      if (!this[CACHE].has(key2))\n        return false;\n      var hit = this[CACHE].get(key2).value;\n      if (isStale(this, hit)) {\n        return false;\n      }\n      return true;\n    };\n    LRUCache.prototype.get = function(key2) {\n      return get(this, key2, true);\n    };\n    LRUCache.prototype.peek = function(key2) {\n      return get(this, key2, false);\n    };\n    LRUCache.prototype.pop = function() {\n      var node = this[LRU_LIST].tail;\n      if (!node)\n        return null;\n      del(this, node);\n      return node.value;\n    };\n    LRUCache.prototype.del = function(key2) {\n      del(this, this[CACHE].get(key2));\n    };\n    LRUCache.prototype.load = function(arr) {\n      this.reset();\n      var now = Date.now();\n      for (var l = arr.length - 1; l >= 0; l--) {\n        var hit = arr[l];\n        var expiresAt = hit.e || 0;\n        if (expiresAt === 0) {\n          this.set(hit.k, hit.v);\n        } else {\n          var maxAge = expiresAt - now;\n          if (maxAge > 0) {\n            this.set(hit.k, hit.v, maxAge);\n          }\n        }\n      }\n    };\n    LRUCache.prototype.prune = function() {\n      var self = this;\n      this[CACHE].forEach(function(value, key2) {\n        get(self, key2, false);\n      });\n    };\n    function get(self, key2, doUse) {\n      var node = self[CACHE].get(key2);\n      if (node) {\n        var hit = node.value;\n        if (isStale(self, hit)) {\n          del(self, node);\n          if (!self[ALLOW_STALE])\n            hit = void 0;\n        } else {\n          if (doUse) {\n            self[LRU_LIST].unshiftNode(node);\n          }\n        }\n        if (hit)\n          hit = hit.value;\n      }\n      return hit;\n    }\n    function isStale(self, hit) {\n      if (!hit || !hit.maxAge && !self[MAX_AGE]) {\n        return false;\n      }\n      var stale = false;\n      var diff = Date.now() - hit.now;\n      if (hit.maxAge) {\n        stale = diff > hit.maxAge;\n      } else {\n        stale = self[MAX_AGE] && diff > self[MAX_AGE];\n      }\n      return stale;\n    }\n    function trim2(self) {\n      if (self[LENGTH] > self[MAX]) {\n        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {\n          var prev = walker.prev;\n          del(self, walker);\n          walker = prev;\n        }\n      }\n    }\n    function del(self, node) {\n      if (node) {\n        var hit = node.value;\n        if (self[DISPOSE]) {\n          self[DISPOSE](hit.key, hit.value);\n        }\n        self[LENGTH] -= hit.length;\n        self[CACHE].delete(hit.key);\n        self[LRU_LIST].removeNode(node);\n      }\n    }\n    function Entry(key2, value, length, now, maxAge) {\n      this.key = key2;\n      this.value = value;\n      this.length = length;\n      this.now = now;\n      this.maxAge = maxAge || 0;\n    }\n  }\n});\n\n// node_modules/sigmund/sigmund.js\nvar require_sigmund = __commonJS({\n  \"node_modules/sigmund/sigmund.js\"(exports, module) {\n    module.exports = sigmund;\n    function sigmund(subject, maxSessions) {\n      maxSessions = maxSessions || 10;\n      var notes = [];\n      var analysis = \"\";\n      var RE = RegExp;\n      function psychoAnalyze(subject2, session) {\n        if (session > maxSessions)\n          return;\n        if (typeof subject2 === \"function\" || typeof subject2 === \"undefined\") {\n          return;\n        }\n        if (typeof subject2 !== \"object\" || !subject2 || subject2 instanceof RE) {\n          analysis += subject2;\n          return;\n        }\n        if (notes.indexOf(subject2) !== -1 || session === maxSessions)\n          return;\n        notes.push(subject2);\n        analysis += \"{\";\n        Object.keys(subject2).forEach(function(issue, _, __) {\n          if (issue.charAt(0) === \"_\")\n            return;\n          var to = typeof subject2[issue];\n          if (to === \"function\" || to === \"undefined\")\n            return;\n          analysis += issue;\n          psychoAnalyze(subject2[issue], session + 1);\n        });\n      }\n      psychoAnalyze(subject, 0);\n      return analysis;\n    }\n  }\n});\n\n// node_modules/editorconfig/src/lib/fnmatch.js\nvar require_fnmatch = __commonJS({\n  \"node_modules/editorconfig/src/lib/fnmatch.js\"(exports, module) {\n    var platform = typeof process === \"object\" ? process.platform : \"win32\";\n    if (module)\n      module.exports = minimatch;\n    else\n      exports.minimatch = minimatch;\n    minimatch.Minimatch = Minimatch;\n    var LRU = require_lru_cache();\n    var cache3 = minimatch.cache = new LRU({ max: 100 });\n    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n    var sigmund = require_sigmund();\n    var path13 = __require(\"path\");\n    var qmark = \"[^/]\";\n    var star = qmark + \"*?\";\n    var twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n    var twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n    var reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n    function charSet(s) {\n      return s.split(\"\").reduce(function(set2, c2) {\n        set2[c2] = true;\n        return set2;\n      }, {});\n    }\n    var slashSplit = /\\/+/;\n    minimatch.monkeyPatch = monkeyPatch;\n    function monkeyPatch() {\n      var desc = Object.getOwnPropertyDescriptor(String.prototype, \"match\");\n      var orig = desc.value;\n      desc.value = function(p) {\n        if (p instanceof Minimatch)\n          return p.match(this);\n        return orig.call(this, p);\n      };\n      Object.defineProperty(String.prototype, desc);\n    }\n    minimatch.filter = filter2;\n    function filter2(pattern, options8) {\n      options8 = options8 || {};\n      return function(p, i, list) {\n        return minimatch(p, pattern, options8);\n      };\n    }\n    function ext(a, b) {\n      a = a || {};\n      b = b || {};\n      var t = {};\n      Object.keys(b).forEach(function(k) {\n        t[k] = b[k];\n      });\n      Object.keys(a).forEach(function(k) {\n        t[k] = a[k];\n      });\n      return t;\n    }\n    minimatch.defaults = function(def) {\n      if (!def || !Object.keys(def).length)\n        return minimatch;\n      var orig = minimatch;\n      var m = function minimatch2(p, pattern, options8) {\n        return orig.minimatch(p, pattern, ext(def, options8));\n      };\n      m.Minimatch = function Minimatch2(pattern, options8) {\n        return new orig.Minimatch(pattern, ext(def, options8));\n      };\n      return m;\n    };\n    Minimatch.defaults = function(def) {\n      if (!def || !Object.keys(def).length)\n        return Minimatch;\n      return minimatch.defaults(def).Minimatch;\n    };\n    function minimatch(p, pattern, options8) {\n      if (typeof pattern !== \"string\") {\n        throw new TypeError(\"glob pattern string required\");\n      }\n      if (!options8)\n        options8 = {};\n      if (!options8.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n      }\n      if (pattern.trim() === \"\")\n        return p === \"\";\n      return new Minimatch(pattern, options8).match(p);\n    }\n    function Minimatch(pattern, options8) {\n      if (!(this instanceof Minimatch)) {\n        return new Minimatch(pattern, options8, cache3);\n      }\n      if (typeof pattern !== \"string\") {\n        throw new TypeError(\"glob pattern string required\");\n      }\n      if (!options8)\n        options8 = {};\n      if (platform === \"win32\") {\n        pattern = pattern.split(\"\\\\\").join(\"/\");\n      }\n      var cacheKey = pattern + \"\\n\" + sigmund(options8);\n      var cached = minimatch.cache.get(cacheKey);\n      if (cached)\n        return cached;\n      minimatch.cache.set(cacheKey, this);\n      this.options = options8;\n      this.set = [];\n      this.pattern = pattern;\n      this.regexp = null;\n      this.negate = false;\n      this.comment = false;\n      this.empty = false;\n      this.make();\n    }\n    Minimatch.prototype.make = make;\n    function make() {\n      if (this._made)\n        return;\n      var pattern = this.pattern;\n      var options8 = this.options;\n      if (!options8.nocomment && pattern.charAt(0) === \"#\") {\n        this.comment = true;\n        return;\n      }\n      if (!pattern) {\n        this.empty = true;\n        return;\n      }\n      this.parseNegate();\n      var set2 = this.globSet = this.braceExpand();\n      if (options8.debug)\n        console.error(this.pattern, set2);\n      set2 = this.globParts = set2.map(function(s) {\n        return s.split(slashSplit);\n      });\n      if (options8.debug)\n        console.error(this.pattern, set2);\n      set2 = set2.map(function(s, si, set3) {\n        return s.map(this.parse, this);\n      }, this);\n      if (options8.debug)\n        console.error(this.pattern, set2);\n      set2 = set2.filter(function(s) {\n        return -1 === s.indexOf(false);\n      });\n      if (options8.debug)\n        console.error(this.pattern, set2);\n      this.set = set2;\n    }\n    Minimatch.prototype.parseNegate = parseNegate;\n    function parseNegate() {\n      var pattern = this.pattern, negate = false, options8 = this.options, negateOffset = 0;\n      if (options8.nonegate)\n        return;\n      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++) {\n        negate = !negate;\n        negateOffset++;\n      }\n      if (negateOffset)\n        this.pattern = pattern.substr(negateOffset);\n      this.negate = negate;\n    }\n    minimatch.braceExpand = function(pattern, options8) {\n      return new Minimatch(pattern, options8).braceExpand();\n    };\n    Minimatch.prototype.braceExpand = braceExpand;\n    function braceExpand(pattern, options8) {\n      options8 = options8 || this.options;\n      pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n      if (typeof pattern === \"undefined\") {\n        throw new Error(\"undefined pattern\");\n      }\n      if (options8.nobrace || !pattern.match(/\\{.*\\}/)) {\n        return [pattern];\n      }\n      var escaping = false;\n      if (pattern.charAt(0) !== \"{\") {\n        var prefix = null;\n        for (var i = 0, l = pattern.length; i < l; i++) {\n          var c2 = pattern.charAt(i);\n          if (c2 === \"\\\\\") {\n            escaping = !escaping;\n          } else if (c2 === \"{\" && !escaping) {\n            prefix = pattern.substr(0, i);\n            break;\n          }\n        }\n        if (prefix === null) {\n          return [pattern];\n        }\n        var tail = braceExpand(pattern.substr(i), options8);\n        return tail.map(function(t) {\n          return prefix + t;\n        });\n      }\n      var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/);\n      if (numset) {\n        var suf = braceExpand(pattern.substr(numset[0].length), options8), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set2 = [];\n        for (var i = start; i != end + inc; i += inc) {\n          for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n            set2.push(i + suf[ii]);\n          }\n        }\n        return set2;\n      }\n      var i = 1, depth = 1, set2 = [], member = \"\", sawEnd = false, escaping = false;\n      function addMember() {\n        set2.push(member);\n        member = \"\";\n      }\n      FOR:\n        for (i = 1, l = pattern.length; i < l; i++) {\n          var c2 = pattern.charAt(i);\n          if (escaping) {\n            escaping = false;\n            member += \"\\\\\" + c2;\n          } else {\n            switch (c2) {\n              case \"\\\\\":\n                escaping = true;\n                continue;\n              case \"{\":\n                depth++;\n                member += \"{\";\n                continue;\n              case \"}\":\n                depth--;\n                if (depth === 0) {\n                  addMember();\n                  i++;\n                  break FOR;\n                } else {\n                  member += c2;\n                  continue;\n                }\n              case \",\":\n                if (depth === 1) {\n                  addMember();\n                } else {\n                  member += c2;\n                }\n                continue;\n              default:\n                member += c2;\n                continue;\n            }\n          }\n        }\n      if (depth !== 0) {\n        return braceExpand(\"\\\\\" + pattern, options8);\n      }\n      var suf = braceExpand(pattern.substr(i), options8);\n      var addBraces = set2.length === 1;\n      set2 = set2.map(function(p) {\n        return braceExpand(p, options8);\n      });\n      set2 = set2.reduce(function(l2, r) {\n        return l2.concat(r);\n      });\n      if (addBraces) {\n        set2 = set2.map(function(s) {\n          return \"{\" + s + \"}\";\n        });\n      }\n      var ret = [];\n      for (var i = 0, l = set2.length; i < l; i++) {\n        for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n          ret.push(set2[i] + suf[ii]);\n        }\n      }\n      return ret;\n    }\n    Minimatch.prototype.parse = parse6;\n    var SUBPARSE = {};\n    function parse6(pattern, isSub) {\n      var options8 = this.options;\n      if (!options8.noglobstar && pattern === \"**\")\n        return GLOBSTAR;\n      if (pattern === \"\")\n        return \"\";\n      var re = \"\", hasMagic = !!options8.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === \".\" ? \"\" : options8.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n      function clearStateChar() {\n        if (stateChar) {\n          switch (stateChar) {\n            case \"*\":\n              re += star;\n              hasMagic = true;\n              break;\n            case \"?\":\n              re += qmark;\n              hasMagic = true;\n              break;\n            default:\n              re += \"\\\\\" + stateChar;\n              break;\n          }\n          stateChar = false;\n        }\n      }\n      for (var i = 0, len = pattern.length, c2; i < len && (c2 = pattern.charAt(i)); i++) {\n        if (options8.debug) {\n          console.error(\"%s\t%s %s %j\", pattern, i, re, c2);\n        }\n        if (escaping && reSpecials[c2]) {\n          re += \"\\\\\" + c2;\n          escaping = false;\n          continue;\n        }\n        SWITCH:\n          switch (c2) {\n            case \"/\":\n              return false;\n            case \"\\\\\":\n              clearStateChar();\n              escaping = true;\n              continue;\n            case \"?\":\n            case \"*\":\n            case \"+\":\n            case \"@\":\n            case \"!\":\n              if (options8.debug) {\n                console.error(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c2);\n              }\n              if (inClass) {\n                if (c2 === \"!\" && i === classStart + 1)\n                  c2 = \"^\";\n                re += c2;\n                continue;\n              }\n              clearStateChar();\n              stateChar = c2;\n              if (options8.noext)\n                clearStateChar();\n              continue;\n            case \"(\":\n              if (inClass) {\n                re += \"(\";\n                continue;\n              }\n              if (!stateChar) {\n                re += \"\\\\(\";\n                continue;\n              }\n              plType = stateChar;\n              patternListStack.push({\n                type: plType,\n                start: i - 1,\n                reStart: re.length\n              });\n              re += stateChar === \"!\" ? \"(?:(?!\" : \"(?:\";\n              stateChar = false;\n              continue;\n            case \")\":\n              if (inClass || !patternListStack.length) {\n                re += \"\\\\)\";\n                continue;\n              }\n              hasMagic = true;\n              re += \")\";\n              plType = patternListStack.pop().type;\n              switch (plType) {\n                case \"!\":\n                  re += \"[^/]*?)\";\n                  break;\n                case \"?\":\n                case \"+\":\n                case \"*\":\n                  re += plType;\n                case \"@\":\n                  break;\n              }\n              continue;\n            case \"|\":\n              if (inClass || !patternListStack.length || escaping) {\n                re += \"\\\\|\";\n                escaping = false;\n                continue;\n              }\n              re += \"|\";\n              continue;\n            case \"[\":\n              clearStateChar();\n              if (inClass) {\n                re += \"\\\\\" + c2;\n                continue;\n              }\n              inClass = true;\n              classStart = i;\n              reClassStart = re.length;\n              re += c2;\n              continue;\n            case \"]\":\n              if (i === classStart + 1 || !inClass) {\n                re += \"\\\\\" + c2;\n                escaping = false;\n                continue;\n              }\n              hasMagic = true;\n              inClass = false;\n              re += c2;\n              continue;\n            default:\n              clearStateChar();\n              if (escaping) {\n                escaping = false;\n              } else if (reSpecials[c2] && !(c2 === \"^\" && inClass)) {\n                re += \"\\\\\";\n              }\n              re += c2;\n          }\n      }\n      if (inClass) {\n        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);\n        re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n        hasMagic = hasMagic || sp[1];\n      }\n      var pl;\n      while (pl = patternListStack.pop()) {\n        var tail = re.slice(pl.reStart + 3);\n        tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function(_, $1, $2) {\n          if (!$2) {\n            $2 = \"\\\\\";\n          }\n          return $1 + $1 + $2 + \"|\";\n        });\n        var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n        hasMagic = true;\n        re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n      }\n      clearStateChar();\n      if (escaping) {\n        re += \"\\\\\\\\\";\n      }\n      var addPatternStart = false;\n      switch (re.charAt(0)) {\n        case \".\":\n        case \"[\":\n        case \"(\":\n          addPatternStart = true;\n      }\n      if (re !== \"\" && hasMagic)\n        re = \"(?=.)\" + re;\n      if (addPatternStart)\n        re = patternStart + re;\n      if (isSub === SUBPARSE) {\n        return [re, hasMagic];\n      }\n      if (!hasMagic) {\n        return globUnescape(pattern);\n      }\n      var flags = options8.nocase ? \"i\" : \"\", regExp = new RegExp(\"^\" + re + \"$\", flags);\n      regExp._glob = pattern;\n      regExp._src = re;\n      return regExp;\n    }\n    minimatch.makeRe = function(pattern, options8) {\n      return new Minimatch(pattern, options8 || {}).makeRe();\n    };\n    Minimatch.prototype.makeRe = makeRe;\n    function makeRe() {\n      if (this.regexp || this.regexp === false)\n        return this.regexp;\n      var set2 = this.set;\n      if (!set2.length)\n        return this.regexp = false;\n      var options8 = this.options;\n      var twoStar = options8.noglobstar ? star : options8.dot ? twoStarDot : twoStarNoDot, flags = options8.nocase ? \"i\" : \"\";\n      var re = set2.map(function(pattern) {\n        return pattern.map(function(p) {\n          return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n        }).join(\"\\\\/\");\n      }).join(\"|\");\n      re = \"^(?:\" + re + \")$\";\n      if (this.negate)\n        re = \"^(?!\" + re + \").*$\";\n      try {\n        return this.regexp = new RegExp(re, flags);\n      } catch (ex) {\n        return this.regexp = false;\n      }\n    }\n    minimatch.match = function(list, pattern, options8) {\n      var mm = new Minimatch(pattern, options8);\n      list = list.filter(function(f) {\n        return mm.match(f);\n      });\n      if (options8.nonull && !list.length) {\n        list.push(pattern);\n      }\n      return list;\n    };\n    Minimatch.prototype.match = match;\n    function match(f, partial) {\n      if (this.comment)\n        return false;\n      if (this.empty)\n        return f === \"\";\n      if (f === \"/\" && partial)\n        return true;\n      var options8 = this.options;\n      if (platform === \"win32\") {\n        f = f.split(\"\\\\\").join(\"/\");\n      }\n      f = f.split(slashSplit);\n      if (options8.debug) {\n        console.error(this.pattern, \"split\", f);\n      }\n      var set2 = this.set;\n      for (var i = 0, l = set2.length; i < l; i++) {\n        var pattern = set2[i];\n        var hit = this.matchOne(f, pattern, partial);\n        if (hit) {\n          if (options8.flipNegate)\n            return true;\n          return !this.negate;\n        }\n      }\n      if (options8.flipNegate)\n        return false;\n      return this.negate;\n    }\n    Minimatch.prototype.matchOne = function(file, pattern, partial) {\n      var options8 = this.options;\n      if (options8.debug) {\n        console.error(\n          \"matchOne\",\n          {\n            \"this\": this,\n            file,\n            pattern\n          }\n        );\n      }\n      if (options8.matchBase && pattern.length === 1) {\n        file = path13.basename(file.join(\"/\")).split(\"/\");\n      }\n      if (options8.debug) {\n        console.error(\"matchOne\", file.length, pattern.length);\n      }\n      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n        if (options8.debug) {\n          console.error(\"matchOne loop\");\n        }\n        var p = pattern[pi], f = file[fi];\n        if (options8.debug) {\n          console.error(pattern, p, f);\n        }\n        if (p === false)\n          return false;\n        if (p === GLOBSTAR) {\n          if (options8.debug)\n            console.error(\"GLOBSTAR\", [pattern, p, f]);\n          var fr = fi, pr = pi + 1;\n          if (pr === pl) {\n            if (options8.debug)\n              console.error(\"** at the end\");\n            for (; fi < fl; fi++) {\n              if (file[fi] === \".\" || file[fi] === \"..\" || !options8.dot && file[fi].charAt(0) === \".\")\n                return false;\n            }\n            return true;\n          }\n          WHILE:\n            while (fr < fl) {\n              var swallowee = file[fr];\n              if (options8.debug) {\n                console.error(\n                  \"\\nglobstar while\",\n                  file,\n                  fr,\n                  pattern,\n                  pr,\n                  swallowee\n                );\n              }\n              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                if (options8.debug)\n                  console.error(\"globstar found match!\", fr, fl, swallowee);\n                return true;\n              } else {\n                if (swallowee === \".\" || swallowee === \"..\" || !options8.dot && swallowee.charAt(0) === \".\") {\n                  if (options8.debug)\n                    console.error(\"dot detected!\", file, fr, pattern, pr);\n                  break WHILE;\n                }\n                if (options8.debug)\n                  console.error(\"globstar swallow a segment, and continue\");\n                fr++;\n              }\n            }\n          if (partial) {\n            if (fr === fl)\n              return true;\n          }\n          return false;\n        }\n        var hit;\n        if (typeof p === \"string\") {\n          if (options8.nocase) {\n            hit = f.toLowerCase() === p.toLowerCase();\n          } else {\n            hit = f === p;\n          }\n          if (options8.debug) {\n            console.error(\"string match\", p, f, hit);\n          }\n        } else {\n          hit = f.match(p);\n          if (options8.debug) {\n            console.error(\"pattern match\", p, f, hit);\n          }\n        }\n        if (!hit)\n          return false;\n      }\n      if (fi === fl && pi === pl) {\n        return true;\n      } else if (fi === fl) {\n        return partial;\n      } else if (pi === pl) {\n        var emptyFileEnd = fi === fl - 1 && file[fi] === \"\";\n        return emptyFileEnd;\n      }\n      throw new Error(\"wtf?\");\n    };\n    function globUnescape(s) {\n      return s.replace(/\\\\(.)/g, \"$1\");\n    }\n    function regExpEscape(s) {\n      return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n    }\n  }\n});\n\n// node_modules/editorconfig/src/lib/ini.js\nvar require_ini = __commonJS({\n  \"node_modules/editorconfig/src/lib/ini.js\"(exports) {\n    \"use strict\";\n    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function(resolve3, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve3(result.value) : new P(function(resolve4) {\n            resolve4(result.value);\n          }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __generator = exports && exports.__generator || function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    var __importStar = exports && exports.__importStar || function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod)\n          if (Object.hasOwnProperty.call(mod, k))\n            result[k] = mod[k];\n      }\n      result[\"default\"] = mod;\n      return result;\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fs7 = __importStar(__require(\"fs\"));\n    var regex = {\n      section: /^\\s*\\[(([^#;]|\\\\#|\\\\;)+)\\]\\s*([#;].*)?$/,\n      param: /^\\s*([\\w\\.\\-\\_]+)\\s*[=:]\\s*(.*?)\\s*([#;].*)?$/,\n      comment: /^\\s*[#;].*$/\n    };\n    function parse6(file) {\n      return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n          return [2, new Promise(function(resolve3, reject) {\n            fs7.readFile(file, \"utf8\", function(err, data) {\n              if (err) {\n                reject(err);\n                return;\n              }\n              resolve3(parseString(data));\n            });\n          })];\n        });\n      });\n    }\n    exports.parse = parse6;\n    function parseSync(file) {\n      return parseString(fs7.readFileSync(file, \"utf8\"));\n    }\n    exports.parseSync = parseSync;\n    function parseString(data) {\n      var sectionBody = {};\n      var sectionName = null;\n      var value = [[sectionName, sectionBody]];\n      var lines = data.split(/\\r\\n|\\r|\\n/);\n      lines.forEach(function(line3) {\n        var match;\n        if (regex.comment.test(line3)) {\n          return;\n        }\n        if (regex.param.test(line3)) {\n          match = line3.match(regex.param);\n          sectionBody[match[1]] = match[2];\n        } else if (regex.section.test(line3)) {\n          match = line3.match(regex.section);\n          sectionName = match[1];\n          sectionBody = {};\n          value.push([sectionName, sectionBody]);\n        }\n      });\n      return value;\n    }\n    exports.parseString = parseString;\n  }\n});\n\n// node_modules/editorconfig/package.json\nvar require_package = __commonJS({\n  \"node_modules/editorconfig/package.json\"(exports, module) {\n    module.exports = {\n      name: \"editorconfig\",\n      version: \"0.15.3\",\n      description: \"EditorConfig File Locator and Interpreter for Node.js\",\n      keywords: [\n        \"editorconfig\",\n        \"core\"\n      ],\n      main: \"src/index.js\",\n      contributors: [\n        \"Hong Xu (topbug.net)\",\n        \"Jed Mao (https://github.com/jedmao/)\",\n        \"Trey Hunner (http://treyhunner.com)\"\n      ],\n      directories: {\n        bin: \"./bin\",\n        lib: \"./lib\"\n      },\n      scripts: {\n        clean: \"rimraf dist\",\n        prebuild: \"npm run clean\",\n        build: \"tsc\",\n        pretest: \"npm run lint && npm run build && npm run copy && cmake .\",\n        test: \"ctest .\",\n        \"pretest:ci\": \"npm run pretest\",\n        \"test:ci\": \"ctest -VV --output-on-failure .\",\n        lint: \"npm run eclint && npm run tslint\",\n        eclint: 'eclint check --indent_size ignore \"src/**\"',\n        tslint: \"tslint --project tsconfig.json --exclude package.json\",\n        copy: \"cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib\",\n        prepub: \"npm run lint && npm run build && npm run copy\",\n        pub: \"npm publish ./dist\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git://github.com/editorconfig/editorconfig-core-js.git\"\n      },\n      bugs: \"https://github.com/editorconfig/editorconfig-core-js/issues\",\n      author: \"EditorConfig Team\",\n      license: \"MIT\",\n      dependencies: {\n        commander: \"^2.19.0\",\n        \"lru-cache\": \"^4.1.5\",\n        semver: \"^5.6.0\",\n        sigmund: \"^1.0.1\"\n      },\n      devDependencies: {\n        \"@types/mocha\": \"^5.2.6\",\n        \"@types/node\": \"^10.12.29\",\n        \"@types/semver\": \"^5.5.0\",\n        \"cpy-cli\": \"^2.0.0\",\n        eclint: \"^2.8.1\",\n        mocha: \"^5.2.0\",\n        rimraf: \"^2.6.3\",\n        should: \"^13.2.3\",\n        tslint: \"^5.13.1\",\n        typescript: \"^3.3.3333\"\n      }\n    };\n  }\n});\n\n// node_modules/editorconfig/src/index.js\nvar require_src = __commonJS({\n  \"node_modules/editorconfig/src/index.js\"(exports) {\n    \"use strict\";\n    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function(resolve3, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator[\"throw\"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve3(result.value) : new P(function(resolve4) {\n            resolve4(result.value);\n          }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __generator = exports && exports.__generator || function(thisArg, body) {\n      var _ = { label: 0, sent: function() {\n        if (t[0] & 1)\n          throw t[1];\n        return t[1];\n      }, trys: [], ops: [] }, f, y, t, g;\n      return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError(\"Generator is already executing.\");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return { value: op[1], done: false };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return { value: op[0] ? op[1] : void 0, done: true };\n      }\n    };\n    var __importStar = exports && exports.__importStar || function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod)\n          if (Object.hasOwnProperty.call(mod, k))\n            result[k] = mod[k];\n      }\n      result[\"default\"] = mod;\n      return result;\n    };\n    var __importDefault = exports && exports.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : { \"default\": mod };\n    };\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var fs7 = __importStar(__require(\"fs\"));\n    var path13 = __importStar(__require(\"path\"));\n    var semver = {\n      gte: require_gte()\n    };\n    var fnmatch_1 = __importDefault(require_fnmatch());\n    var ini_1 = require_ini();\n    exports.parseString = ini_1.parseString;\n    var package_json_1 = __importDefault(require_package());\n    var knownProps = {\n      end_of_line: true,\n      indent_style: true,\n      indent_size: true,\n      insert_final_newline: true,\n      trim_trailing_whitespace: true,\n      charset: true\n    };\n    function fnmatch(filepath, glob) {\n      var matchOptions = { matchBase: true, dot: true, noext: true };\n      glob = glob.replace(/\\*\\*/g, \"{*,**/**/**}\");\n      return fnmatch_1.default(filepath, glob, matchOptions);\n    }\n    function getConfigFileNames(filepath, options8) {\n      var paths = [];\n      do {\n        filepath = path13.dirname(filepath);\n        paths.push(path13.join(filepath, options8.config));\n      } while (filepath !== options8.root);\n      return paths;\n    }\n    function processMatches(matches, version) {\n      if (\"indent_style\" in matches && matches.indent_style === \"tab\" && !(\"indent_size\" in matches) && semver.gte(version, \"0.10.0\")) {\n        matches.indent_size = \"tab\";\n      }\n      if (\"indent_size\" in matches && !(\"tab_width\" in matches) && matches.indent_size !== \"tab\") {\n        matches.tab_width = matches.indent_size;\n      }\n      if (\"indent_size\" in matches && \"tab_width\" in matches && matches.indent_size === \"tab\") {\n        matches.indent_size = matches.tab_width;\n      }\n      return matches;\n    }\n    function processOptions(options8, filepath) {\n      if (options8 === void 0) {\n        options8 = {};\n      }\n      return {\n        config: options8.config || \".editorconfig\",\n        version: options8.version || package_json_1.default.version,\n        root: path13.resolve(options8.root || path13.parse(filepath).root)\n      };\n    }\n    function buildFullGlob(pathPrefix, glob) {\n      switch (glob.indexOf(\"/\")) {\n        case -1:\n          glob = \"**/\" + glob;\n          break;\n        case 0:\n          glob = glob.substring(1);\n          break;\n        default:\n          break;\n      }\n      return path13.join(pathPrefix, glob);\n    }\n    function extendProps(props, options8) {\n      if (props === void 0) {\n        props = {};\n      }\n      if (options8 === void 0) {\n        options8 = {};\n      }\n      for (var key2 in options8) {\n        if (options8.hasOwnProperty(key2)) {\n          var value = options8[key2];\n          var key22 = key2.toLowerCase();\n          var value2 = value;\n          if (knownProps[key22]) {\n            value2 = value.toLowerCase();\n          }\n          try {\n            value2 = JSON.parse(value);\n          } catch (e) {\n          }\n          if (typeof value === \"undefined\" || value === null) {\n            value2 = String(value);\n          }\n          props[key22] = value2;\n        }\n      }\n      return props;\n    }\n    function parseFromConfigs(configs, filepath, options8) {\n      return processMatches(configs.reverse().reduce(function(matches, file) {\n        var pathPrefix = path13.dirname(file.name);\n        file.contents.forEach(function(section) {\n          var glob = section[0];\n          var options22 = section[1];\n          if (!glob) {\n            return;\n          }\n          var fullGlob = buildFullGlob(pathPrefix, glob);\n          if (!fnmatch(filepath, fullGlob)) {\n            return;\n          }\n          matches = extendProps(matches, options22);\n        });\n        return matches;\n      }, {}), options8.version);\n    }\n    function getConfigsForFiles(files) {\n      var configs = [];\n      for (var i in files) {\n        if (files.hasOwnProperty(i)) {\n          var file = files[i];\n          var contents = ini_1.parseString(file.contents);\n          configs.push({\n            name: file.name,\n            contents\n          });\n          if ((contents[0][1].root || \"\").toLowerCase() === \"true\") {\n            break;\n          }\n        }\n      }\n      return configs;\n    }\n    function readConfigFiles(filepaths) {\n      return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n          return [2, Promise.all(filepaths.map(function(name) {\n            return new Promise(function(resolve3) {\n              fs7.readFile(name, \"utf8\", function(err, data) {\n                resolve3({\n                  name,\n                  contents: err ? \"\" : data\n                });\n              });\n            });\n          }))];\n        });\n      });\n    }\n    function readConfigFilesSync(filepaths) {\n      var files = [];\n      var file;\n      filepaths.forEach(function(filepath) {\n        try {\n          file = fs7.readFileSync(filepath, \"utf8\");\n        } catch (e) {\n          file = \"\";\n        }\n        files.push({\n          name: filepath,\n          contents: file\n        });\n      });\n      return files;\n    }\n    function opts(filepath, options8) {\n      if (options8 === void 0) {\n        options8 = {};\n      }\n      var resolvedFilePath = path13.resolve(filepath);\n      return [\n        resolvedFilePath,\n        processOptions(options8, resolvedFilePath)\n      ];\n    }\n    function parseFromFiles(filepath, files, options8) {\n      if (options8 === void 0) {\n        options8 = {};\n      }\n      return __awaiter(this, void 0, void 0, function() {\n        var _a, resolvedFilePath, processedOptions;\n        return __generator(this, function(_b) {\n          _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1];\n          return [2, files.then(getConfigsForFiles).then(function(configs) {\n            return parseFromConfigs(configs, resolvedFilePath, processedOptions);\n          })];\n        });\n      });\n    }\n    exports.parseFromFiles = parseFromFiles;\n    function parseFromFilesSync(filepath, files, options8) {\n      if (options8 === void 0) {\n        options8 = {};\n      }\n      var _a = opts(filepath, options8), resolvedFilePath = _a[0], processedOptions = _a[1];\n      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);\n    }\n    exports.parseFromFilesSync = parseFromFilesSync;\n    function parse6(_filepath, _options) {\n      if (_options === void 0) {\n        _options = {};\n      }\n      return __awaiter(this, void 0, void 0, function() {\n        var _a, resolvedFilePath, processedOptions, filepaths;\n        return __generator(this, function(_b) {\n          _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];\n          filepaths = getConfigFileNames(resolvedFilePath, processedOptions);\n          return [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {\n            return parseFromConfigs(configs, resolvedFilePath, processedOptions);\n          })];\n        });\n      });\n    }\n    exports.parse = parse6;\n    function parseSync(_filepath, _options) {\n      if (_options === void 0) {\n        _options = {};\n      }\n      var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];\n      var filepaths = getConfigFileNames(resolvedFilePath, processedOptions);\n      var files = readConfigFilesSync(filepaths);\n      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);\n    }\n    exports.parseSync = parseSync;\n  }\n});\n\n// node_modules/ci-info/vendors.json\nvar require_vendors = __commonJS({\n  \"node_modules/ci-info/vendors.json\"(exports, module) {\n    module.exports = [\n      {\n        name: \"Agola CI\",\n        constant: \"AGOLA\",\n        env: \"AGOLA_GIT_REF\",\n        pr: \"AGOLA_PULL_REQUEST_ID\"\n      },\n      {\n        name: \"Appcircle\",\n        constant: \"APPCIRCLE\",\n        env: \"AC_APPCIRCLE\"\n      },\n      {\n        name: \"AppVeyor\",\n        constant: \"APPVEYOR\",\n        env: \"APPVEYOR\",\n        pr: \"APPVEYOR_PULL_REQUEST_NUMBER\"\n      },\n      {\n        name: \"AWS CodeBuild\",\n        constant: \"CODEBUILD\",\n        env: \"CODEBUILD_BUILD_ARN\"\n      },\n      {\n        name: \"Azure Pipelines\",\n        constant: \"AZURE_PIPELINES\",\n        env: \"TF_BUILD\",\n        pr: {\n          BUILD_REASON: \"PullRequest\"\n        }\n      },\n      {\n        name: \"Bamboo\",\n        constant: \"BAMBOO\",\n        env: \"bamboo_planKey\"\n      },\n      {\n        name: \"Bitbucket Pipelines\",\n        constant: \"BITBUCKET\",\n        env: \"BITBUCKET_COMMIT\",\n        pr: \"BITBUCKET_PR_ID\"\n      },\n      {\n        name: \"Bitrise\",\n        constant: \"BITRISE\",\n        env: \"BITRISE_IO\",\n        pr: \"BITRISE_PULL_REQUEST\"\n      },\n      {\n        name: \"Buddy\",\n        constant: \"BUDDY\",\n        env: \"BUDDY_WORKSPACE_ID\",\n        pr: \"BUDDY_EXECUTION_PULL_REQUEST_ID\"\n      },\n      {\n        name: \"Buildkite\",\n        constant: \"BUILDKITE\",\n        env: \"BUILDKITE\",\n        pr: {\n          env: \"BUILDKITE_PULL_REQUEST\",\n          ne: \"false\"\n        }\n      },\n      {\n        name: \"CircleCI\",\n        constant: \"CIRCLE\",\n        env: \"CIRCLECI\",\n        pr: \"CIRCLE_PULL_REQUEST\"\n      },\n      {\n        name: \"Cirrus CI\",\n        constant: \"CIRRUS\",\n        env: \"CIRRUS_CI\",\n        pr: \"CIRRUS_PR\"\n      },\n      {\n        name: \"Codefresh\",\n        constant: \"CODEFRESH\",\n        env: \"CF_BUILD_ID\",\n        pr: {\n          any: [\n            \"CF_PULL_REQUEST_NUMBER\",\n            \"CF_PULL_REQUEST_ID\"\n          ]\n        }\n      },\n      {\n        name: \"Codemagic\",\n        constant: \"CODEMAGIC\",\n        env: \"CM_BUILD_ID\",\n        pr: \"CM_PULL_REQUEST\"\n      },\n      {\n        name: \"Codeship\",\n        constant: \"CODESHIP\",\n        env: {\n          CI_NAME: \"codeship\"\n        }\n      },\n      {\n        name: \"Drone\",\n        constant: \"DRONE\",\n        env: \"DRONE\",\n        pr: {\n          DRONE_BUILD_EVENT: \"pull_request\"\n        }\n      },\n      {\n        name: \"dsari\",\n        constant: \"DSARI\",\n        env: \"DSARI\"\n      },\n      {\n        name: \"Earthly\",\n        constant: \"EARTHLY\",\n        env: \"EARTHLY_CI\"\n      },\n      {\n        name: \"Expo Application Services\",\n        constant: \"EAS\",\n        env: \"EAS_BUILD\"\n      },\n      {\n        name: \"Gerrit\",\n        constant: \"GERRIT\",\n        env: \"GERRIT_PROJECT\"\n      },\n      {\n        name: \"Gitea Actions\",\n        constant: \"GITEA_ACTIONS\",\n        env: \"GITEA_ACTIONS\"\n      },\n      {\n        name: \"GitHub Actions\",\n        constant: \"GITHUB_ACTIONS\",\n        env: \"GITHUB_ACTIONS\",\n        pr: {\n          GITHUB_EVENT_NAME: \"pull_request\"\n        }\n      },\n      {\n        name: \"GitLab CI\",\n        constant: \"GITLAB\",\n        env: \"GITLAB_CI\",\n        pr: \"CI_MERGE_REQUEST_ID\"\n      },\n      {\n        name: \"GoCD\",\n        constant: \"GOCD\",\n        env: \"GO_PIPELINE_LABEL\"\n      },\n      {\n        name: \"Google Cloud Build\",\n        constant: \"GOOGLE_CLOUD_BUILD\",\n        env: \"BUILDER_OUTPUT\"\n      },\n      {\n        name: \"Harness CI\",\n        constant: \"HARNESS\",\n        env: \"HARNESS_BUILD_ID\"\n      },\n      {\n        name: \"Heroku\",\n        constant: \"HEROKU\",\n        env: {\n          env: \"NODE\",\n          includes: \"/app/.heroku/node/bin/node\"\n        }\n      },\n      {\n        name: \"Hudson\",\n        constant: \"HUDSON\",\n        env: \"HUDSON_URL\"\n      },\n      {\n        name: \"Jenkins\",\n        constant: \"JENKINS\",\n        env: [\n          \"JENKINS_URL\",\n          \"BUILD_ID\"\n        ],\n        pr: {\n          any: [\n            \"ghprbPullId\",\n            \"CHANGE_ID\"\n          ]\n        }\n      },\n      {\n        name: \"LayerCI\",\n        constant: \"LAYERCI\",\n        env: \"LAYERCI\",\n        pr: \"LAYERCI_PULL_REQUEST\"\n      },\n      {\n        name: \"Magnum CI\",\n        constant: \"MAGNUM\",\n        env: \"MAGNUM\"\n      },\n      {\n        name: \"Netlify CI\",\n        constant: \"NETLIFY\",\n        env: \"NETLIFY\",\n        pr: {\n          env: \"PULL_REQUEST\",\n          ne: \"false\"\n        }\n      },\n      {\n        name: \"Nevercode\",\n        constant: \"NEVERCODE\",\n        env: \"NEVERCODE\",\n        pr: {\n          env: \"NEVERCODE_PULL_REQUEST\",\n          ne: \"false\"\n        }\n      },\n      {\n        name: \"Prow\",\n        constant: \"PROW\",\n        env: \"PROW_JOB_ID\"\n      },\n      {\n        name: \"ReleaseHub\",\n        constant: \"RELEASEHUB\",\n        env: \"RELEASE_BUILD_ID\"\n      },\n      {\n        name: \"Render\",\n        constant: \"RENDER\",\n        env: \"RENDER\",\n        pr: {\n          IS_PULL_REQUEST: \"true\"\n        }\n      },\n      {\n        name: \"Sail CI\",\n        constant: \"SAIL\",\n        env: \"SAILCI\",\n        pr: \"SAIL_PULL_REQUEST_NUMBER\"\n      },\n      {\n        name: \"Screwdriver\",\n        constant: \"SCREWDRIVER\",\n        env: \"SCREWDRIVER\",\n        pr: {\n          env: \"SD_PULL_REQUEST\",\n          ne: \"false\"\n        }\n      },\n      {\n        name: \"Semaphore\",\n        constant: \"SEMAPHORE\",\n        env: \"SEMAPHORE\",\n        pr: \"PULL_REQUEST_NUMBER\"\n      },\n      {\n        name: \"Sourcehut\",\n        constant: \"SOURCEHUT\",\n        env: {\n          CI_NAME: \"sourcehut\"\n        }\n      },\n      {\n        name: \"Strider CD\",\n        constant: \"STRIDER\",\n        env: \"STRIDER\"\n      },\n      {\n        name: \"TaskCluster\",\n        constant: \"TASKCLUSTER\",\n        env: [\n          \"TASK_ID\",\n          \"RUN_ID\"\n        ]\n      },\n      {\n        name: \"TeamCity\",\n        constant: \"TEAMCITY\",\n        env: \"TEAMCITY_VERSION\"\n      },\n      {\n        name: \"Travis CI\",\n        constant: \"TRAVIS\",\n        env: \"TRAVIS\",\n        pr: {\n          env: \"TRAVIS_PULL_REQUEST\",\n          ne: \"false\"\n        }\n      },\n      {\n        name: \"Vela\",\n        constant: \"VELA\",\n        env: \"VELA\",\n        pr: {\n          VELA_PULL_REQUEST: \"1\"\n        }\n      },\n      {\n        name: \"Vercel\",\n        constant: \"VERCEL\",\n        env: {\n          any: [\n            \"NOW_BUILDER\",\n            \"VERCEL\"\n          ]\n        },\n        pr: \"VERCEL_GIT_PULL_REQUEST_ID\"\n      },\n      {\n        name: \"Visual Studio App Center\",\n        constant: \"APPCENTER\",\n        env: \"APPCENTER_BUILD_ID\"\n      },\n      {\n        name: \"Woodpecker\",\n        constant: \"WOODPECKER\",\n        env: {\n          CI: \"woodpecker\"\n        },\n        pr: {\n          CI_BUILD_EVENT: \"pull_request\"\n        }\n      },\n      {\n        name: \"Xcode Cloud\",\n        constant: \"XCODE_CLOUD\",\n        env: \"CI_XCODE_PROJECT\",\n        pr: \"CI_PULL_REQUEST_NUMBER\"\n      },\n      {\n        name: \"Xcode Server\",\n        constant: \"XCODE_SERVER\",\n        env: \"XCS\"\n      }\n    ];\n  }\n});\n\n// node_modules/ci-info/index.js\nvar require_ci_info = __commonJS({\n  \"node_modules/ci-info/index.js\"(exports) {\n    \"use strict\";\n    var vendors = require_vendors();\n    var env2 = process.env;\n    Object.defineProperty(exports, \"_vendors\", {\n      value: vendors.map(function(v) {\n        return v.constant;\n      })\n    });\n    exports.name = null;\n    exports.isPR = null;\n    vendors.forEach(function(vendor) {\n      const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];\n      const isCI2 = envs.every(function(obj) {\n        return checkEnv(obj);\n      });\n      exports[vendor.constant] = isCI2;\n      if (!isCI2) {\n        return;\n      }\n      exports.name = vendor.name;\n      switch (typeof vendor.pr) {\n        case \"string\":\n          exports.isPR = !!env2[vendor.pr];\n          break;\n        case \"object\":\n          if (\"env\" in vendor.pr) {\n            exports.isPR = vendor.pr.env in env2 && env2[vendor.pr.env] !== vendor.pr.ne;\n          } else if (\"any\" in vendor.pr) {\n            exports.isPR = vendor.pr.any.some(function(key2) {\n              return !!env2[key2];\n            });\n          } else {\n            exports.isPR = checkEnv(vendor.pr);\n          }\n          break;\n        default:\n          exports.isPR = null;\n      }\n    });\n    exports.isCI = !!(env2.CI !== \"false\" && // Bypass all checks if CI env is explicitly set to 'false'\n    (env2.BUILD_ID || // Jenkins, Cloudbees\n    env2.BUILD_NUMBER || // Jenkins, TeamCity\n    env2.CI || // Travis CI, CircleCI, Cirrus CI, Gitlab CI, Appveyor, CodeShip, dsari\n    env2.CI_APP_ID || // Appflow\n    env2.CI_BUILD_ID || // Appflow\n    env2.CI_BUILD_NUMBER || // Appflow\n    env2.CI_NAME || // Codeship and others\n    env2.CONTINUOUS_INTEGRATION || // Travis CI, Cirrus CI\n    env2.RUN_ID || // TaskCluster, dsari\n    exports.name || false));\n    function checkEnv(obj) {\n      if (typeof obj === \"string\")\n        return !!env2[obj];\n      if (\"env\" in obj) {\n        return env2[obj.env] && env2[obj.env].includes(obj.includes);\n      }\n      if (\"any\" in obj) {\n        return obj.any.some(function(k) {\n          return !!env2[k];\n        });\n      }\n      return Object.keys(obj).every(function(k) {\n        return env2[k] === obj[k];\n      });\n    }\n  }\n});\n\n// node_modules/@iarna/toml/lib/parser.js\nvar require_parser = __commonJS({\n  \"node_modules/@iarna/toml/lib/parser.js\"(exports, module) {\n    \"use strict\";\n    var ParserEND = 1114112;\n    var ParserError = class _ParserError extends Error {\n      /* istanbul ignore next */\n      constructor(msg, filename, linenumber) {\n        super(\"[ParserError] \" + msg, filename, linenumber);\n        this.name = \"ParserError\";\n        this.code = \"ParserError\";\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, _ParserError);\n      }\n    };\n    var State = class {\n      constructor(parser) {\n        this.parser = parser;\n        this.buf = \"\";\n        this.returned = null;\n        this.result = null;\n        this.resultTable = null;\n        this.resultArr = null;\n      }\n    };\n    var Parser = class {\n      constructor() {\n        this.pos = 0;\n        this.col = 0;\n        this.line = 0;\n        this.obj = {};\n        this.ctx = this.obj;\n        this.stack = [];\n        this._buf = \"\";\n        this.char = null;\n        this.ii = 0;\n        this.state = new State(this.parseStart);\n      }\n      parse(str2) {\n        if (str2.length === 0 || str2.length == null)\n          return;\n        this._buf = String(str2);\n        this.ii = -1;\n        this.char = -1;\n        let getNext;\n        while (getNext === false || this.nextChar()) {\n          getNext = this.runOne();\n        }\n        this._buf = null;\n      }\n      nextChar() {\n        if (this.char === 10) {\n          ++this.line;\n          this.col = -1;\n        }\n        ++this.ii;\n        this.char = this._buf.codePointAt(this.ii);\n        ++this.pos;\n        ++this.col;\n        return this.haveBuffer();\n      }\n      haveBuffer() {\n        return this.ii < this._buf.length;\n      }\n      runOne() {\n        return this.state.parser.call(this, this.state.returned);\n      }\n      finish() {\n        this.char = ParserEND;\n        let last;\n        do {\n          last = this.state.parser;\n          this.runOne();\n        } while (this.state.parser !== last);\n        this.ctx = null;\n        this.state = null;\n        this._buf = null;\n        return this.obj;\n      }\n      next(fn) {\n        if (typeof fn !== \"function\")\n          throw new ParserError(\"Tried to set state to non-existent state: \" + JSON.stringify(fn));\n        this.state.parser = fn;\n      }\n      goto(fn) {\n        this.next(fn);\n        return this.runOne();\n      }\n      call(fn, returnWith) {\n        if (returnWith)\n          this.next(returnWith);\n        this.stack.push(this.state);\n        this.state = new State(fn);\n      }\n      callNow(fn, returnWith) {\n        this.call(fn, returnWith);\n        return this.runOne();\n      }\n      return(value) {\n        if (this.stack.length === 0)\n          throw this.error(new ParserError(\"Stack underflow\"));\n        if (value === void 0)\n          value = this.state.buf;\n        this.state = this.stack.pop();\n        this.state.returned = value;\n      }\n      returnNow(value) {\n        this.return(value);\n        return this.runOne();\n      }\n      consume() {\n        if (this.char === ParserEND)\n          throw this.error(new ParserError(\"Unexpected end-of-buffer\"));\n        this.state.buf += this._buf[this.ii];\n      }\n      error(err) {\n        err.line = this.line;\n        err.col = this.col;\n        err.pos = this.pos;\n        return err;\n      }\n      /* istanbul ignore next */\n      parseStart() {\n        throw new ParserError(\"Must declare a parseStart method\");\n      }\n    };\n    Parser.END = ParserEND;\n    Parser.Error = ParserError;\n    module.exports = Parser;\n  }\n});\n\n// node_modules/@iarna/toml/lib/create-datetime.js\nvar require_create_datetime = __commonJS({\n  \"node_modules/@iarna/toml/lib/create-datetime.js\"(exports, module) {\n    \"use strict\";\n    module.exports = (value) => {\n      const date = new Date(value);\n      if (isNaN(date)) {\n        throw new TypeError(\"Invalid Datetime\");\n      } else {\n        return date;\n      }\n    };\n  }\n});\n\n// node_modules/@iarna/toml/lib/format-num.js\nvar require_format_num = __commonJS({\n  \"node_modules/@iarna/toml/lib/format-num.js\"(exports, module) {\n    \"use strict\";\n    module.exports = (d, num) => {\n      num = String(num);\n      while (num.length < d)\n        num = \"0\" + num;\n      return num;\n    };\n  }\n});\n\n// node_modules/@iarna/toml/lib/create-datetime-float.js\nvar require_create_datetime_float = __commonJS({\n  \"node_modules/@iarna/toml/lib/create-datetime-float.js\"(exports, module) {\n    \"use strict\";\n    var f = require_format_num();\n    var FloatingDateTime = class extends Date {\n      constructor(value) {\n        super(value + \"Z\");\n        this.isFloating = true;\n      }\n      toISOString() {\n        const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;\n        const time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;\n        return `${date}T${time}`;\n      }\n    };\n    module.exports = (value) => {\n      const date = new FloatingDateTime(value);\n      if (isNaN(date)) {\n        throw new TypeError(\"Invalid Datetime\");\n      } else {\n        return date;\n      }\n    };\n  }\n});\n\n// node_modules/@iarna/toml/lib/create-date.js\nvar require_create_date = __commonJS({\n  \"node_modules/@iarna/toml/lib/create-date.js\"(exports, module) {\n    \"use strict\";\n    var f = require_format_num();\n    var DateTime = global.Date;\n    var Date2 = class extends DateTime {\n      constructor(value) {\n        super(value);\n        this.isDate = true;\n      }\n      toISOString() {\n        return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;\n      }\n    };\n    module.exports = (value) => {\n      const date = new Date2(value);\n      if (isNaN(date)) {\n        throw new TypeError(\"Invalid Datetime\");\n      } else {\n        return date;\n      }\n    };\n  }\n});\n\n// node_modules/@iarna/toml/lib/create-time.js\nvar require_create_time = __commonJS({\n  \"node_modules/@iarna/toml/lib/create-time.js\"(exports, module) {\n    \"use strict\";\n    var f = require_format_num();\n    var Time = class extends Date {\n      constructor(value) {\n        super(`0000-01-01T${value}Z`);\n        this.isTime = true;\n      }\n      toISOString() {\n        return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;\n      }\n    };\n    module.exports = (value) => {\n      const date = new Time(value);\n      if (isNaN(date)) {\n        throw new TypeError(\"Invalid Datetime\");\n      } else {\n        return date;\n      }\n    };\n  }\n});\n\n// node_modules/@iarna/toml/lib/toml-parser.js\nvar require_toml_parser = __commonJS({\n  \"node_modules/@iarna/toml/lib/toml-parser.js\"(exports, module) {\n    \"use strict\";\n    module.exports = makeParserClass(require_parser());\n    module.exports.makeParserClass = makeParserClass;\n    var TomlError = class _TomlError extends Error {\n      constructor(msg) {\n        super(msg);\n        this.name = \"TomlError\";\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, _TomlError);\n        this.fromTOML = true;\n        this.wrapped = null;\n      }\n    };\n    TomlError.wrap = (err) => {\n      const terr = new TomlError(err.message);\n      terr.code = err.code;\n      terr.wrapped = err;\n      return terr;\n    };\n    module.exports.TomlError = TomlError;\n    var createDateTime = require_create_datetime();\n    var createDateTimeFloat = require_create_datetime_float();\n    var createDate = require_create_date();\n    var createTime = require_create_time();\n    var CTRL_I = 9;\n    var CTRL_J = 10;\n    var CTRL_M = 13;\n    var CTRL_CHAR_BOUNDARY = 31;\n    var CHAR_SP = 32;\n    var CHAR_QUOT = 34;\n    var CHAR_NUM = 35;\n    var CHAR_APOS = 39;\n    var CHAR_PLUS = 43;\n    var CHAR_COMMA = 44;\n    var CHAR_HYPHEN = 45;\n    var CHAR_PERIOD = 46;\n    var CHAR_0 = 48;\n    var CHAR_1 = 49;\n    var CHAR_7 = 55;\n    var CHAR_9 = 57;\n    var CHAR_COLON = 58;\n    var CHAR_EQUALS = 61;\n    var CHAR_A = 65;\n    var CHAR_E = 69;\n    var CHAR_F = 70;\n    var CHAR_T = 84;\n    var CHAR_U = 85;\n    var CHAR_Z = 90;\n    var CHAR_LOWBAR = 95;\n    var CHAR_a = 97;\n    var CHAR_b = 98;\n    var CHAR_e = 101;\n    var CHAR_f = 102;\n    var CHAR_i = 105;\n    var CHAR_l = 108;\n    var CHAR_n = 110;\n    var CHAR_o = 111;\n    var CHAR_r = 114;\n    var CHAR_s = 115;\n    var CHAR_t = 116;\n    var CHAR_u = 117;\n    var CHAR_x = 120;\n    var CHAR_z = 122;\n    var CHAR_LCUB = 123;\n    var CHAR_RCUB = 125;\n    var CHAR_LSQB = 91;\n    var CHAR_BSOL = 92;\n    var CHAR_RSQB = 93;\n    var CHAR_DEL = 127;\n    var SURROGATE_FIRST = 55296;\n    var SURROGATE_LAST = 57343;\n    var escapes = {\n      [CHAR_b]: \"\\b\",\n      [CHAR_t]: \"\t\",\n      [CHAR_n]: \"\\n\",\n      [CHAR_f]: \"\\f\",\n      [CHAR_r]: \"\\r\",\n      [CHAR_QUOT]: '\"',\n      [CHAR_BSOL]: \"\\\\\"\n    };\n    function isDigit(cp) {\n      return cp >= CHAR_0 && cp <= CHAR_9;\n    }\n    function isHexit(cp) {\n      return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;\n    }\n    function isBit(cp) {\n      return cp === CHAR_1 || cp === CHAR_0;\n    }\n    function isOctit(cp) {\n      return cp >= CHAR_0 && cp <= CHAR_7;\n    }\n    function isAlphaNumQuoteHyphen(cp) {\n      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;\n    }\n    function isAlphaNumHyphen(cp) {\n      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;\n    }\n    var _type = Symbol(\"type\");\n    var _declared = Symbol(\"declared\");\n    var hasOwnProperty3 = Object.prototype.hasOwnProperty;\n    var defineProperty = Object.defineProperty;\n    var descriptor = { configurable: true, enumerable: true, writable: true, value: void 0 };\n    function hasKey(obj, key2) {\n      if (hasOwnProperty3.call(obj, key2))\n        return true;\n      if (key2 === \"__proto__\")\n        defineProperty(obj, \"__proto__\", descriptor);\n      return false;\n    }\n    var INLINE_TABLE = Symbol(\"inline-table\");\n    function InlineTable() {\n      return Object.defineProperties({}, {\n        [_type]: { value: INLINE_TABLE }\n      });\n    }\n    function isInlineTable(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === INLINE_TABLE;\n    }\n    var TABLE = Symbol(\"table\");\n    function Table() {\n      return Object.defineProperties({}, {\n        [_type]: { value: TABLE },\n        [_declared]: { value: false, writable: true }\n      });\n    }\n    function isTable(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === TABLE;\n    }\n    var _contentType = Symbol(\"content-type\");\n    var INLINE_LIST = Symbol(\"inline-list\");\n    function InlineList(type2) {\n      return Object.defineProperties([], {\n        [_type]: { value: INLINE_LIST },\n        [_contentType]: { value: type2 }\n      });\n    }\n    function isInlineList(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === INLINE_LIST;\n    }\n    var LIST = Symbol(\"list\");\n    function List() {\n      return Object.defineProperties([], {\n        [_type]: { value: LIST }\n      });\n    }\n    function isList(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === LIST;\n    }\n    var _custom;\n    try {\n      const utilInspect = __require(\"util\").inspect;\n      _custom = utilInspect.custom;\n    } catch (_) {\n    }\n    var _inspect = _custom || \"inspect\";\n    var BoxedBigInt = class {\n      constructor(value) {\n        try {\n          this.value = global.BigInt.asIntN(64, value);\n        } catch (_) {\n          this.value = null;\n        }\n        Object.defineProperty(this, _type, { value: INTEGER });\n      }\n      isNaN() {\n        return this.value === null;\n      }\n      /* istanbul ignore next */\n      toString() {\n        return String(this.value);\n      }\n      /* istanbul ignore next */\n      [_inspect]() {\n        return `[BigInt: ${this.toString()}]}`;\n      }\n      valueOf() {\n        return this.value;\n      }\n    };\n    var INTEGER = Symbol(\"integer\");\n    function Integer(value) {\n      let num = Number(value);\n      if (Object.is(num, -0))\n        num = 0;\n      if (global.BigInt && !Number.isSafeInteger(num)) {\n        return new BoxedBigInt(value);\n      } else {\n        return Object.defineProperties(new Number(num), {\n          isNaN: { value: function() {\n            return isNaN(this);\n          } },\n          [_type]: { value: INTEGER },\n          [_inspect]: { value: () => `[Integer: ${value}]` }\n        });\n      }\n    }\n    function isInteger2(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === INTEGER;\n    }\n    var FLOAT = Symbol(\"float\");\n    function Float(value) {\n      return Object.defineProperties(new Number(value), {\n        [_type]: { value: FLOAT },\n        [_inspect]: { value: () => `[Float: ${value}]` }\n      });\n    }\n    function isFloat2(obj) {\n      if (obj === null || typeof obj !== \"object\")\n        return false;\n      return obj[_type] === FLOAT;\n    }\n    function tomlType(value) {\n      const type2 = typeof value;\n      if (type2 === \"object\") {\n        if (value === null)\n          return \"null\";\n        if (value instanceof Date)\n          return \"datetime\";\n        if (_type in value) {\n          switch (value[_type]) {\n            case INLINE_TABLE:\n              return \"inline-table\";\n            case INLINE_LIST:\n              return \"inline-list\";\n            case TABLE:\n              return \"table\";\n            case LIST:\n              return \"list\";\n            case FLOAT:\n              return \"float\";\n            case INTEGER:\n              return \"integer\";\n          }\n        }\n      }\n      return type2;\n    }\n    function makeParserClass(Parser) {\n      class TOMLParser extends Parser {\n        constructor() {\n          super();\n          this.ctx = this.obj = Table();\n        }\n        /* MATCH HELPER */\n        atEndOfWord() {\n          return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();\n        }\n        atEndOfLine() {\n          return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;\n        }\n        parseStart() {\n          if (this.char === Parser.END) {\n            return null;\n          } else if (this.char === CHAR_LSQB) {\n            return this.call(this.parseTableOrList);\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else if (isAlphaNumQuoteHyphen(this.char)) {\n            return this.callNow(this.parseAssignStatement);\n          } else {\n            throw this.error(new TomlError(`Unknown character \"${this.char}\"`));\n          }\n        }\n        // HELPER, this strips any whitespace and comments to the end of the line\n        // then RETURNS. Last state in a production.\n        parseWhitespaceToEOL() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CHAR_NUM) {\n            return this.goto(this.parseComment);\n          } else if (this.char === Parser.END || this.char === CTRL_J) {\n            return this.return();\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expected only whitespace or comments till end of line\"));\n          }\n        }\n        /* ASSIGNMENT: key = value */\n        parseAssignStatement() {\n          return this.callNow(this.parseAssign, this.recordAssignStatement);\n        }\n        recordAssignStatement(kv) {\n          let target = this.ctx;\n          let finalKey = kv.key.pop();\n          for (let kw of kv.key) {\n            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {\n              throw this.error(new TomlError(\"Can't redefine existing key\"));\n            }\n            target = target[kw] = target[kw] || Table();\n          }\n          if (hasKey(target, finalKey)) {\n            throw this.error(new TomlError(\"Can't redefine existing key\"));\n          }\n          if (isInteger2(kv.value) || isFloat2(kv.value)) {\n            target[finalKey] = kv.value.valueOf();\n          } else {\n            target[finalKey] = kv.value;\n          }\n          return this.goto(this.parseWhitespaceToEOL);\n        }\n        /* ASSSIGNMENT expression, key = value possibly inside an inline table */\n        parseAssign() {\n          return this.callNow(this.parseKeyword, this.recordAssignKeyword);\n        }\n        recordAssignKeyword(key2) {\n          if (this.state.resultTable) {\n            this.state.resultTable.push(key2);\n          } else {\n            this.state.resultTable = [key2];\n          }\n          return this.goto(this.parseAssignKeywordPreDot);\n        }\n        parseAssignKeywordPreDot() {\n          if (this.char === CHAR_PERIOD) {\n            return this.next(this.parseAssignKeywordPostDot);\n          } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {\n            return this.goto(this.parseAssignEqual);\n          }\n        }\n        parseAssignKeywordPostDot() {\n          if (this.char !== CHAR_SP && this.char !== CTRL_I) {\n            return this.callNow(this.parseKeyword, this.recordAssignKeyword);\n          }\n        }\n        parseAssignEqual() {\n          if (this.char === CHAR_EQUALS) {\n            return this.next(this.parseAssignPreValue);\n          } else {\n            throw this.error(new TomlError('Invalid character, expected \"=\"'));\n          }\n        }\n        parseAssignPreValue() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseValue, this.recordAssignValue);\n          }\n        }\n        recordAssignValue(value) {\n          return this.returnNow({ key: this.state.resultTable, value });\n        }\n        /* COMMENTS: #...eol */\n        parseComment() {\n          do {\n            if (this.char === Parser.END || this.char === CTRL_J) {\n              return this.return();\n            }\n          } while (this.nextChar());\n        }\n        /* TABLES AND LISTS, [foo] and [[foo]] */\n        parseTableOrList() {\n          if (this.char === CHAR_LSQB) {\n            this.next(this.parseList);\n          } else {\n            return this.goto(this.parseTable);\n          }\n        }\n        /* TABLE [foo.bar.baz] */\n        parseTable() {\n          this.ctx = this.obj;\n          return this.goto(this.parseTableNext);\n        }\n        parseTableNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseKeyword, this.parseTableMore);\n          }\n        }\n        parseTableMore(keyword) {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CHAR_RSQB) {\n            if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {\n              throw this.error(new TomlError(\"Can't redefine existing key\"));\n            } else {\n              this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();\n              this.ctx[_declared] = true;\n            }\n            return this.next(this.parseWhitespaceToEOL);\n          } else if (this.char === CHAR_PERIOD) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx = this.ctx[keyword] = Table();\n            } else if (isTable(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword];\n            } else if (isList(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];\n            } else {\n              throw this.error(new TomlError(\"Can't redefine existing key\"));\n            }\n            return this.next(this.parseTableNext);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expected whitespace, . or ]\"));\n          }\n        }\n        /* LIST [[a.b.c]] */\n        parseList() {\n          this.ctx = this.obj;\n          return this.goto(this.parseListNext);\n        }\n        parseListNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseKeyword, this.parseListMore);\n          }\n        }\n        parseListMore(keyword) {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CHAR_RSQB) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx[keyword] = List();\n            }\n            if (isInlineList(this.ctx[keyword])) {\n              throw this.error(new TomlError(\"Can't extend an inline array\"));\n            } else if (isList(this.ctx[keyword])) {\n              const next = Table();\n              this.ctx[keyword].push(next);\n              this.ctx = next;\n            } else {\n              throw this.error(new TomlError(\"Can't redefine an existing key\"));\n            }\n            return this.next(this.parseListEnd);\n          } else if (this.char === CHAR_PERIOD) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx = this.ctx[keyword] = Table();\n            } else if (isInlineList(this.ctx[keyword])) {\n              throw this.error(new TomlError(\"Can't extend an inline array\"));\n            } else if (isInlineTable(this.ctx[keyword])) {\n              throw this.error(new TomlError(\"Can't extend an inline table\"));\n            } else if (isList(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];\n            } else if (isTable(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword];\n            } else {\n              throw this.error(new TomlError(\"Can't redefine an existing key\"));\n            }\n            return this.next(this.parseListNext);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expected whitespace, . or ]\"));\n          }\n        }\n        parseListEnd(keyword) {\n          if (this.char === CHAR_RSQB) {\n            return this.next(this.parseWhitespaceToEOL);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expected whitespace, . or ]\"));\n          }\n        }\n        /* VALUE string, number, boolean, inline list, inline object */\n        parseValue() {\n          if (this.char === Parser.END) {\n            throw this.error(new TomlError(\"Key without value\"));\n          } else if (this.char === CHAR_QUOT) {\n            return this.next(this.parseDoubleString);\n          }\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseSingleString);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            return this.goto(this.parseNumberSign);\n          } else if (this.char === CHAR_i) {\n            return this.next(this.parseInf);\n          } else if (this.char === CHAR_n) {\n            return this.next(this.parseNan);\n          } else if (isDigit(this.char)) {\n            return this.goto(this.parseNumberOrDateTime);\n          } else if (this.char === CHAR_t || this.char === CHAR_f) {\n            return this.goto(this.parseBoolean);\n          } else if (this.char === CHAR_LSQB) {\n            return this.call(this.parseInlineList, this.recordValue);\n          } else if (this.char === CHAR_LCUB) {\n            return this.call(this.parseInlineTable, this.recordValue);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expecting string, number, datetime, boolean, inline array or inline table\"));\n          }\n        }\n        recordValue(value) {\n          return this.returnNow(value);\n        }\n        parseInf() {\n          if (this.char === CHAR_n) {\n            return this.next(this.parseInf2);\n          } else {\n            throw this.error(new TomlError('Unexpected character, expected \"inf\", \"+inf\" or \"-inf\"'));\n          }\n        }\n        parseInf2() {\n          if (this.char === CHAR_f) {\n            if (this.state.buf === \"-\") {\n              return this.return(-Infinity);\n            } else {\n              return this.return(Infinity);\n            }\n          } else {\n            throw this.error(new TomlError('Unexpected character, expected \"inf\", \"+inf\" or \"-inf\"'));\n          }\n        }\n        parseNan() {\n          if (this.char === CHAR_a) {\n            return this.next(this.parseNan2);\n          } else {\n            throw this.error(new TomlError('Unexpected character, expected \"nan\"'));\n          }\n        }\n        parseNan2() {\n          if (this.char === CHAR_n) {\n            return this.return(NaN);\n          } else {\n            throw this.error(new TomlError('Unexpected character, expected \"nan\"'));\n          }\n        }\n        /* KEYS, barewords or basic, literal, or dotted */\n        parseKeyword() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseBasicString);\n          } else if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralString);\n          } else {\n            return this.goto(this.parseBareKey);\n          }\n        }\n        /* KEYS: barewords */\n        parseBareKey() {\n          do {\n            if (this.char === Parser.END) {\n              throw this.error(new TomlError(\"Key ended without value\"));\n            } else if (isAlphaNumHyphen(this.char)) {\n              this.consume();\n            } else if (this.state.buf.length === 0) {\n              throw this.error(new TomlError(\"Empty bare keys are not allowed\"));\n            } else {\n              return this.returnNow();\n            }\n          } while (this.nextChar());\n        }\n        /* STRINGS, single quoted (literal) */\n        parseSingleString() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiStringMaybe);\n          } else {\n            return this.goto(this.parseLiteralString);\n          }\n        }\n        parseLiteralString() {\n          do {\n            if (this.char === CHAR_APOS) {\n              return this.return();\n            } else if (this.atEndOfLine()) {\n              throw this.error(new TomlError(\"Unterminated string\"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        parseLiteralMultiStringMaybe() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiString);\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseLiteralMultiString() {\n          if (this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CTRL_J) {\n            return this.next(this.parseLiteralMultiStringContent);\n          } else {\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        parseLiteralMultiStringContent() {\n          do {\n            if (this.char === CHAR_APOS) {\n              return this.next(this.parseLiteralMultiEnd);\n            } else if (this.char === Parser.END) {\n              throw this.error(new TomlError(\"Unterminated multi-line string\"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        parseLiteralMultiEnd() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiEnd2);\n          } else {\n            this.state.buf += \"'\";\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        parseLiteralMultiEnd2() {\n          if (this.char === CHAR_APOS) {\n            return this.return();\n          } else {\n            this.state.buf += \"''\";\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        /* STRINGS double quoted */\n        parseDoubleString() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiStringMaybe);\n          } else {\n            return this.goto(this.parseBasicString);\n          }\n        }\n        parseBasicString() {\n          do {\n            if (this.char === CHAR_BSOL) {\n              return this.call(this.parseEscape, this.recordEscapeReplacement);\n            } else if (this.char === CHAR_QUOT) {\n              return this.return();\n            } else if (this.atEndOfLine()) {\n              throw this.error(new TomlError(\"Unterminated string\"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        recordEscapeReplacement(replacement) {\n          this.state.buf += replacement;\n          return this.goto(this.parseBasicString);\n        }\n        parseMultiStringMaybe() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiString);\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseMultiString() {\n          if (this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CTRL_J) {\n            return this.next(this.parseMultiStringContent);\n          } else {\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiStringContent() {\n          do {\n            if (this.char === CHAR_BSOL) {\n              return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);\n            } else if (this.char === CHAR_QUOT) {\n              return this.next(this.parseMultiEnd);\n            } else if (this.char === Parser.END) {\n              throw this.error(new TomlError(\"Unterminated multi-line string\"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        errorControlCharInString() {\n          let displayCode = \"\\\\u00\";\n          if (this.char < 16) {\n            displayCode += \"0\";\n          }\n          displayCode += this.char.toString(16);\n          return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));\n        }\n        recordMultiEscapeReplacement(replacement) {\n          this.state.buf += replacement;\n          return this.goto(this.parseMultiStringContent);\n        }\n        parseMultiEnd() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiEnd2);\n          } else {\n            this.state.buf += '\"';\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiEnd2() {\n          if (this.char === CHAR_QUOT) {\n            return this.return();\n          } else {\n            this.state.buf += '\"\"';\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiEscape() {\n          if (this.char === CTRL_M || this.char === CTRL_J) {\n            return this.next(this.parseMultiTrim);\n          } else if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return this.next(this.parsePreMultiTrim);\n          } else {\n            return this.goto(this.parseEscape);\n          }\n        }\n        parsePreMultiTrim() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CTRL_M || this.char === CTRL_J) {\n            return this.next(this.parseMultiTrim);\n          } else {\n            throw this.error(new TomlError(\"Can't escape whitespace\"));\n          }\n        }\n        parseMultiTrim() {\n          if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseEscape() {\n          if (this.char in escapes) {\n            return this.return(escapes[this.char]);\n          } else if (this.char === CHAR_u) {\n            return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);\n          } else if (this.char === CHAR_U) {\n            return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);\n          } else {\n            throw this.error(new TomlError(\"Unknown escape character: \" + this.char));\n          }\n        }\n        parseUnicodeReturn(char) {\n          try {\n            const codePoint = parseInt(char, 16);\n            if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {\n              throw this.error(new TomlError(\"Invalid unicode, character in range 0xD800 - 0xDFFF is reserved\"));\n            }\n            return this.returnNow(String.fromCodePoint(codePoint));\n          } catch (err) {\n            throw this.error(TomlError.wrap(err));\n          }\n        }\n        parseSmallUnicode() {\n          if (!isHexit(this.char)) {\n            throw this.error(new TomlError(\"Invalid character in unicode sequence, expected hex\"));\n          } else {\n            this.consume();\n            if (this.state.buf.length >= 4)\n              return this.return();\n          }\n        }\n        parseLargeUnicode() {\n          if (!isHexit(this.char)) {\n            throw this.error(new TomlError(\"Invalid character in unicode sequence, expected hex\"));\n          } else {\n            this.consume();\n            if (this.state.buf.length >= 8)\n              return this.return();\n          }\n        }\n        /* NUMBERS */\n        parseNumberSign() {\n          this.consume();\n          return this.next(this.parseMaybeSignedInfOrNan);\n        }\n        parseMaybeSignedInfOrNan() {\n          if (this.char === CHAR_i) {\n            return this.next(this.parseInf);\n          } else if (this.char === CHAR_n) {\n            return this.next(this.parseNan);\n          } else {\n            return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);\n          }\n        }\n        parseNumberIntegerStart() {\n          if (this.char === CHAR_0) {\n            this.consume();\n            return this.next(this.parseNumberIntegerExponentOrDecimal);\n          } else {\n            return this.goto(this.parseNumberInteger);\n          }\n        }\n        parseNumberIntegerExponentOrDecimal() {\n          if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseNumberInteger() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError(\"Invalid number\"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseNoUnder() {\n          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {\n            throw this.error(new TomlError(\"Unexpected character, expected digit\"));\n          } else if (this.atEndOfWord()) {\n            throw this.error(new TomlError(\"Incomplete number\"));\n          }\n          return this.returnNow();\n        }\n        parseNoUnderHexOctBinLiteral() {\n          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {\n            throw this.error(new TomlError(\"Unexpected character, expected digit\"));\n          } else if (this.atEndOfWord()) {\n            throw this.error(new TomlError(\"Incomplete number\"));\n          }\n          return this.returnNow();\n        }\n        parseNumberFloat() {\n          if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else {\n            return this.returnNow(Float(this.state.buf));\n          }\n        }\n        parseNumberExponentSign() {\n          if (isDigit(this.char)) {\n            return this.goto(this.parseNumberExponent);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.call(this.parseNoUnder, this.parseNumberExponent);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character, expected -, + or digit\"));\n          }\n        }\n        parseNumberExponent() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder);\n          } else {\n            return this.returnNow(Float(this.state.buf));\n          }\n        }\n        /* NUMBERS or DATETIMES  */\n        parseNumberOrDateTime() {\n          if (this.char === CHAR_0) {\n            this.consume();\n            return this.next(this.parseNumberBaseOrDateTime);\n          } else {\n            return this.goto(this.parseNumberOrDateTimeOnly);\n          }\n        }\n        parseNumberOrDateTimeOnly() {\n          if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder, this.parseNumberInteger);\n          } else if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length > 4)\n              this.next(this.parseNumberInteger);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (this.char === CHAR_HYPHEN) {\n            return this.goto(this.parseDateTime);\n          } else if (this.char === CHAR_COLON) {\n            return this.goto(this.parseOnlyTimeHour);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseDateTimeOnly() {\n          if (this.state.buf.length < 4) {\n            if (isDigit(this.char)) {\n              return this.consume();\n            } else if (this.char === CHAR_COLON) {\n              return this.goto(this.parseOnlyTimeHour);\n            } else {\n              throw this.error(new TomlError(\"Expected digit while parsing year part of a date\"));\n            }\n          } else {\n            if (this.char === CHAR_HYPHEN) {\n              return this.goto(this.parseDateTime);\n            } else {\n              throw this.error(new TomlError(\"Expected hyphen (-) while parsing year part of date\"));\n            }\n          }\n        }\n        parseNumberBaseOrDateTime() {\n          if (this.char === CHAR_b) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);\n          } else if (this.char === CHAR_o) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);\n          } else if (this.char === CHAR_x) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);\n          } else if (this.char === CHAR_PERIOD) {\n            return this.goto(this.parseNumberInteger);\n          } else if (isDigit(this.char)) {\n            return this.goto(this.parseDateTimeOnly);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseIntegerHex() {\n          if (isHexit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError(\"Invalid number\"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseIntegerOct() {\n          if (isOctit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError(\"Invalid number\"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseIntegerBin() {\n          if (isBit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError(\"Invalid number\"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        /* DATETIME */\n        parseDateTime() {\n          if (this.state.buf.length < 4) {\n            throw this.error(new TomlError(\"Years less than 1000 must be zero padded to four characters\"));\n          }\n          this.state.result = this.state.buf;\n          this.state.buf = \"\";\n          return this.next(this.parseDateMonth);\n        }\n        parseDateMonth() {\n          if (this.char === CHAR_HYPHEN) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError(\"Months less than 10 must be zero padded to two characters\"));\n            }\n            this.state.result += \"-\" + this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseDateDay);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError(\"Incomplete datetime\"));\n          }\n        }\n        parseDateDay() {\n          if (this.char === CHAR_T || this.char === CHAR_SP) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError(\"Days less than 10 must be zero padded to two characters\"));\n            }\n            this.state.result += \"-\" + this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseStartTimeHour);\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDate(this.state.result + \"-\" + this.state.buf));\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError(\"Incomplete datetime\"));\n          }\n        }\n        parseStartTimeHour() {\n          if (this.atEndOfWord()) {\n            return this.returnNow(createDate(this.state.result));\n          } else {\n            return this.goto(this.parseTimeHour);\n          }\n        }\n        parseTimeHour() {\n          if (this.char === CHAR_COLON) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError(\"Hours less than 10 must be zero padded to two characters\"));\n            }\n            this.state.result += \"T\" + this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseTimeMin);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError(\"Incomplete datetime\"));\n          }\n        }\n        parseTimeMin() {\n          if (this.state.buf.length < 2 && isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {\n            this.state.result += \":\" + this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseTimeSec);\n          } else {\n            throw this.error(new TomlError(\"Incomplete datetime\"));\n          }\n        }\n        parseTimeSec() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length === 2) {\n              this.state.result += \":\" + this.state.buf;\n              this.state.buf = \"\";\n              return this.next(this.parseTimeZoneOrFraction);\n            }\n          } else {\n            throw this.error(new TomlError(\"Incomplete datetime\"));\n          }\n        }\n        parseOnlyTimeHour() {\n          if (this.char === CHAR_COLON) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError(\"Hours less than 10 must be zero padded to two characters\"));\n            }\n            this.state.result = this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseOnlyTimeMin);\n          } else {\n            throw this.error(new TomlError(\"Incomplete time\"));\n          }\n        }\n        parseOnlyTimeMin() {\n          if (this.state.buf.length < 2 && isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {\n            this.state.result += \":\" + this.state.buf;\n            this.state.buf = \"\";\n            return this.next(this.parseOnlyTimeSec);\n          } else {\n            throw this.error(new TomlError(\"Incomplete time\"));\n          }\n        }\n        parseOnlyTimeSec() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length === 2) {\n              return this.next(this.parseOnlyTimeFractionMaybe);\n            }\n          } else {\n            throw this.error(new TomlError(\"Incomplete time\"));\n          }\n        }\n        parseOnlyTimeFractionMaybe() {\n          this.state.result += \":\" + this.state.buf;\n          if (this.char === CHAR_PERIOD) {\n            this.state.buf = \"\";\n            this.next(this.parseOnlyTimeFraction);\n          } else {\n            return this.return(createTime(this.state.result));\n          }\n        }\n        parseOnlyTimeFraction() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.atEndOfWord()) {\n            if (this.state.buf.length === 0)\n              throw this.error(new TomlError(\"Expected digit in milliseconds\"));\n            return this.returnNow(createTime(this.state.result + \".\" + this.state.buf));\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z\"));\n          }\n        }\n        parseTimeZoneOrFraction() {\n          if (this.char === CHAR_PERIOD) {\n            this.consume();\n            this.next(this.parseDateTimeFraction);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.next(this.parseTimeZoneHour);\n          } else if (this.char === CHAR_Z) {\n            this.consume();\n            return this.return(createDateTime(this.state.result + this.state.buf));\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z\"));\n          }\n        }\n        parseDateTimeFraction() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 1) {\n            throw this.error(new TomlError(\"Expected digit in milliseconds\"));\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.next(this.parseTimeZoneHour);\n          } else if (this.char === CHAR_Z) {\n            this.consume();\n            return this.return(createDateTime(this.state.result + this.state.buf));\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z\"));\n          }\n        }\n        parseTimeZoneHour() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (/\\d\\d$/.test(this.state.buf))\n              return this.next(this.parseTimeZoneSep);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected digit\"));\n          }\n        }\n        parseTimeZoneSep() {\n          if (this.char === CHAR_COLON) {\n            this.consume();\n            this.next(this.parseTimeZoneMin);\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected colon\"));\n          }\n        }\n        parseTimeZoneMin() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (/\\d\\d$/.test(this.state.buf))\n              return this.return(createDateTime(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError(\"Unexpected character in datetime, expected digit\"));\n          }\n        }\n        /* BOOLEAN */\n        parseBoolean() {\n          if (this.char === CHAR_t) {\n            this.consume();\n            return this.next(this.parseTrue_r);\n          } else if (this.char === CHAR_f) {\n            this.consume();\n            return this.next(this.parseFalse_a);\n          }\n        }\n        parseTrue_r() {\n          if (this.char === CHAR_r) {\n            this.consume();\n            return this.next(this.parseTrue_u);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseTrue_u() {\n          if (this.char === CHAR_u) {\n            this.consume();\n            return this.next(this.parseTrue_e);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseTrue_e() {\n          if (this.char === CHAR_e) {\n            return this.return(true);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseFalse_a() {\n          if (this.char === CHAR_a) {\n            this.consume();\n            return this.next(this.parseFalse_l);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseFalse_l() {\n          if (this.char === CHAR_l) {\n            this.consume();\n            return this.next(this.parseFalse_s);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseFalse_s() {\n          if (this.char === CHAR_s) {\n            this.consume();\n            return this.next(this.parseFalse_e);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        parseFalse_e() {\n          if (this.char === CHAR_e) {\n            return this.return(false);\n          } else {\n            throw this.error(new TomlError(\"Invalid boolean, expected true or false\"));\n          }\n        }\n        /* INLINE LISTS */\n        parseInlineList() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {\n            return null;\n          } else if (this.char === Parser.END) {\n            throw this.error(new TomlError(\"Unterminated inline array\"));\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CHAR_RSQB) {\n            return this.return(this.state.resultArr || InlineList());\n          } else {\n            return this.callNow(this.parseValue, this.recordInlineListValue);\n          }\n        }\n        recordInlineListValue(value) {\n          if (this.state.resultArr) {\n            const listType = this.state.resultArr[_contentType];\n            const valueType = tomlType(value);\n            if (listType !== valueType) {\n              throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));\n            }\n          } else {\n            this.state.resultArr = InlineList(tomlType(value));\n          }\n          if (isFloat2(value) || isInteger2(value)) {\n            this.state.resultArr.push(value.valueOf());\n          } else {\n            this.state.resultArr.push(value);\n          }\n          return this.goto(this.parseInlineListNext);\n        }\n        parseInlineListNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {\n            return null;\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CHAR_COMMA) {\n            return this.next(this.parseInlineList);\n          } else if (this.char === CHAR_RSQB) {\n            return this.goto(this.parseInlineList);\n          } else {\n            throw this.error(new TomlError(\"Invalid character, expected whitespace, comma (,) or close bracket (])\"));\n          }\n        }\n        /* INLINE TABLE */\n        parseInlineTable() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {\n            throw this.error(new TomlError(\"Unterminated inline array\"));\n          } else if (this.char === CHAR_RCUB) {\n            return this.return(this.state.resultTable || InlineTable());\n          } else {\n            if (!this.state.resultTable)\n              this.state.resultTable = InlineTable();\n            return this.callNow(this.parseAssign, this.recordInlineTableValue);\n          }\n        }\n        recordInlineTableValue(kv) {\n          let target = this.state.resultTable;\n          let finalKey = kv.key.pop();\n          for (let kw of kv.key) {\n            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {\n              throw this.error(new TomlError(\"Can't redefine existing key\"));\n            }\n            target = target[kw] = target[kw] || Table();\n          }\n          if (hasKey(target, finalKey)) {\n            throw this.error(new TomlError(\"Can't redefine existing key\"));\n          }\n          if (isInteger2(kv.value) || isFloat2(kv.value)) {\n            target[finalKey] = kv.value.valueOf();\n          } else {\n            target[finalKey] = kv.value;\n          }\n          return this.goto(this.parseInlineTableNext);\n        }\n        parseInlineTableNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {\n            throw this.error(new TomlError(\"Unterminated inline array\"));\n          } else if (this.char === CHAR_COMMA) {\n            return this.next(this.parseInlineTable);\n          } else if (this.char === CHAR_RCUB) {\n            return this.goto(this.parseInlineTable);\n          } else {\n            throw this.error(new TomlError(\"Invalid character, expected whitespace, comma (,) or close bracket (])\"));\n          }\n        }\n      }\n      return TOMLParser;\n    }\n  }\n});\n\n// node_modules/@iarna/toml/parse-pretty-error.js\nvar require_parse_pretty_error = __commonJS({\n  \"node_modules/@iarna/toml/parse-pretty-error.js\"(exports, module) {\n    \"use strict\";\n    module.exports = prettyError;\n    function prettyError(err, buf) {\n      if (err.pos == null || err.line == null)\n        return err;\n      let msg = err.message;\n      msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`;\n      if (buf && buf.split) {\n        const lines = buf.split(/\\n/);\n        const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;\n        let linePadding = \" \";\n        while (linePadding.length < lineNumWidth)\n          linePadding += \" \";\n        for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {\n          let lineNum = String(ii + 1);\n          if (lineNum.length < lineNumWidth)\n            lineNum = \" \" + lineNum;\n          if (err.line === ii) {\n            msg += lineNum + \"> \" + lines[ii] + \"\\n\";\n            msg += linePadding + \"  \";\n            for (let hh = 0; hh < err.col; ++hh) {\n              msg += \" \";\n            }\n            msg += \"^\\n\";\n          } else {\n            msg += lineNum + \": \" + lines[ii] + \"\\n\";\n          }\n        }\n      }\n      err.message = msg + \"\\n\";\n      return err;\n    }\n  }\n});\n\n// node_modules/@iarna/toml/parse-async.js\nvar require_parse_async = __commonJS({\n  \"node_modules/@iarna/toml/parse-async.js\"(exports, module) {\n    \"use strict\";\n    module.exports = parseAsync;\n    var TOMLParser = require_toml_parser();\n    var prettyError = require_parse_pretty_error();\n    function parseAsync(str2, opts) {\n      if (!opts)\n        opts = {};\n      const index = 0;\n      const blocksize = opts.blocksize || 40960;\n      const parser = new TOMLParser();\n      return new Promise((resolve3, reject) => {\n        setImmediate(parseAsyncNext, index, blocksize, resolve3, reject);\n      });\n      function parseAsyncNext(index2, blocksize2, resolve3, reject) {\n        if (index2 >= str2.length) {\n          try {\n            return resolve3(parser.finish());\n          } catch (err) {\n            return reject(prettyError(err, str2));\n          }\n        }\n        try {\n          parser.parse(str2.slice(index2, index2 + blocksize2));\n          setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve3, reject);\n        } catch (err) {\n          reject(prettyError(err, str2));\n        }\n      }\n    }\n  }\n});\n\n// node_modules/js-tokens/index.js\nvar require_js_tokens = __commonJS({\n  \"node_modules/js-tokens/index.js\"(exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = /((['\"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\'\"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g;\n    exports.matchToToken = function(match) {\n      var token2 = { type: \"invalid\", value: match[0], closed: void 0 };\n      if (match[1])\n        token2.type = \"string\", token2.closed = !!(match[3] || match[4]);\n      else if (match[5])\n        token2.type = \"comment\";\n      else if (match[6])\n        token2.type = \"comment\", token2.closed = !!match[7];\n      else if (match[8])\n        token2.type = \"regex\";\n      else if (match[9])\n        token2.type = \"number\";\n      else if (match[10])\n        token2.type = \"name\";\n      else if (match[11])\n        token2.type = \"punctuator\";\n      else if (match[12])\n        token2.type = \"whitespace\";\n      return token2;\n    };\n  }\n});\n\n// node_modules/@babel/helper-validator-identifier/lib/identifier.js\nvar require_identifier = __commonJS({\n  \"node_modules/@babel/helper-validator-identifier/lib/identifier.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.isIdentifierChar = isIdentifierChar;\n    exports.isIdentifierName = isIdentifierName;\n    exports.isIdentifierStart = isIdentifierStart;\n    var nonASCIIidentifierStartChars = \"\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC\";\n    var nonASCIIidentifierChars = \"\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3C\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0CF3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DFF\\u200C\\u200D\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\u30FB\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F\\uFF65\";\n    var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n    var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\n    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n    function isInAstralSet(code, set2) {\n      let pos2 = 65536;\n      for (let i = 0, length = set2.length; i < length; i += 2) {\n        pos2 += set2[i];\n        if (pos2 > code)\n          return false;\n        pos2 += set2[i + 1];\n        if (pos2 >= code)\n          return true;\n      }\n      return false;\n    }\n    function isIdentifierStart(code) {\n      if (code < 65)\n        return code === 36;\n      if (code <= 90)\n        return true;\n      if (code < 97)\n        return code === 95;\n      if (code <= 122)\n        return true;\n      if (code <= 65535) {\n        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));\n      }\n      return isInAstralSet(code, astralIdentifierStartCodes);\n    }\n    function isIdentifierChar(code) {\n      if (code < 48)\n        return code === 36;\n      if (code < 58)\n        return true;\n      if (code < 65)\n        return false;\n      if (code <= 90)\n        return true;\n      if (code < 97)\n        return code === 95;\n      if (code <= 122)\n        return true;\n      if (code <= 65535) {\n        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));\n      }\n      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n    }\n    function isIdentifierName(name) {\n      let isFirst = true;\n      for (let i = 0; i < name.length; i++) {\n        let cp = name.charCodeAt(i);\n        if ((cp & 64512) === 55296 && i + 1 < name.length) {\n          const trail = name.charCodeAt(++i);\n          if ((trail & 64512) === 56320) {\n            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);\n          }\n        }\n        if (isFirst) {\n          isFirst = false;\n          if (!isIdentifierStart(cp)) {\n            return false;\n          }\n        } else if (!isIdentifierChar(cp)) {\n          return false;\n        }\n      }\n      return !isFirst;\n    }\n  }\n});\n\n// node_modules/@babel/helper-validator-identifier/lib/keyword.js\nvar require_keyword = __commonJS({\n  \"node_modules/@babel/helper-validator-identifier/lib/keyword.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.isKeyword = isKeyword;\n    exports.isReservedWord = isReservedWord;\n    exports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\n    exports.isStrictBindReservedWord = isStrictBindReservedWord;\n    exports.isStrictReservedWord = isStrictReservedWord;\n    var reservedWords = {\n      keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n      strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n      strictBind: [\"eval\", \"arguments\"]\n    };\n    var keywords = new Set(reservedWords.keyword);\n    var reservedWordsStrictSet = new Set(reservedWords.strict);\n    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n    function isReservedWord(word, inModule) {\n      return inModule && word === \"await\" || word === \"enum\";\n    }\n    function isStrictReservedWord(word, inModule) {\n      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n    }\n    function isStrictBindOnlyReservedWord(word) {\n      return reservedWordsStrictBindSet.has(word);\n    }\n    function isStrictBindReservedWord(word, inModule) {\n      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n    }\n    function isKeyword(word) {\n      return keywords.has(word);\n    }\n  }\n});\n\n// node_modules/@babel/helper-validator-identifier/lib/index.js\nvar require_lib = __commonJS({\n  \"node_modules/@babel/helper-validator-identifier/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    Object.defineProperty(exports, \"isIdentifierChar\", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierChar;\n      }\n    });\n    Object.defineProperty(exports, \"isIdentifierName\", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierName;\n      }\n    });\n    Object.defineProperty(exports, \"isIdentifierStart\", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierStart;\n      }\n    });\n    Object.defineProperty(exports, \"isKeyword\", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isKeyword;\n      }\n    });\n    Object.defineProperty(exports, \"isReservedWord\", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isReservedWord;\n      }\n    });\n    Object.defineProperty(exports, \"isStrictBindOnlyReservedWord\", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictBindOnlyReservedWord;\n      }\n    });\n    Object.defineProperty(exports, \"isStrictBindReservedWord\", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictBindReservedWord;\n      }\n    });\n    Object.defineProperty(exports, \"isStrictReservedWord\", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictReservedWord;\n      }\n    });\n    var _identifier = require_identifier();\n    var _keyword = require_keyword();\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/escape-string-regexp/index.js\nvar require_escape_string_regexp = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/escape-string-regexp/index.js\"(exports, module) {\n    \"use strict\";\n    var matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n    module.exports = function(str2) {\n      if (typeof str2 !== \"string\") {\n        throw new TypeError(\"Expected a string\");\n      }\n      return str2.replace(matchOperatorsRe, \"\\\\$&\");\n    };\n  }\n});\n\n// node_modules/color-name/index.js\nvar require_color_name = __commonJS({\n  \"node_modules/color-name/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = {\n      \"aliceblue\": [240, 248, 255],\n      \"antiquewhite\": [250, 235, 215],\n      \"aqua\": [0, 255, 255],\n      \"aquamarine\": [127, 255, 212],\n      \"azure\": [240, 255, 255],\n      \"beige\": [245, 245, 220],\n      \"bisque\": [255, 228, 196],\n      \"black\": [0, 0, 0],\n      \"blanchedalmond\": [255, 235, 205],\n      \"blue\": [0, 0, 255],\n      \"blueviolet\": [138, 43, 226],\n      \"brown\": [165, 42, 42],\n      \"burlywood\": [222, 184, 135],\n      \"cadetblue\": [95, 158, 160],\n      \"chartreuse\": [127, 255, 0],\n      \"chocolate\": [210, 105, 30],\n      \"coral\": [255, 127, 80],\n      \"cornflowerblue\": [100, 149, 237],\n      \"cornsilk\": [255, 248, 220],\n      \"crimson\": [220, 20, 60],\n      \"cyan\": [0, 255, 255],\n      \"darkblue\": [0, 0, 139],\n      \"darkcyan\": [0, 139, 139],\n      \"darkgoldenrod\": [184, 134, 11],\n      \"darkgray\": [169, 169, 169],\n      \"darkgreen\": [0, 100, 0],\n      \"darkgrey\": [169, 169, 169],\n      \"darkkhaki\": [189, 183, 107],\n      \"darkmagenta\": [139, 0, 139],\n      \"darkolivegreen\": [85, 107, 47],\n      \"darkorange\": [255, 140, 0],\n      \"darkorchid\": [153, 50, 204],\n      \"darkred\": [139, 0, 0],\n      \"darksalmon\": [233, 150, 122],\n      \"darkseagreen\": [143, 188, 143],\n      \"darkslateblue\": [72, 61, 139],\n      \"darkslategray\": [47, 79, 79],\n      \"darkslategrey\": [47, 79, 79],\n      \"darkturquoise\": [0, 206, 209],\n      \"darkviolet\": [148, 0, 211],\n      \"deeppink\": [255, 20, 147],\n      \"deepskyblue\": [0, 191, 255],\n      \"dimgray\": [105, 105, 105],\n      \"dimgrey\": [105, 105, 105],\n      \"dodgerblue\": [30, 144, 255],\n      \"firebrick\": [178, 34, 34],\n      \"floralwhite\": [255, 250, 240],\n      \"forestgreen\": [34, 139, 34],\n      \"fuchsia\": [255, 0, 255],\n      \"gainsboro\": [220, 220, 220],\n      \"ghostwhite\": [248, 248, 255],\n      \"gold\": [255, 215, 0],\n      \"goldenrod\": [218, 165, 32],\n      \"gray\": [128, 128, 128],\n      \"green\": [0, 128, 0],\n      \"greenyellow\": [173, 255, 47],\n      \"grey\": [128, 128, 128],\n      \"honeydew\": [240, 255, 240],\n      \"hotpink\": [255, 105, 180],\n      \"indianred\": [205, 92, 92],\n      \"indigo\": [75, 0, 130],\n      \"ivory\": [255, 255, 240],\n      \"khaki\": [240, 230, 140],\n      \"lavender\": [230, 230, 250],\n      \"lavenderblush\": [255, 240, 245],\n      \"lawngreen\": [124, 252, 0],\n      \"lemonchiffon\": [255, 250, 205],\n      \"lightblue\": [173, 216, 230],\n      \"lightcoral\": [240, 128, 128],\n      \"lightcyan\": [224, 255, 255],\n      \"lightgoldenrodyellow\": [250, 250, 210],\n      \"lightgray\": [211, 211, 211],\n      \"lightgreen\": [144, 238, 144],\n      \"lightgrey\": [211, 211, 211],\n      \"lightpink\": [255, 182, 193],\n      \"lightsalmon\": [255, 160, 122],\n      \"lightseagreen\": [32, 178, 170],\n      \"lightskyblue\": [135, 206, 250],\n      \"lightslategray\": [119, 136, 153],\n      \"lightslategrey\": [119, 136, 153],\n      \"lightsteelblue\": [176, 196, 222],\n      \"lightyellow\": [255, 255, 224],\n      \"lime\": [0, 255, 0],\n      \"limegreen\": [50, 205, 50],\n      \"linen\": [250, 240, 230],\n      \"magenta\": [255, 0, 255],\n      \"maroon\": [128, 0, 0],\n      \"mediumaquamarine\": [102, 205, 170],\n      \"mediumblue\": [0, 0, 205],\n      \"mediumorchid\": [186, 85, 211],\n      \"mediumpurple\": [147, 112, 219],\n      \"mediumseagreen\": [60, 179, 113],\n      \"mediumslateblue\": [123, 104, 238],\n      \"mediumspringgreen\": [0, 250, 154],\n      \"mediumturquoise\": [72, 209, 204],\n      \"mediumvioletred\": [199, 21, 133],\n      \"midnightblue\": [25, 25, 112],\n      \"mintcream\": [245, 255, 250],\n      \"mistyrose\": [255, 228, 225],\n      \"moccasin\": [255, 228, 181],\n      \"navajowhite\": [255, 222, 173],\n      \"navy\": [0, 0, 128],\n      \"oldlace\": [253, 245, 230],\n      \"olive\": [128, 128, 0],\n      \"olivedrab\": [107, 142, 35],\n      \"orange\": [255, 165, 0],\n      \"orangered\": [255, 69, 0],\n      \"orchid\": [218, 112, 214],\n      \"palegoldenrod\": [238, 232, 170],\n      \"palegreen\": [152, 251, 152],\n      \"paleturquoise\": [175, 238, 238],\n      \"palevioletred\": [219, 112, 147],\n      \"papayawhip\": [255, 239, 213],\n      \"peachpuff\": [255, 218, 185],\n      \"peru\": [205, 133, 63],\n      \"pink\": [255, 192, 203],\n      \"plum\": [221, 160, 221],\n      \"powderblue\": [176, 224, 230],\n      \"purple\": [128, 0, 128],\n      \"rebeccapurple\": [102, 51, 153],\n      \"red\": [255, 0, 0],\n      \"rosybrown\": [188, 143, 143],\n      \"royalblue\": [65, 105, 225],\n      \"saddlebrown\": [139, 69, 19],\n      \"salmon\": [250, 128, 114],\n      \"sandybrown\": [244, 164, 96],\n      \"seagreen\": [46, 139, 87],\n      \"seashell\": [255, 245, 238],\n      \"sienna\": [160, 82, 45],\n      \"silver\": [192, 192, 192],\n      \"skyblue\": [135, 206, 235],\n      \"slateblue\": [106, 90, 205],\n      \"slategray\": [112, 128, 144],\n      \"slategrey\": [112, 128, 144],\n      \"snow\": [255, 250, 250],\n      \"springgreen\": [0, 255, 127],\n      \"steelblue\": [70, 130, 180],\n      \"tan\": [210, 180, 140],\n      \"teal\": [0, 128, 128],\n      \"thistle\": [216, 191, 216],\n      \"tomato\": [255, 99, 71],\n      \"turquoise\": [64, 224, 208],\n      \"violet\": [238, 130, 238],\n      \"wheat\": [245, 222, 179],\n      \"white\": [255, 255, 255],\n      \"whitesmoke\": [245, 245, 245],\n      \"yellow\": [255, 255, 0],\n      \"yellowgreen\": [154, 205, 50]\n    };\n  }\n});\n\n// node_modules/color-convert/conversions.js\nvar require_conversions = __commonJS({\n  \"node_modules/color-convert/conversions.js\"(exports, module) {\n    var cssKeywords = require_color_name();\n    var reverseKeywords = {};\n    for (key2 in cssKeywords) {\n      if (cssKeywords.hasOwnProperty(key2)) {\n        reverseKeywords[cssKeywords[key2]] = key2;\n      }\n    }\n    var key2;\n    var convert = module.exports = {\n      rgb: { channels: 3, labels: \"rgb\" },\n      hsl: { channels: 3, labels: \"hsl\" },\n      hsv: { channels: 3, labels: \"hsv\" },\n      hwb: { channels: 3, labels: \"hwb\" },\n      cmyk: { channels: 4, labels: \"cmyk\" },\n      xyz: { channels: 3, labels: \"xyz\" },\n      lab: { channels: 3, labels: \"lab\" },\n      lch: { channels: 3, labels: \"lch\" },\n      hex: { channels: 1, labels: [\"hex\"] },\n      keyword: { channels: 1, labels: [\"keyword\"] },\n      ansi16: { channels: 1, labels: [\"ansi16\"] },\n      ansi256: { channels: 1, labels: [\"ansi256\"] },\n      hcg: { channels: 3, labels: [\"h\", \"c\", \"g\"] },\n      apple: { channels: 3, labels: [\"r16\", \"g16\", \"b16\"] },\n      gray: { channels: 1, labels: [\"gray\"] }\n    };\n    for (model in convert) {\n      if (convert.hasOwnProperty(model)) {\n        if (!(\"channels\" in convert[model])) {\n          throw new Error(\"missing channels property: \" + model);\n        }\n        if (!(\"labels\" in convert[model])) {\n          throw new Error(\"missing channel labels property: \" + model);\n        }\n        if (convert[model].labels.length !== convert[model].channels) {\n          throw new Error(\"channel and label counts mismatch: \" + model);\n        }\n        channels = convert[model].channels;\n        labels = convert[model].labels;\n        delete convert[model].channels;\n        delete convert[model].labels;\n        Object.defineProperty(convert[model], \"channels\", { value: channels });\n        Object.defineProperty(convert[model], \"labels\", { value: labels });\n      }\n    }\n    var channels;\n    var labels;\n    var model;\n    convert.rgb.hsl = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var l;\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n      h = Math.min(h * 60, 360);\n      if (h < 0) {\n        h += 360;\n      }\n      l = (min + max) / 2;\n      if (max === min) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max + min);\n      } else {\n        s = delta / (2 - max - min);\n      }\n      return [h, s * 100, l * 100];\n    };\n    convert.rgb.hsv = function(rgb) {\n      var rdif;\n      var gdif;\n      var bdif;\n      var h;\n      var s;\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var v = Math.max(r, g, b);\n      var diff = v - Math.min(r, g, b);\n      var diffc = function(c2) {\n        return (v - c2) / 6 / diff + 1 / 2;\n      };\n      if (diff === 0) {\n        h = s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n      return [\n        h * 360,\n        s * 100,\n        v * 100\n      ];\n    };\n    convert.rgb.hwb = function(rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var h = convert.rgb.hsl(rgb)[0];\n      var w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n    convert.rgb.cmyk = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var c2;\n      var m;\n      var y;\n      var k;\n      k = Math.min(1 - r, 1 - g, 1 - b);\n      c2 = (1 - r - k) / (1 - k) || 0;\n      m = (1 - g - k) / (1 - k) || 0;\n      y = (1 - b - k) / (1 - k) || 0;\n      return [c2 * 100, m * 100, y * 100, k * 100];\n    };\n    function comparativeDistance(x, y) {\n      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);\n    }\n    convert.rgb.keyword = function(rgb) {\n      var reversed = reverseKeywords[rgb];\n      if (reversed) {\n        return reversed;\n      }\n      var currentClosestDistance = Infinity;\n      var currentClosestKeyword;\n      for (var keyword in cssKeywords) {\n        if (cssKeywords.hasOwnProperty(keyword)) {\n          var value = cssKeywords[keyword];\n          var distance = comparativeDistance(rgb, value);\n          if (distance < currentClosestDistance) {\n            currentClosestDistance = distance;\n            currentClosestKeyword = keyword;\n          }\n        }\n      }\n      return currentClosestKeyword;\n    };\n    convert.keyword.rgb = function(keyword) {\n      return cssKeywords[keyword];\n    };\n    convert.rgb.xyz = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n    convert.rgb.lab = function(rgb) {\n      var xyz = convert.rgb.xyz(rgb);\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.hsl.rgb = function(hsl) {\n      var h = hsl[0] / 360;\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var t1;\n      var t2;\n      var t3;\n      var rgb;\n      var val;\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n      t1 = 2 * l - t2;\n      rgb = [0, 0, 0];\n      for (var i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n        if (t3 < 0) {\n          t3++;\n        }\n        if (t3 > 1) {\n          t3--;\n        }\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n        rgb[i] = val * 255;\n      }\n      return rgb;\n    };\n    convert.hsl.hsv = function(hsl) {\n      var h = hsl[0];\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var smin = s;\n      var lmin = Math.max(l, 0.01);\n      var sv;\n      var v;\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      v = (l + s) / 2;\n      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n    convert.hsv.rgb = function(hsv) {\n      var h = hsv[0] / 60;\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var hi = Math.floor(h) % 6;\n      var f = h - Math.floor(h);\n      var p = 255 * v * (1 - s);\n      var q = 255 * v * (1 - s * f);\n      var t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n        case 1:\n          return [q, v, p];\n        case 2:\n          return [p, v, t];\n        case 3:\n          return [p, q, v];\n        case 4:\n          return [t, p, v];\n        case 5:\n          return [v, p, q];\n      }\n    };\n    convert.hsv.hsl = function(hsv) {\n      var h = hsv[0];\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var vmin = Math.max(v, 0.01);\n      var lmin;\n      var sl;\n      var l;\n      l = (2 - s) * v;\n      lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    };\n    convert.hwb.rgb = function(hwb) {\n      var h = hwb[0] / 360;\n      var wh = hwb[1] / 100;\n      var bl = hwb[2] / 100;\n      var ratio = wh + bl;\n      var i;\n      var v;\n      var f;\n      var n;\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n      i = Math.floor(6 * h);\n      v = 1 - bl;\n      f = 6 * h - i;\n      if ((i & 1) !== 0) {\n        f = 1 - f;\n      }\n      n = wh + f * (v - wh);\n      var r;\n      var g;\n      var b;\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.cmyk.rgb = function(cmyk) {\n      var c2 = cmyk[0] / 100;\n      var m = cmyk[1] / 100;\n      var y = cmyk[2] / 100;\n      var k = cmyk[3] / 100;\n      var r;\n      var g;\n      var b;\n      r = 1 - Math.min(1, c2 * (1 - k) + k);\n      g = 1 - Math.min(1, m * (1 - k) + k);\n      b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.rgb = function(xyz) {\n      var x = xyz[0] / 100;\n      var y = xyz[1] / 100;\n      var z = xyz[2] / 100;\n      var r;\n      var g;\n      var b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.204 + z * 1.057;\n      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;\n      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;\n      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.lab = function(xyz) {\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.lab.xyz = function(lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var x;\n      var y;\n      var z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      var y2 = Math.pow(y, 3);\n      var x2 = Math.pow(x, 3);\n      var z2 = Math.pow(z, 3);\n      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n    convert.lab.lch = function(lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var hr;\n      var h;\n      var c2;\n      hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n      if (h < 0) {\n        h += 360;\n      }\n      c2 = Math.sqrt(a * a + b * b);\n      return [l, c2, h];\n    };\n    convert.lch.lab = function(lch) {\n      var l = lch[0];\n      var c2 = lch[1];\n      var h = lch[2];\n      var a;\n      var b;\n      var hr;\n      hr = h / 360 * 2 * Math.PI;\n      a = c2 * Math.cos(hr);\n      b = c2 * Math.sin(hr);\n      return [l, a, b];\n    };\n    convert.rgb.ansi16 = function(args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];\n      value = Math.round(value / 50);\n      if (value === 0) {\n        return 30;\n      }\n      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n      if (value === 2) {\n        ansi += 60;\n      }\n      return ansi;\n    };\n    convert.hsv.ansi16 = function(args) {\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n    convert.rgb.ansi256 = function(args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n        if (r > 248) {\n          return 231;\n        }\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n    convert.ansi16.rgb = function(args) {\n      var color = args % 10;\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n      var mult = (~~(args > 50) + 1) * 0.5;\n      var r = (color & 1) * mult * 255;\n      var g = (color >> 1 & 1) * mult * 255;\n      var b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n    convert.ansi256.rgb = function(args) {\n      if (args >= 232) {\n        var c2 = (args - 232) * 10 + 8;\n        return [c2, c2, c2];\n      }\n      args -= 16;\n      var rem;\n      var r = Math.floor(args / 36) / 5 * 255;\n      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      var b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n    convert.rgb.hex = function(args) {\n      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);\n      var string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.hex.rgb = function(args) {\n      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n      if (!match) {\n        return [0, 0, 0];\n      }\n      var colorString = match[0];\n      if (match[0].length === 3) {\n        colorString = colorString.split(\"\").map(function(char) {\n          return char + char;\n        }).join(\"\");\n      }\n      var integer = parseInt(colorString, 16);\n      var r = integer >> 16 & 255;\n      var g = integer >> 8 & 255;\n      var b = integer & 255;\n      return [r, g, b];\n    };\n    convert.rgb.hcg = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var max = Math.max(Math.max(r, g), b);\n      var min = Math.min(Math.min(r, g), b);\n      var chroma = max - min;\n      var grayscale;\n      var hue;\n      if (chroma < 1) {\n        grayscale = min / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma + 4;\n      }\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n    convert.hsl.hcg = function(hsl) {\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var c2 = 1;\n      var f = 0;\n      if (l < 0.5) {\n        c2 = 2 * s * l;\n      } else {\n        c2 = 2 * s * (1 - l);\n      }\n      if (c2 < 1) {\n        f = (l - 0.5 * c2) / (1 - c2);\n      }\n      return [hsl[0], c2 * 100, f * 100];\n    };\n    convert.hsv.hcg = function(hsv) {\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var c2 = s * v;\n      var f = 0;\n      if (c2 < 1) {\n        f = (v - c2) / (1 - c2);\n      }\n      return [hsv[0], c2 * 100, f * 100];\n    };\n    convert.hcg.rgb = function(hcg) {\n      var h = hcg[0] / 360;\n      var c2 = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      if (c2 === 0) {\n        return [g * 255, g * 255, g * 255];\n      }\n      var pure = [0, 0, 0];\n      var hi = h % 1 * 6;\n      var v = hi % 1;\n      var w = 1 - v;\n      var mg = 0;\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n      mg = (1 - c2) * g;\n      return [\n        (c2 * pure[0] + mg) * 255,\n        (c2 * pure[1] + mg) * 255,\n        (c2 * pure[2] + mg) * 255\n      ];\n    };\n    convert.hcg.hsv = function(hcg) {\n      var c2 = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c2 + g * (1 - c2);\n      var f = 0;\n      if (v > 0) {\n        f = c2 / v;\n      }\n      return [hcg[0], f * 100, v * 100];\n    };\n    convert.hcg.hsl = function(hcg) {\n      var c2 = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var l = g * (1 - c2) + 0.5 * c2;\n      var s = 0;\n      if (l > 0 && l < 0.5) {\n        s = c2 / (2 * l);\n      } else if (l >= 0.5 && l < 1) {\n        s = c2 / (2 * (1 - l));\n      }\n      return [hcg[0], s * 100, l * 100];\n    };\n    convert.hcg.hwb = function(hcg) {\n      var c2 = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c2 + g * (1 - c2);\n      return [hcg[0], (v - c2) * 100, (1 - v) * 100];\n    };\n    convert.hwb.hcg = function(hwb) {\n      var w = hwb[1] / 100;\n      var b = hwb[2] / 100;\n      var v = 1 - b;\n      var c2 = v - w;\n      var g = 0;\n      if (c2 < 1) {\n        g = (v - c2) / (1 - c2);\n      }\n      return [hwb[0], c2 * 100, g * 100];\n    };\n    convert.apple.rgb = function(apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n    convert.rgb.apple = function(rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n    convert.gray.rgb = function(args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n    convert.gray.hsl = convert.gray.hsv = function(args) {\n      return [0, 0, args[0]];\n    };\n    convert.gray.hwb = function(gray) {\n      return [0, 100, gray[0]];\n    };\n    convert.gray.cmyk = function(gray) {\n      return [0, 0, 0, gray[0]];\n    };\n    convert.gray.lab = function(gray) {\n      return [gray[0], 0, 0];\n    };\n    convert.gray.hex = function(gray) {\n      var val = Math.round(gray[0] / 100 * 255) & 255;\n      var integer = (val << 16) + (val << 8) + val;\n      var string = integer.toString(16).toUpperCase();\n      return \"000000\".substring(string.length) + string;\n    };\n    convert.rgb.gray = function(rgb) {\n      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  }\n});\n\n// node_modules/color-convert/route.js\nvar require_route = __commonJS({\n  \"node_modules/color-convert/route.js\"(exports, module) {\n    var conversions = require_conversions();\n    function buildGraph() {\n      var graph = {};\n      var models = Object.keys(conversions);\n      for (var len = models.length, i = 0; i < len; i++) {\n        graph[models[i]] = {\n          // http://jsperf.com/1-vs-infinity\n          // micro-opt, but this is simple.\n          distance: -1,\n          parent: null\n        };\n      }\n      return graph;\n    }\n    function deriveBFS(fromModel) {\n      var graph = buildGraph();\n      var queue = [fromModel];\n      graph[fromModel].distance = 0;\n      while (queue.length) {\n        var current = queue.pop();\n        var adjacents = Object.keys(conversions[current]);\n        for (var len = adjacents.length, i = 0; i < len; i++) {\n          var adjacent = adjacents[i];\n          var node = graph[adjacent];\n          if (node.distance === -1) {\n            node.distance = graph[current].distance + 1;\n            node.parent = current;\n            queue.unshift(adjacent);\n          }\n        }\n      }\n      return graph;\n    }\n    function link(from, to) {\n      return function(args) {\n        return to(from(args));\n      };\n    }\n    function wrapConversion(toModel, graph) {\n      var path13 = [graph[toModel].parent, toModel];\n      var fn = conversions[graph[toModel].parent][toModel];\n      var cur = graph[toModel].parent;\n      while (graph[cur].parent) {\n        path13.unshift(graph[cur].parent);\n        fn = link(conversions[graph[cur].parent][cur], fn);\n        cur = graph[cur].parent;\n      }\n      fn.conversion = path13;\n      return fn;\n    }\n    module.exports = function(fromModel) {\n      var graph = deriveBFS(fromModel);\n      var conversion = {};\n      var models = Object.keys(graph);\n      for (var len = models.length, i = 0; i < len; i++) {\n        var toModel = models[i];\n        var node = graph[toModel];\n        if (node.parent === null) {\n          continue;\n        }\n        conversion[toModel] = wrapConversion(toModel, graph);\n      }\n      return conversion;\n    };\n  }\n});\n\n// node_modules/color-convert/index.js\nvar require_color_convert = __commonJS({\n  \"node_modules/color-convert/index.js\"(exports, module) {\n    var conversions = require_conversions();\n    var route = require_route();\n    var convert = {};\n    var models = Object.keys(conversions);\n    function wrapRaw(fn) {\n      var wrappedFn = function(args) {\n        if (args === void 0 || args === null) {\n          return args;\n        }\n        if (arguments.length > 1) {\n          args = Array.prototype.slice.call(arguments);\n        }\n        return fn(args);\n      };\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    function wrapRounded(fn) {\n      var wrappedFn = function(args) {\n        if (args === void 0 || args === null) {\n          return args;\n        }\n        if (arguments.length > 1) {\n          args = Array.prototype.slice.call(arguments);\n        }\n        var result = fn(args);\n        if (typeof result === \"object\") {\n          for (var len = result.length, i = 0; i < len; i++) {\n            result[i] = Math.round(result[i]);\n          }\n        }\n        return result;\n      };\n      if (\"conversion\" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    models.forEach(function(fromModel) {\n      convert[fromModel] = {};\n      Object.defineProperty(convert[fromModel], \"channels\", { value: conversions[fromModel].channels });\n      Object.defineProperty(convert[fromModel], \"labels\", { value: conversions[fromModel].labels });\n      var routes = route(fromModel);\n      var routeModels = Object.keys(routes);\n      routeModels.forEach(function(toModel) {\n        var fn = routes[toModel];\n        convert[fromModel][toModel] = wrapRounded(fn);\n        convert[fromModel][toModel].raw = wrapRaw(fn);\n      });\n    });\n    module.exports = convert;\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/ansi-styles/index.js\nvar require_ansi_styles = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/ansi-styles/index.js\"(exports, module) {\n    \"use strict\";\n    var colorConvert = require_color_convert();\n    var wrapAnsi162 = (fn, offset) => function() {\n      const code = fn.apply(colorConvert, arguments);\n      return `\\x1B[${code + offset}m`;\n    };\n    var wrapAnsi2562 = (fn, offset) => function() {\n      const code = fn.apply(colorConvert, arguments);\n      return `\\x1B[${38 + offset};5;${code}m`;\n    };\n    var wrapAnsi16m2 = (fn, offset) => function() {\n      const rgb = fn.apply(colorConvert, arguments);\n      return `\\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n    };\n    function assembleStyles2() {\n      const codes2 = /* @__PURE__ */ new Map();\n      const styles3 = {\n        modifier: {\n          reset: [0, 0],\n          // 21 isn't widely supported and 22 does the same thing\n          bold: [1, 22],\n          dim: [2, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          hidden: [8, 28],\n          strikethrough: [9, 29]\n        },\n        color: {\n          black: [30, 39],\n          red: [31, 39],\n          green: [32, 39],\n          yellow: [33, 39],\n          blue: [34, 39],\n          magenta: [35, 39],\n          cyan: [36, 39],\n          white: [37, 39],\n          gray: [90, 39],\n          // Bright color\n          redBright: [91, 39],\n          greenBright: [92, 39],\n          yellowBright: [93, 39],\n          blueBright: [94, 39],\n          magentaBright: [95, 39],\n          cyanBright: [96, 39],\n          whiteBright: [97, 39]\n        },\n        bgColor: {\n          bgBlack: [40, 49],\n          bgRed: [41, 49],\n          bgGreen: [42, 49],\n          bgYellow: [43, 49],\n          bgBlue: [44, 49],\n          bgMagenta: [45, 49],\n          bgCyan: [46, 49],\n          bgWhite: [47, 49],\n          // Bright color\n          bgBlackBright: [100, 49],\n          bgRedBright: [101, 49],\n          bgGreenBright: [102, 49],\n          bgYellowBright: [103, 49],\n          bgBlueBright: [104, 49],\n          bgMagentaBright: [105, 49],\n          bgCyanBright: [106, 49],\n          bgWhiteBright: [107, 49]\n        }\n      };\n      styles3.color.grey = styles3.color.gray;\n      for (const groupName of Object.keys(styles3)) {\n        const group = styles3[groupName];\n        for (const styleName of Object.keys(group)) {\n          const style = group[styleName];\n          styles3[styleName] = {\n            open: `\\x1B[${style[0]}m`,\n            close: `\\x1B[${style[1]}m`\n          };\n          group[styleName] = styles3[styleName];\n          codes2.set(style[0], style[1]);\n        }\n        Object.defineProperty(styles3, groupName, {\n          value: group,\n          enumerable: false\n        });\n        Object.defineProperty(styles3, \"codes\", {\n          value: codes2,\n          enumerable: false\n        });\n      }\n      const ansi2ansi = (n) => n;\n      const rgb2rgb = (r, g, b) => [r, g, b];\n      styles3.color.close = \"\\x1B[39m\";\n      styles3.bgColor.close = \"\\x1B[49m\";\n      styles3.color.ansi = {\n        ansi: wrapAnsi162(ansi2ansi, 0)\n      };\n      styles3.color.ansi256 = {\n        ansi256: wrapAnsi2562(ansi2ansi, 0)\n      };\n      styles3.color.ansi16m = {\n        rgb: wrapAnsi16m2(rgb2rgb, 0)\n      };\n      styles3.bgColor.ansi = {\n        ansi: wrapAnsi162(ansi2ansi, 10)\n      };\n      styles3.bgColor.ansi256 = {\n        ansi256: wrapAnsi2562(ansi2ansi, 10)\n      };\n      styles3.bgColor.ansi16m = {\n        rgb: wrapAnsi16m2(rgb2rgb, 10)\n      };\n      for (let key2 of Object.keys(colorConvert)) {\n        if (typeof colorConvert[key2] !== \"object\") {\n          continue;\n        }\n        const suite = colorConvert[key2];\n        if (key2 === \"ansi16\") {\n          key2 = \"ansi\";\n        }\n        if (\"ansi16\" in suite) {\n          styles3.color.ansi[key2] = wrapAnsi162(suite.ansi16, 0);\n          styles3.bgColor.ansi[key2] = wrapAnsi162(suite.ansi16, 10);\n        }\n        if (\"ansi256\" in suite) {\n          styles3.color.ansi256[key2] = wrapAnsi2562(suite.ansi256, 0);\n          styles3.bgColor.ansi256[key2] = wrapAnsi2562(suite.ansi256, 10);\n        }\n        if (\"rgb\" in suite) {\n          styles3.color.ansi16m[key2] = wrapAnsi16m2(suite.rgb, 0);\n          styles3.bgColor.ansi16m[key2] = wrapAnsi16m2(suite.rgb, 10);\n        }\n      }\n      return styles3;\n    }\n    Object.defineProperty(module, \"exports\", {\n      enumerable: true,\n      get: assembleStyles2\n    });\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/has-flag/index.js\nvar require_has_flag = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/has-flag/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = (flag, argv) => {\n      argv = argv || process.argv;\n      const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n      const pos2 = argv.indexOf(prefix + flag);\n      const terminatorPos = argv.indexOf(\"--\");\n      return pos2 !== -1 && (terminatorPos === -1 ? true : pos2 < terminatorPos);\n    };\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/supports-color/index.js\nvar require_supports_color = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/supports-color/index.js\"(exports, module) {\n    \"use strict\";\n    var os2 = __require(\"os\");\n    var hasFlag2 = require_has_flag();\n    var env2 = process.env;\n    var forceColor;\n    if (hasFlag2(\"no-color\") || hasFlag2(\"no-colors\") || hasFlag2(\"color=false\")) {\n      forceColor = false;\n    } else if (hasFlag2(\"color\") || hasFlag2(\"colors\") || hasFlag2(\"color=true\") || hasFlag2(\"color=always\")) {\n      forceColor = true;\n    }\n    if (\"FORCE_COLOR\" in env2) {\n      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;\n    }\n    function translateLevel2(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    function supportsColor2(stream) {\n      if (forceColor === false) {\n        return 0;\n      }\n      if (hasFlag2(\"color=16m\") || hasFlag2(\"color=full\") || hasFlag2(\"color=truecolor\")) {\n        return 3;\n      }\n      if (hasFlag2(\"color=256\")) {\n        return 2;\n      }\n      if (stream && !stream.isTTY && forceColor !== true) {\n        return 0;\n      }\n      const min = forceColor ? 1 : 0;\n      if (process.platform === \"win32\") {\n        const osRelease = os2.release().split(\".\");\n        if (Number(process.versions.node.split(\".\")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if (\"CI\" in env2) {\n        if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\"].some((sign2) => sign2 in env2) || env2.CI_NAME === \"codeship\") {\n          return 1;\n        }\n        return min;\n      }\n      if (\"TEAMCITY_VERSION\" in env2) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env2.COLORTERM === \"truecolor\") {\n        return 3;\n      }\n      if (\"TERM_PROGRAM\" in env2) {\n        const version = parseInt((env2.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n        switch (env2.TERM_PROGRAM) {\n          case \"iTerm.app\":\n            return version >= 3 ? 3 : 2;\n          case \"Apple_Terminal\":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env2.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {\n        return 1;\n      }\n      if (\"COLORTERM\" in env2) {\n        return 1;\n      }\n      if (env2.TERM === \"dumb\") {\n        return min;\n      }\n      return min;\n    }\n    function getSupportLevel(stream) {\n      const level = supportsColor2(stream);\n      return translateLevel2(level);\n    }\n    module.exports = {\n      supportsColor: getSupportLevel,\n      stdout: getSupportLevel(process.stdout),\n      stderr: getSupportLevel(process.stderr)\n    };\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/chalk/templates.js\nvar require_templates = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/chalk/templates.js\"(exports, module) {\n    \"use strict\";\n    var TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n    var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n    var STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n    var ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n    var ESCAPES = /* @__PURE__ */ new Map([\n      [\"n\", \"\\n\"],\n      [\"r\", \"\\r\"],\n      [\"t\", \"\t\"],\n      [\"b\", \"\\b\"],\n      [\"f\", \"\\f\"],\n      [\"v\", \"\\v\"],\n      [\"0\", \"\\0\"],\n      [\"\\\\\", \"\\\\\"],\n      [\"e\", \"\\x1B\"],\n      [\"a\", \"\\x07\"]\n    ]);\n    function unescape(c2) {\n      if (c2[0] === \"u\" && c2.length === 5 || c2[0] === \"x\" && c2.length === 3) {\n        return String.fromCharCode(parseInt(c2.slice(1), 16));\n      }\n      return ESCAPES.get(c2) || c2;\n    }\n    function parseArguments(name, args) {\n      const results = [];\n      const chunks = args.trim().split(/\\s*,\\s*/g);\n      let matches;\n      for (const chunk of chunks) {\n        if (!isNaN(chunk)) {\n          results.push(Number(chunk));\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, chr) => escape2 ? unescape(escape2) : chr));\n        } else {\n          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n        }\n      }\n      return results;\n    }\n    function parseStyle(style) {\n      STYLE_REGEX.lastIndex = 0;\n      const results = [];\n      let matches;\n      while ((matches = STYLE_REGEX.exec(style)) !== null) {\n        const name = matches[1];\n        if (matches[2]) {\n          const args = parseArguments(name, matches[2]);\n          results.push([name].concat(args));\n        } else {\n          results.push([name]);\n        }\n      }\n      return results;\n    }\n    function buildStyle(chalk2, styles3) {\n      const enabled = {};\n      for (const layer of styles3) {\n        for (const style of layer.styles) {\n          enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n      }\n      let current = chalk2;\n      for (const styleName of Object.keys(enabled)) {\n        if (Array.isArray(enabled[styleName])) {\n          if (!(styleName in current)) {\n            throw new Error(`Unknown Chalk style: ${styleName}`);\n          }\n          if (enabled[styleName].length > 0) {\n            current = current[styleName].apply(current, enabled[styleName]);\n          } else {\n            current = current[styleName];\n          }\n        }\n      }\n      return current;\n    }\n    module.exports = (chalk2, tmp) => {\n      const styles3 = [];\n      const chunks = [];\n      let chunk = [];\n      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n        if (escapeChar) {\n          chunk.push(unescape(escapeChar));\n        } else if (style) {\n          const str2 = chunk.join(\"\");\n          chunk = [];\n          chunks.push(styles3.length === 0 ? str2 : buildStyle(chalk2, styles3)(str2));\n          styles3.push({ inverse, styles: parseStyle(style) });\n        } else if (close) {\n          if (styles3.length === 0) {\n            throw new Error(\"Found extraneous } in Chalk template literal\");\n          }\n          chunks.push(buildStyle(chalk2, styles3)(chunk.join(\"\")));\n          chunk = [];\n          styles3.pop();\n        } else {\n          chunk.push(chr);\n        }\n      });\n      chunks.push(chunk.join(\"\"));\n      if (styles3.length > 0) {\n        const errMsg = `Chalk template literal is missing ${styles3.length} closing bracket${styles3.length === 1 ? \"\" : \"s\"} (\\`}\\`)`;\n        throw new Error(errMsg);\n      }\n      return chunks.join(\"\");\n    };\n  }\n});\n\n// node_modules/@babel/code-frame/node_modules/chalk/index.js\nvar require_chalk = __commonJS({\n  \"node_modules/@babel/code-frame/node_modules/chalk/index.js\"(exports, module) {\n    \"use strict\";\n    var escapeStringRegexp2 = require_escape_string_regexp();\n    var ansiStyles2 = require_ansi_styles();\n    var stdoutColor2 = require_supports_color().stdout;\n    var template = require_templates();\n    var isSimpleWindowsTerm = process.platform === \"win32\" && !(process.env.TERM || \"\").toLowerCase().startsWith(\"xterm\");\n    var levelMapping2 = [\"ansi\", \"ansi\", \"ansi256\", \"ansi16m\"];\n    var skipModels = /* @__PURE__ */ new Set([\"gray\"]);\n    var styles3 = /* @__PURE__ */ Object.create(null);\n    function applyOptions2(obj, options8) {\n      options8 = options8 || {};\n      const scLevel = stdoutColor2 ? stdoutColor2.level : 0;\n      obj.level = options8.level === void 0 ? scLevel : options8.level;\n      obj.enabled = \"enabled\" in options8 ? options8.enabled : obj.level > 0;\n    }\n    function Chalk(options8) {\n      if (!this || !(this instanceof Chalk) || this.template) {\n        const chalk2 = {};\n        applyOptions2(chalk2, options8);\n        chalk2.template = function() {\n          const args = [].slice.call(arguments);\n          return chalkTag.apply(null, [chalk2.template].concat(args));\n        };\n        Object.setPrototypeOf(chalk2, Chalk.prototype);\n        Object.setPrototypeOf(chalk2.template, chalk2);\n        chalk2.template.constructor = Chalk;\n        return chalk2.template;\n      }\n      applyOptions2(this, options8);\n    }\n    if (isSimpleWindowsTerm) {\n      ansiStyles2.blue.open = \"\\x1B[94m\";\n    }\n    for (const key2 of Object.keys(ansiStyles2)) {\n      ansiStyles2[key2].closeRe = new RegExp(escapeStringRegexp2(ansiStyles2[key2].close), \"g\");\n      styles3[key2] = {\n        get() {\n          const codes2 = ansiStyles2[key2];\n          return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, key2);\n        }\n      };\n    }\n    styles3.visible = {\n      get() {\n        return build.call(this, this._styles || [], true, \"visible\");\n      }\n    };\n    ansiStyles2.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.color.close), \"g\");\n    for (const model of Object.keys(ansiStyles2.color.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      styles3[model] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles2.color[levelMapping2[level]][model].apply(null, arguments);\n            const codes2 = {\n              open,\n              close: ansiStyles2.color.close,\n              closeRe: ansiStyles2.color.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);\n          };\n        }\n      };\n    }\n    ansiStyles2.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles2.bgColor.close), \"g\");\n    for (const model of Object.keys(ansiStyles2.bgColor.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);\n      styles3[bgModel] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles2.bgColor[levelMapping2[level]][model].apply(null, arguments);\n            const codes2 = {\n              open,\n              close: ansiStyles2.bgColor.close,\n              closeRe: ansiStyles2.bgColor.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes2) : [codes2], this._empty, model);\n          };\n        }\n      };\n    }\n    var proto2 = Object.defineProperties(() => {\n    }, styles3);\n    function build(_styles, _empty, key2) {\n      const builder = function() {\n        return applyStyle2.apply(builder, arguments);\n      };\n      builder._styles = _styles;\n      builder._empty = _empty;\n      const self = this;\n      Object.defineProperty(builder, \"level\", {\n        enumerable: true,\n        get() {\n          return self.level;\n        },\n        set(level) {\n          self.level = level;\n        }\n      });\n      Object.defineProperty(builder, \"enabled\", {\n        enumerable: true,\n        get() {\n          return self.enabled;\n        },\n        set(enabled) {\n          self.enabled = enabled;\n        }\n      });\n      builder.hasGrey = this.hasGrey || key2 === \"gray\" || key2 === \"grey\";\n      builder.__proto__ = proto2;\n      return builder;\n    }\n    function applyStyle2() {\n      const args = arguments;\n      const argsLen = args.length;\n      let str2 = String(arguments[0]);\n      if (argsLen === 0) {\n        return \"\";\n      }\n      if (argsLen > 1) {\n        for (let a = 1; a < argsLen; a++) {\n          str2 += \" \" + args[a];\n        }\n      }\n      if (!this.enabled || this.level <= 0 || !str2) {\n        return this._empty ? \"\" : str2;\n      }\n      const originalDim = ansiStyles2.dim.open;\n      if (isSimpleWindowsTerm && this.hasGrey) {\n        ansiStyles2.dim.open = \"\";\n      }\n      for (const code of this._styles.slice().reverse()) {\n        str2 = code.open + str2.replace(code.closeRe, code.open) + code.close;\n        str2 = str2.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n      }\n      ansiStyles2.dim.open = originalDim;\n      return str2;\n    }\n    function chalkTag(chalk2, strings) {\n      if (!Array.isArray(strings)) {\n        return [].slice.call(arguments, 1).join(\" \");\n      }\n      const args = [].slice.call(arguments, 2);\n      const parts = [strings.raw[0]];\n      for (let i = 1; i < strings.length; i++) {\n        parts.push(String(args[i - 1]).replace(/[{}\\\\]/g, \"\\\\$&\"));\n        parts.push(String(strings.raw[i]));\n      }\n      return template(chalk2, parts.join(\"\"));\n    }\n    Object.defineProperties(Chalk.prototype, styles3);\n    module.exports = Chalk();\n    module.exports.supportsColor = stdoutColor2;\n    module.exports.default = module.exports;\n  }\n});\n\n// node_modules/@babel/highlight/lib/index.js\nvar require_lib2 = __commonJS({\n  \"node_modules/@babel/highlight/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = highlight;\n    exports.shouldHighlight = shouldHighlight;\n    var _jsTokens = require_js_tokens();\n    var _helperValidatorIdentifier = require_lib();\n    var _chalk = _interopRequireWildcard(require_chalk(), true);\n    function _getRequireWildcardCache(e) {\n      if (\"function\" != typeof WeakMap)\n        return null;\n      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function(e2) {\n        return e2 ? t : r;\n      })(e);\n    }\n    function _interopRequireWildcard(e, r) {\n      if (!r && e && e.__esModule)\n        return e;\n      if (null === e || \"object\" != typeof e && \"function\" != typeof e)\n        return { default: e };\n      var t = _getRequireWildcardCache(r);\n      if (t && t.has(e))\n        return t.get(e);\n      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var u in e)\n        if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n        }\n      return n.default = e, t && t.set(e, n), n;\n    }\n    var sometimesKeywords = /* @__PURE__ */ new Set([\"as\", \"async\", \"from\", \"get\", \"of\", \"set\"]);\n    function getDefs(chalk2) {\n      return {\n        keyword: chalk2.cyan,\n        capitalized: chalk2.yellow,\n        jsxIdentifier: chalk2.yellow,\n        punctuator: chalk2.yellow,\n        number: chalk2.magenta,\n        string: chalk2.green,\n        regex: chalk2.magenta,\n        comment: chalk2.grey,\n        invalid: chalk2.white.bgRed.bold\n      };\n    }\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n    var BRACKET = /^[()[\\]{}]$/;\n    var tokenize;\n    {\n      const JSX_TAG = /^[a-z][\\w-]*$/i;\n      const getTokenType = function(token2, offset, text) {\n        if (token2.type === \"name\") {\n          if ((0, _helperValidatorIdentifier.isKeyword)(token2.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token2.value, true) || sometimesKeywords.has(token2.value)) {\n            return \"keyword\";\n          }\n          if (JSX_TAG.test(token2.value) && (text[offset - 1] === \"<\" || text.slice(offset - 2, offset) == \"</\")) {\n            return \"jsxIdentifier\";\n          }\n          if (token2.value[0] !== token2.value[0].toLowerCase()) {\n            return \"capitalized\";\n          }\n        }\n        if (token2.type === \"punctuator\" && BRACKET.test(token2.value)) {\n          return \"bracket\";\n        }\n        if (token2.type === \"invalid\" && (token2.value === \"@\" || token2.value === \"#\")) {\n          return \"punctuator\";\n        }\n        return token2.type;\n      };\n      tokenize = function* (text) {\n        let match;\n        while (match = _jsTokens.default.exec(text)) {\n          const token2 = _jsTokens.matchToToken(match);\n          yield {\n            type: getTokenType(token2, match.index, text),\n            value: token2.value\n          };\n        }\n      };\n    }\n    function highlightTokens(defs, text) {\n      let highlighted = \"\";\n      for (const {\n        type: type2,\n        value\n      } of tokenize(text)) {\n        const colorize = defs[type2];\n        if (colorize) {\n          highlighted += value.split(NEWLINE).map((str2) => colorize(str2)).join(\"\\n\");\n        } else {\n          highlighted += value;\n        }\n      }\n      return highlighted;\n    }\n    function shouldHighlight(options8) {\n      return _chalk.default.level > 0 || options8.forceColor;\n    }\n    var chalkWithForcedColor = void 0;\n    function getChalk(forceColor) {\n      if (forceColor) {\n        var _chalkWithForcedColor;\n        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({\n          enabled: true,\n          level: 1\n        });\n        return chalkWithForcedColor;\n      }\n      return _chalk.default;\n    }\n    {\n      exports.getChalk = (options8) => getChalk(options8.forceColor);\n    }\n    function highlight(code, options8 = {}) {\n      if (code !== \"\" && shouldHighlight(options8)) {\n        const defs = getDefs(getChalk(options8.forceColor));\n        return highlightTokens(defs, code);\n      } else {\n        return code;\n      }\n    }\n  }\n});\n\n// node_modules/@babel/code-frame/lib/index.js\nvar require_lib3 = __commonJS({\n  \"node_modules/@babel/code-frame/lib/index.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.codeFrameColumns = codeFrameColumns3;\n    exports.default = _default2;\n    var _highlight = require_lib2();\n    var _chalk = _interopRequireWildcard(require_chalk(), true);\n    function _getRequireWildcardCache(e) {\n      if (\"function\" != typeof WeakMap)\n        return null;\n      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();\n      return (_getRequireWildcardCache = function(e2) {\n        return e2 ? t : r;\n      })(e);\n    }\n    function _interopRequireWildcard(e, r) {\n      if (!r && e && e.__esModule)\n        return e;\n      if (null === e || \"object\" != typeof e && \"function\" != typeof e)\n        return { default: e };\n      var t = _getRequireWildcardCache(r);\n      if (t && t.has(e))\n        return t.get(e);\n      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n      for (var u in e)\n        if (\"default\" !== u && Object.prototype.hasOwnProperty.call(e, u)) {\n          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n        }\n      return n.default = e, t && t.set(e, n), n;\n    }\n    var chalkWithForcedColor = void 0;\n    function getChalk(forceColor) {\n      if (forceColor) {\n        var _chalkWithForcedColor;\n        (_chalkWithForcedColor = chalkWithForcedColor) != null ? _chalkWithForcedColor : chalkWithForcedColor = new _chalk.default.constructor({\n          enabled: true,\n          level: 1\n        });\n        return chalkWithForcedColor;\n      }\n      return _chalk.default;\n    }\n    var deprecationWarningShown = false;\n    function getDefs(chalk2) {\n      return {\n        gutter: chalk2.grey,\n        marker: chalk2.red.bold,\n        message: chalk2.red.bold\n      };\n    }\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n    function getMarkerLines(loc, source2, opts) {\n      const startLoc = Object.assign({\n        column: 0,\n        line: -1\n      }, loc.start);\n      const endLoc = Object.assign({}, startLoc, loc.end);\n      const {\n        linesAbove = 2,\n        linesBelow = 3\n      } = opts || {};\n      const startLine = startLoc.line;\n      const startColumn = startLoc.column;\n      const endLine = endLoc.line;\n      const endColumn = endLoc.column;\n      let start = Math.max(startLine - (linesAbove + 1), 0);\n      let end = Math.min(source2.length, endLine + linesBelow);\n      if (startLine === -1) {\n        start = 0;\n      }\n      if (endLine === -1) {\n        end = source2.length;\n      }\n      const lineDiff = endLine - startLine;\n      const markerLines = {};\n      if (lineDiff) {\n        for (let i = 0; i <= lineDiff; i++) {\n          const lineNumber = i + startLine;\n          if (!startColumn) {\n            markerLines[lineNumber] = true;\n          } else if (i === 0) {\n            const sourceLength = source2[lineNumber - 1].length;\n            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n          } else if (i === lineDiff) {\n            markerLines[lineNumber] = [0, endColumn];\n          } else {\n            const sourceLength = source2[lineNumber - i].length;\n            markerLines[lineNumber] = [0, sourceLength];\n          }\n        }\n      } else {\n        if (startColumn === endColumn) {\n          if (startColumn) {\n            markerLines[startLine] = [startColumn, 0];\n          } else {\n            markerLines[startLine] = true;\n          }\n        } else {\n          markerLines[startLine] = [startColumn, endColumn - startColumn];\n        }\n      }\n      return {\n        start,\n        end,\n        markerLines\n      };\n    }\n    function codeFrameColumns3(rawLines, loc, opts = {}) {\n      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);\n      const chalk2 = getChalk(opts.forceColor);\n      const defs = getDefs(chalk2);\n      const maybeHighlight = (chalkFn, string) => {\n        return highlighted ? chalkFn(string) : string;\n      };\n      const lines = rawLines.split(NEWLINE);\n      const {\n        start,\n        end,\n        markerLines\n      } = getMarkerLines(loc, lines, opts);\n      const hasColumns = loc.start && typeof loc.start.column === \"number\";\n      const numberMaxWidth = String(end).length;\n      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;\n      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line3, index) => {\n        const number = start + 1 + index;\n        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n        const gutter = ` ${paddedNumber} |`;\n        const hasMarker = markerLines[number];\n        const lastMarkerLine = !markerLines[number + 1];\n        if (hasMarker) {\n          let markerLine = \"\";\n          if (Array.isArray(hasMarker)) {\n            const markerSpacing = line3.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, \" \");\n            const numberOfMarkers = hasMarker[1] || 1;\n            markerLine = [\"\\n \", maybeHighlight(defs.gutter, gutter.replace(/\\d/g, \" \")), \" \", markerSpacing, maybeHighlight(defs.marker, \"^\").repeat(numberOfMarkers)].join(\"\");\n            if (lastMarkerLine && opts.message) {\n              markerLine += \" \" + maybeHighlight(defs.message, opts.message);\n            }\n          }\n          return [maybeHighlight(defs.marker, \">\"), maybeHighlight(defs.gutter, gutter), line3.length > 0 ? ` ${line3}` : \"\", markerLine].join(\"\");\n        } else {\n          return ` ${maybeHighlight(defs.gutter, gutter)}${line3.length > 0 ? ` ${line3}` : \"\"}`;\n        }\n      }).join(\"\\n\");\n      if (opts.message && !hasColumns) {\n        frame = `${\" \".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;\n      }\n      if (highlighted) {\n        return chalk2.reset(frame);\n      } else {\n        return frame;\n      }\n    }\n    function _default2(rawLines, lineNumber, colNumber, opts = {}) {\n      if (!deprecationWarningShown) {\n        deprecationWarningShown = true;\n        const message = \"Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.\";\n        if (process.emitWarning) {\n          process.emitWarning(message, \"DeprecationWarning\");\n        } else {\n          const deprecationError = new Error(message);\n          deprecationError.name = \"DeprecationWarning\";\n          console.warn(new Error(message));\n        }\n      }\n      colNumber = Math.max(colNumber, 0);\n      const location = {\n        start: {\n          column: colNumber,\n          line: lineNumber\n        }\n      };\n      return codeFrameColumns3(rawLines, location, opts);\n    }\n  }\n});\n\n// node_modules/ignore/index.js\nvar require_ignore = __commonJS({\n  \"node_modules/ignore/index.js\"(exports, module) {\n    function makeArray(subject) {\n      return Array.isArray(subject) ? subject : [subject];\n    }\n    var EMPTY = \"\";\n    var SPACE = \" \";\n    var ESCAPE = \"\\\\\";\n    var REGEX_TEST_BLANK_LINE = /^\\s+$/;\n    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;\n    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\n    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\n    var REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n    var REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\n    var SLASH = \"/\";\n    var TMP_KEY_IGNORE = \"node-ignore\";\n    if (typeof Symbol !== \"undefined\") {\n      TMP_KEY_IGNORE = Symbol.for(\"node-ignore\");\n    }\n    var KEY_IGNORE = TMP_KEY_IGNORE;\n    var define = (object, key2, value) => Object.defineProperty(object, key2, { value });\n    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n    var RETURN_FALSE = () => false;\n    var sanitizeRange = (range) => range.replace(\n      REGEX_REGEXP_RANGE,\n      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY\n    );\n    var cleanRangeBackSlash = (slashes) => {\n      const { length } = slashes;\n      return slashes.slice(0, length - length % 2);\n    };\n    var REPLACERS = [\n      [\n        // remove BOM\n        // TODO:\n        // Other similar zero-width characters?\n        /^\\uFEFF/,\n        () => EMPTY\n      ],\n      // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n      [\n        // (a\\ ) -> (a )\n        // (a  ) -> (a)\n        // (a \\ ) -> (a  )\n        /\\\\?\\s+$/,\n        (match) => match.indexOf(\"\\\\\") === 0 ? SPACE : EMPTY\n      ],\n      // replace (\\ ) with ' '\n      [\n        /\\\\\\s/g,\n        () => SPACE\n      ],\n      // Escape metacharacters\n      // which is written down by users but means special for regular expressions.\n      // > There are 12 characters with special meanings:\n      // > - the backslash \\,\n      // > - the caret ^,\n      // > - the dollar sign $,\n      // > - the period or dot .,\n      // > - the vertical bar or pipe symbol |,\n      // > - the question mark ?,\n      // > - the asterisk or star *,\n      // > - the plus sign +,\n      // > - the opening parenthesis (,\n      // > - the closing parenthesis ),\n      // > - and the opening square bracket [,\n      // > - the opening curly brace {,\n      // > These special characters are often called \"metacharacters\".\n      [\n        /[\\\\$.|*+(){^]/g,\n        (match) => `\\\\${match}`\n      ],\n      [\n        // > a question mark (?) matches a single character\n        /(?!\\\\)\\?/g,\n        () => \"[^/]\"\n      ],\n      // leading slash\n      [\n        // > A leading slash matches the beginning of the pathname.\n        // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n        // A leading slash matches the beginning of the pathname\n        /^\\//,\n        () => \"^\"\n      ],\n      // replace special metacharacter slash after the leading slash\n      [\n        /\\//g,\n        () => \"\\\\/\"\n      ],\n      [\n        // > A leading \"**\" followed by a slash means match in all directories.\n        // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n        // > the same as pattern \"foo\".\n        // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n        // >   under directory \"foo\".\n        // Notice that the '*'s have been replaced as '\\\\*'\n        /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n        // '**/foo' <-> 'foo'\n        () => \"^(?:.*\\\\/)?\"\n      ],\n      // starting\n      [\n        // there will be no leading '/'\n        //   (which has been replaced by section \"leading slash\")\n        // If starts with '**', adding a '^' to the regular expression also works\n        /^(?=[^^])/,\n        function startingReplacer() {\n          return !/\\/(?!$)/.test(this) ? \"(?:^|\\\\/)\" : \"^\";\n        }\n      ],\n      // two globstars\n      [\n        // Use lookahead assertions so that we could match more than one `'/**'`\n        /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n        // Zero, one or several directories\n        // should not use '*', or it will be replaced by the next replacer\n        // Check if it is not the last `'/**'`\n        (_, index, str2) => index + 6 < str2.length ? \"(?:\\\\/[^\\\\/]+)*\" : \"\\\\/.+\"\n      ],\n      // normal intermediate wildcards\n      [\n        // Never replace escaped '*'\n        // ignore rule '\\*' will match the path '*'\n        // 'abc.*/' -> go\n        // 'abc.*'  -> skip this rule,\n        //    coz trailing single wildcard will be handed by [trailing wildcard]\n        /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n        // '*.js' matches '.js'\n        // '*.js' doesn't match 'abc'\n        (_, p1, p2) => {\n          const unescaped = p2.replace(/\\\\\\*/g, \"[^\\\\/]*\");\n          return p1 + unescaped;\n        }\n      ],\n      [\n        // unescape, revert step 3 except for back slash\n        // For example, if a user escape a '\\\\*',\n        // after step 3, the result will be '\\\\\\\\\\\\*'\n        /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n        () => ESCAPE\n      ],\n      [\n        // '\\\\\\\\' -> '\\\\'\n        /\\\\\\\\/g,\n        () => ESCAPE\n      ],\n      [\n        // > The range notation, e.g. [a-zA-Z],\n        // > can be used to match one of the characters in a range.\n        // `\\` is escaped by step 3\n        /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === \"]\" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : \"[]\" : \"[]\"\n      ],\n      // ending\n      [\n        // 'js' will not match 'js.'\n        // 'ab' will not match 'abc'\n        /(?:[^*])$/,\n        // WTF!\n        // https://git-scm.com/docs/gitignore\n        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n        // which re-fixes #24, #38\n        // > If there is a separator at the end of the pattern then the pattern\n        // > will only match directories, otherwise the pattern can match both\n        // > files and directories.\n        // 'js*' will not match 'a.js'\n        // 'js/' will not match 'a.js'\n        // 'js' will match 'a.js' and 'a.js/'\n        (match) => /\\/$/.test(match) ? `${match}$` : `${match}(?=$|\\\\/$)`\n      ],\n      // trailing wildcard\n      [\n        /(\\^|\\\\\\/)?\\\\\\*$/,\n        (_, p1) => {\n          const prefix = p1 ? `${p1}[^/]+` : \"[^/]*\";\n          return `${prefix}(?=$|\\\\/$)`;\n        }\n      ]\n    ];\n    var regexCache = /* @__PURE__ */ Object.create(null);\n    var makeRegex = (pattern, ignoreCase) => {\n      let source2 = regexCache[pattern];\n      if (!source2) {\n        source2 = REPLACERS.reduce(\n          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n          pattern\n        );\n        regexCache[pattern] = source2;\n      }\n      return ignoreCase ? new RegExp(source2, \"i\") : new RegExp(source2);\n    };\n    var isString = (subject) => typeof subject === \"string\";\n    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf(\"#\") !== 0;\n    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);\n    var IgnoreRule = class {\n      constructor(origin, pattern, negative, regex) {\n        this.origin = origin;\n        this.pattern = pattern;\n        this.negative = negative;\n        this.regex = regex;\n      }\n    };\n    var createRule = (pattern, ignoreCase) => {\n      const origin = pattern;\n      let negative = false;\n      if (pattern.indexOf(\"!\") === 0) {\n        negative = true;\n        pattern = pattern.substr(1);\n      }\n      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, \"!\").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, \"#\");\n      const regex = makeRegex(pattern, ignoreCase);\n      return new IgnoreRule(\n        origin,\n        pattern,\n        negative,\n        regex\n      );\n    };\n    var throwError2 = (message, Ctor) => {\n      throw new Ctor(message);\n    };\n    var checkPath = (path13, originalPath, doThrow) => {\n      if (!isString(path13)) {\n        return doThrow(\n          `path must be a string, but got \\`${originalPath}\\``,\n          TypeError\n        );\n      }\n      if (!path13) {\n        return doThrow(`path must not be empty`, TypeError);\n      }\n      if (checkPath.isNotRelative(path13)) {\n        const r = \"`path.relative()`d\";\n        return doThrow(\n          `path should be a ${r} string, but got \"${originalPath}\"`,\n          RangeError\n        );\n      }\n      return true;\n    };\n    var isNotRelative = (path13) => REGEX_TEST_INVALID_PATH.test(path13);\n    checkPath.isNotRelative = isNotRelative;\n    checkPath.convert = (p) => p;\n    var Ignore = class {\n      constructor({\n        ignorecase = true,\n        ignoreCase = ignorecase,\n        allowRelativePaths = false\n      } = {}) {\n        define(this, KEY_IGNORE, true);\n        this._rules = [];\n        this._ignoreCase = ignoreCase;\n        this._allowRelativePaths = allowRelativePaths;\n        this._initCache();\n      }\n      _initCache() {\n        this._ignoreCache = /* @__PURE__ */ Object.create(null);\n        this._testCache = /* @__PURE__ */ Object.create(null);\n      }\n      _addPattern(pattern) {\n        if (pattern && pattern[KEY_IGNORE]) {\n          this._rules = this._rules.concat(pattern._rules);\n          this._added = true;\n          return;\n        }\n        if (checkPattern(pattern)) {\n          const rule = createRule(pattern, this._ignoreCase);\n          this._added = true;\n          this._rules.push(rule);\n        }\n      }\n      // @param {Array<string> | string | Ignore} pattern\n      add(pattern) {\n        this._added = false;\n        makeArray(\n          isString(pattern) ? splitPattern(pattern) : pattern\n        ).forEach(this._addPattern, this);\n        if (this._added) {\n          this._initCache();\n        }\n        return this;\n      }\n      // legacy\n      addPattern(pattern) {\n        return this.add(pattern);\n      }\n      //          |           ignored : unignored\n      // negative |   0:0   |   0:1   |   1:0   |   1:1\n      // -------- | ------- | ------- | ------- | --------\n      //     0    |  TEST   |  TEST   |  SKIP   |    X\n      //     1    |  TESTIF |  SKIP   |  TEST   |    X\n      // - SKIP: always skip\n      // - TEST: always test\n      // - TESTIF: only test if checkUnignored\n      // - X: that never happen\n      // @param {boolean} whether should check if the path is unignored,\n      //   setting `checkUnignored` to `false` could reduce additional\n      //   path matching.\n      // @returns {TestResult} true if a file is ignored\n      _testOne(path13, checkUnignored) {\n        let ignored = false;\n        let unignored = false;\n        this._rules.forEach((rule) => {\n          const { negative } = rule;\n          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n            return;\n          }\n          const matched = rule.regex.test(path13);\n          if (matched) {\n            ignored = !negative;\n            unignored = negative;\n          }\n        });\n        return {\n          ignored,\n          unignored\n        };\n      }\n      // @returns {TestResult}\n      _test(originalPath, cache3, checkUnignored, slices) {\n        const path13 = originalPath && checkPath.convert(originalPath);\n        checkPath(\n          path13,\n          originalPath,\n          this._allowRelativePaths ? RETURN_FALSE : throwError2\n        );\n        return this._t(path13, cache3, checkUnignored, slices);\n      }\n      _t(path13, cache3, checkUnignored, slices) {\n        if (path13 in cache3) {\n          return cache3[path13];\n        }\n        if (!slices) {\n          slices = path13.split(SLASH);\n        }\n        slices.pop();\n        if (!slices.length) {\n          return cache3[path13] = this._testOne(path13, checkUnignored);\n        }\n        const parent = this._t(\n          slices.join(SLASH) + SLASH,\n          cache3,\n          checkUnignored,\n          slices\n        );\n        return cache3[path13] = parent.ignored ? parent : this._testOne(path13, checkUnignored);\n      }\n      ignores(path13) {\n        return this._test(path13, this._ignoreCache, false).ignored;\n      }\n      createFilter() {\n        return (path13) => !this.ignores(path13);\n      }\n      filter(paths) {\n        return makeArray(paths).filter(this.createFilter());\n      }\n      // @returns {TestResult}\n      test(path13) {\n        return this._test(path13, this._testCache, true);\n      }\n    };\n    var factory = (options8) => new Ignore(options8);\n    var isPathValid = (path13) => checkPath(path13 && checkPath.convert(path13), path13, RETURN_FALSE);\n    factory.isPathValid = isPathValid;\n    factory.default = factory;\n    module.exports = factory;\n    if (\n      // Detect `process` so that it can run in browsers.\n      typeof process !== \"undefined\" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === \"win32\")\n    ) {\n      const makePosix = (str2) => /^\\\\\\\\\\?\\\\/.test(str2) || /[\"<>|\\u0000-\\u001F]+/u.test(str2) ? str2 : str2.replace(/\\\\/g, \"/\");\n      checkPath.convert = makePosix;\n      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n      checkPath.isNotRelative = (path13) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path13) || isNotRelative(path13);\n    }\n  }\n});\n\n// node_modules/n-readlines/readlines.js\nvar require_readlines = __commonJS({\n  \"node_modules/n-readlines/readlines.js\"(exports, module) {\n    \"use strict\";\n    var fs7 = __require(\"fs\");\n    var LineByLine = class {\n      constructor(file, options8) {\n        options8 = options8 || {};\n        if (!options8.readChunk)\n          options8.readChunk = 1024;\n        if (!options8.newLineCharacter) {\n          options8.newLineCharacter = 10;\n        } else {\n          options8.newLineCharacter = options8.newLineCharacter.charCodeAt(0);\n        }\n        if (typeof file === \"number\") {\n          this.fd = file;\n        } else {\n          this.fd = fs7.openSync(file, \"r\");\n        }\n        this.options = options8;\n        this.newLineCharacter = options8.newLineCharacter;\n        this.reset();\n      }\n      _searchInBuffer(buffer2, hexNeedle) {\n        let found = -1;\n        for (let i = 0; i <= buffer2.length; i++) {\n          let b_byte = buffer2[i];\n          if (b_byte === hexNeedle) {\n            found = i;\n            break;\n          }\n        }\n        return found;\n      }\n      reset() {\n        this.eofReached = false;\n        this.linesCache = [];\n        this.fdPosition = 0;\n      }\n      close() {\n        fs7.closeSync(this.fd);\n        this.fd = null;\n      }\n      _extractLines(buffer2) {\n        let line3;\n        const lines = [];\n        let bufferPosition = 0;\n        let lastNewLineBufferPosition = 0;\n        while (true) {\n          let bufferPositionValue = buffer2[bufferPosition++];\n          if (bufferPositionValue === this.newLineCharacter) {\n            line3 = buffer2.slice(lastNewLineBufferPosition, bufferPosition);\n            lines.push(line3);\n            lastNewLineBufferPosition = bufferPosition;\n          } else if (bufferPositionValue === void 0) {\n            break;\n          }\n        }\n        let leftovers = buffer2.slice(lastNewLineBufferPosition, bufferPosition);\n        if (leftovers.length) {\n          lines.push(leftovers);\n        }\n        return lines;\n      }\n      _readChunk(lineLeftovers) {\n        let totalBytesRead = 0;\n        let bytesRead;\n        const buffers = [];\n        do {\n          const readBuffer = Buffer.alloc(this.options.readChunk);\n          bytesRead = fs7.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);\n          totalBytesRead = totalBytesRead + bytesRead;\n          this.fdPosition = this.fdPosition + bytesRead;\n          buffers.push(readBuffer);\n        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);\n        let bufferData = Buffer.concat(buffers);\n        if (bytesRead < this.options.readChunk) {\n          this.eofReached = true;\n          bufferData = bufferData.slice(0, totalBytesRead);\n        }\n        if (totalBytesRead) {\n          this.linesCache = this._extractLines(bufferData);\n          if (lineLeftovers) {\n            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);\n          }\n        }\n        return totalBytesRead;\n      }\n      next() {\n        if (!this.fd)\n          return false;\n        let line3 = false;\n        if (this.eofReached && this.linesCache.length === 0) {\n          return line3;\n        }\n        let bytesRead;\n        if (!this.linesCache.length) {\n          bytesRead = this._readChunk();\n        }\n        if (this.linesCache.length) {\n          line3 = this.linesCache.shift();\n          const lastLineCharacter = line3[line3.length - 1];\n          if (lastLineCharacter !== this.newLineCharacter) {\n            bytesRead = this._readChunk(line3);\n            if (bytesRead) {\n              line3 = this.linesCache.shift();\n            }\n          }\n        }\n        if (this.eofReached && this.linesCache.length === 0) {\n          this.close();\n        }\n        if (line3 && line3[line3.length - 1] === this.newLineCharacter) {\n          line3 = line3.slice(0, line3.length - 1);\n        }\n        return line3;\n      }\n    };\n    module.exports = LineByLine;\n  }\n});\n\n// node_modules/diff/lib/diff/base.js\nvar require_base = __commonJS({\n  \"node_modules/diff/lib/diff/base.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports[\"default\"] = Diff;\n    function Diff() {\n    }\n    Diff.prototype = {\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      diff: function diff(oldString, newString) {\n        var options8 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var callback = options8.callback;\n        if (typeof options8 === \"function\") {\n          callback = options8;\n          options8 = {};\n        }\n        this.options = options8;\n        var self = this;\n        function done(value) {\n          if (callback) {\n            setTimeout(function() {\n              callback(void 0, value);\n            }, 0);\n            return true;\n          } else {\n            return value;\n          }\n        }\n        oldString = this.castInput(oldString);\n        newString = this.castInput(newString);\n        oldString = this.removeEmpty(this.tokenize(oldString));\n        newString = this.removeEmpty(this.tokenize(newString));\n        var newLen = newString.length, oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        if (options8.maxEditLength) {\n          maxEditLength = Math.min(maxEditLength, options8.maxEditLength);\n        }\n        var bestPath = [{\n          newPos: -1,\n          components: []\n        }];\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done([{\n            value: this.join(newString),\n            count: newString.length\n          }]);\n        }\n        function execEditLength() {\n          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n            var basePath = (\n              /*istanbul ignore start*/\n              void 0\n            );\n            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n            if (addPath) {\n              bestPath[diagonalPath - 1] = void 0;\n            }\n            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n            if (!canAdd && !canRemove) {\n              bestPath[diagonalPath] = void 0;\n              continue;\n            }\n            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n              basePath = clonePath(removePath);\n              self.pushComponent(basePath.components, void 0, true);\n            } else {\n              basePath = addPath;\n              basePath.newPos++;\n              self.pushComponent(basePath.components, true, void 0);\n            }\n            _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n              return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n            } else {\n              bestPath[diagonalPath] = basePath;\n            }\n          }\n          editLength++;\n        }\n        if (callback) {\n          (function exec() {\n            setTimeout(function() {\n              if (editLength > maxEditLength) {\n                return callback();\n              }\n              if (!execEditLength()) {\n                exec();\n              }\n            }, 0);\n          })();\n        } else {\n          while (editLength <= maxEditLength) {\n            var ret = execEditLength();\n            if (ret) {\n              return ret;\n            }\n          }\n        }\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      pushComponent: function pushComponent(components, added, removed) {\n        var last = components[components.length - 1];\n        if (last && last.added === added && last.removed === removed) {\n          components[components.length - 1] = {\n            count: last.count + 1,\n            added,\n            removed\n          };\n        } else {\n          components.push({\n            count: 1,\n            added,\n            removed\n          });\n        }\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n          newPos++;\n          oldPos++;\n          commonCount++;\n        }\n        if (commonCount) {\n          basePath.components.push({\n            count: commonCount\n          });\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      equals: function equals(left, right) {\n        if (this.options.comparator) {\n          return this.options.comparator(left, right);\n        } else {\n          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      removeEmpty: function removeEmpty(array2) {\n        var ret = [];\n        for (var i = 0; i < array2.length; i++) {\n          if (array2[i]) {\n            ret.push(array2[i]);\n          }\n        }\n        return ret;\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      castInput: function castInput(value) {\n        return value;\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      tokenize: function tokenize(value) {\n        return value.split(\"\");\n      },\n      /*istanbul ignore start*/\n      /*istanbul ignore end*/\n      join: function join2(chars) {\n        return chars.join(\"\");\n      }\n    };\n    function buildValues(diff, components, newString, oldString, useLongestToken) {\n      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n      for (; componentPos < componentLen; componentPos++) {\n        var component = components[componentPos];\n        if (!component.removed) {\n          if (!component.added && useLongestToken) {\n            var value = newString.slice(newPos, newPos + component.count);\n            value = value.map(function(value2, i) {\n              var oldValue = oldString[oldPos + i];\n              return oldValue.length > value2.length ? oldValue : value2;\n            });\n            component.value = diff.join(value);\n          } else {\n            component.value = diff.join(newString.slice(newPos, newPos + component.count));\n          }\n          newPos += component.count;\n          if (!component.added) {\n            oldPos += component.count;\n          }\n        } else {\n          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n          oldPos += component.count;\n          if (componentPos && components[componentPos - 1].added) {\n            var tmp = components[componentPos - 1];\n            components[componentPos - 1] = components[componentPos];\n            components[componentPos] = tmp;\n          }\n        }\n      }\n      var lastComponent = components[componentLen - 1];\n      if (componentLen > 1 && typeof lastComponent.value === \"string\" && (lastComponent.added || lastComponent.removed) && diff.equals(\"\", lastComponent.value)) {\n        components[componentLen - 2].value += lastComponent.value;\n        components.pop();\n      }\n      return components;\n    }\n    function clonePath(path13) {\n      return {\n        newPos: path13.newPos,\n        components: path13.components.slice(0)\n      };\n    }\n  }\n});\n\n// node_modules/diff/lib/diff/array.js\nvar require_array2 = __commonJS({\n  \"node_modules/diff/lib/diff/array.js\"(exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.diffArrays = diffArrays2;\n    exports.arrayDiff = void 0;\n    var _base = _interopRequireDefault(require_base());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : { \"default\": obj };\n    }\n    var arrayDiff = new /*istanbul ignore start*/\n    _base[\n      /*istanbul ignore start*/\n      \"default\"\n      /*istanbul ignore end*/\n    ]();\n    exports.arrayDiff = arrayDiff;\n    arrayDiff.tokenize = function(value) {\n      return value.slice();\n    };\n    arrayDiff.join = arrayDiff.removeEmpty = function(value) {\n      return value;\n    };\n    function diffArrays2(oldArr, newArr, callback) {\n      return arrayDiff.diff(oldArr, newArr, callback);\n    }\n  }\n});\n\n// src/index.js\nvar src_exports = {};\n__export(src_exports, {\n  __debug: () => debugApis,\n  __internal: () => sharedWithCli,\n  check: () => check,\n  clearConfigCache: () => clearCache3,\n  doc: () => doc,\n  format: () => format2,\n  formatWithCursor: () => formatWithCursor2,\n  getFileInfo: () => getFileInfo2,\n  getSupportInfo: () => getSupportInfo2,\n  resolveConfig: () => resolveConfig,\n  resolveConfigFile: () => resolveConfigFile,\n  util: () => public_exports,\n  version: () => version_evaluate_default\n});\nvar import_fast_glob = __toESM(require_out4(), 1);\n\n// node_modules/vnopts/lib/descriptors/api.js\nvar apiDescriptor = {\n  key: (key2) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key2) ? key2 : JSON.stringify(key2),\n  value(value) {\n    if (value === null || typeof value !== \"object\") {\n      return JSON.stringify(value);\n    }\n    if (Array.isArray(value)) {\n      return `[${value.map((subValue) => apiDescriptor.value(subValue)).join(\", \")}]`;\n    }\n    const keys = Object.keys(value);\n    return keys.length === 0 ? \"{}\" : `{ ${keys.map((key2) => `${apiDescriptor.key(key2)}: ${apiDescriptor.value(value[key2])}`).join(\", \")} }`;\n  },\n  pair: ({ key: key2, value }) => apiDescriptor.value({ [key2]: value })\n};\n\n// node_modules/chalk/source/vendor/ansi-styles/index.js\nvar ANSI_BACKGROUND_OFFSET = 10;\nvar wrapAnsi16 = (offset = 0) => (code) => `\\x1B[${code + offset}m`;\nvar wrapAnsi256 = (offset = 0) => (code) => `\\x1B[${38 + offset};5;${code}m`;\nvar wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\x1B[${38 + offset};2;${red};${green};${blue}m`;\nvar styles = {\n  modifier: {\n    reset: [0, 0],\n    // 21 isn't widely supported and 22 does the same thing\n    bold: [1, 22],\n    dim: [2, 22],\n    italic: [3, 23],\n    underline: [4, 24],\n    overline: [53, 55],\n    inverse: [7, 27],\n    hidden: [8, 28],\n    strikethrough: [9, 29]\n  },\n  color: {\n    black: [30, 39],\n    red: [31, 39],\n    green: [32, 39],\n    yellow: [33, 39],\n    blue: [34, 39],\n    magenta: [35, 39],\n    cyan: [36, 39],\n    white: [37, 39],\n    // Bright color\n    blackBright: [90, 39],\n    gray: [90, 39],\n    // Alias of `blackBright`\n    grey: [90, 39],\n    // Alias of `blackBright`\n    redBright: [91, 39],\n    greenBright: [92, 39],\n    yellowBright: [93, 39],\n    blueBright: [94, 39],\n    magentaBright: [95, 39],\n    cyanBright: [96, 39],\n    whiteBright: [97, 39]\n  },\n  bgColor: {\n    bgBlack: [40, 49],\n    bgRed: [41, 49],\n    bgGreen: [42, 49],\n    bgYellow: [43, 49],\n    bgBlue: [44, 49],\n    bgMagenta: [45, 49],\n    bgCyan: [46, 49],\n    bgWhite: [47, 49],\n    // Bright color\n    bgBlackBright: [100, 49],\n    bgGray: [100, 49],\n    // Alias of `bgBlackBright`\n    bgGrey: [100, 49],\n    // Alias of `bgBlackBright`\n    bgRedBright: [101, 49],\n    bgGreenBright: [102, 49],\n    bgYellowBright: [103, 49],\n    bgBlueBright: [104, 49],\n    bgMagentaBright: [105, 49],\n    bgCyanBright: [106, 49],\n    bgWhiteBright: [107, 49]\n  }\n};\nvar modifierNames = Object.keys(styles.modifier);\nvar foregroundColorNames = Object.keys(styles.color);\nvar backgroundColorNames = Object.keys(styles.bgColor);\nvar colorNames = [...foregroundColorNames, ...backgroundColorNames];\nfunction assembleStyles() {\n  const codes2 = /* @__PURE__ */ new Map();\n  for (const [groupName, group] of Object.entries(styles)) {\n    for (const [styleName, style] of Object.entries(group)) {\n      styles[styleName] = {\n        open: `\\x1B[${style[0]}m`,\n        close: `\\x1B[${style[1]}m`\n      };\n      group[styleName] = styles[styleName];\n      codes2.set(style[0], style[1]);\n    }\n    Object.defineProperty(styles, groupName, {\n      value: group,\n      enumerable: false\n    });\n  }\n  Object.defineProperty(styles, \"codes\", {\n    value: codes2,\n    enumerable: false\n  });\n  styles.color.close = \"\\x1B[39m\";\n  styles.bgColor.close = \"\\x1B[49m\";\n  styles.color.ansi = wrapAnsi16();\n  styles.color.ansi256 = wrapAnsi256();\n  styles.color.ansi16m = wrapAnsi16m();\n  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);\n  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n  Object.defineProperties(styles, {\n    rgbToAnsi256: {\n      value(red, green, blue) {\n        if (red === green && green === blue) {\n          if (red < 8) {\n            return 16;\n          }\n          if (red > 248) {\n            return 231;\n          }\n          return Math.round((red - 8) / 247 * 24) + 232;\n        }\n        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);\n      },\n      enumerable: false\n    },\n    hexToRgb: {\n      value(hex) {\n        const matches = /[a-f\\d]{6}|[a-f\\d]{3}/i.exec(hex.toString(16));\n        if (!matches) {\n          return [0, 0, 0];\n        }\n        let [colorString] = matches;\n        if (colorString.length === 3) {\n          colorString = [...colorString].map((character) => character + character).join(\"\");\n        }\n        const integer = Number.parseInt(colorString, 16);\n        return [\n          /* eslint-disable no-bitwise */\n          integer >> 16 & 255,\n          integer >> 8 & 255,\n          integer & 255\n          /* eslint-enable no-bitwise */\n        ];\n      },\n      enumerable: false\n    },\n    hexToAnsi256: {\n      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n      enumerable: false\n    },\n    ansi256ToAnsi: {\n      value(code) {\n        if (code < 8) {\n          return 30 + code;\n        }\n        if (code < 16) {\n          return 90 + (code - 8);\n        }\n        let red;\n        let green;\n        let blue;\n        if (code >= 232) {\n          red = ((code - 232) * 10 + 8) / 255;\n          green = red;\n          blue = red;\n        } else {\n          code -= 16;\n          const remainder = code % 36;\n          red = Math.floor(code / 36) / 5;\n          green = Math.floor(remainder / 6) / 5;\n          blue = remainder % 6 / 5;\n        }\n        const value = Math.max(red, green, blue) * 2;\n        if (value === 0) {\n          return 30;\n        }\n        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));\n        if (value === 2) {\n          result += 60;\n        }\n        return result;\n      },\n      enumerable: false\n    },\n    rgbToAnsi: {\n      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),\n      enumerable: false\n    },\n    hexToAnsi: {\n      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),\n      enumerable: false\n    }\n  });\n  return styles;\n}\nvar ansiStyles = assembleStyles();\nvar ansi_styles_default = ansiStyles;\n\n// node_modules/chalk/source/vendor/supports-color/index.js\nimport process2 from \"process\";\nimport os from \"os\";\nimport tty from \"tty\";\nfunction hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {\n  const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";\n  const position = argv.indexOf(prefix + flag);\n  const terminatorPosition = argv.indexOf(\"--\");\n  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n}\nvar { env } = process2;\nvar flagForceColor;\nif (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\") || hasFlag(\"color=never\")) {\n  flagForceColor = 0;\n} else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {\n  flagForceColor = 1;\n}\nfunction envForceColor() {\n  if (\"FORCE_COLOR\" in env) {\n    if (env.FORCE_COLOR === \"true\") {\n      return 1;\n    }\n    if (env.FORCE_COLOR === \"false\") {\n      return 0;\n    }\n    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);\n  }\n}\nfunction translateLevel(level) {\n  if (level === 0) {\n    return false;\n  }\n  return {\n    level,\n    hasBasic: true,\n    has256: level >= 2,\n    has16m: level >= 3\n  };\n}\nfunction _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {\n  const noFlagForceColor = envForceColor();\n  if (noFlagForceColor !== void 0) {\n    flagForceColor = noFlagForceColor;\n  }\n  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;\n  if (forceColor === 0) {\n    return 0;\n  }\n  if (sniffFlags) {\n    if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {\n      return 3;\n    }\n    if (hasFlag(\"color=256\")) {\n      return 2;\n    }\n  }\n  if (\"TF_BUILD\" in env && \"AGENT_NAME\" in env) {\n    return 1;\n  }\n  if (haveStream && !streamIsTTY && forceColor === void 0) {\n    return 0;\n  }\n  const min = forceColor || 0;\n  if (env.TERM === \"dumb\") {\n    return min;\n  }\n  if (process2.platform === \"win32\") {\n    const osRelease = os.release().split(\".\");\n    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n      return Number(osRelease[2]) >= 14931 ? 3 : 2;\n    }\n    return 1;\n  }\n  if (\"CI\" in env) {\n    if (\"GITHUB_ACTIONS\" in env || \"GITEA_ACTIONS\" in env) {\n      return 3;\n    }\n    if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"BUILDKITE\", \"DRONE\"].some((sign2) => sign2 in env) || env.CI_NAME === \"codeship\") {\n      return 1;\n    }\n    return min;\n  }\n  if (\"TEAMCITY_VERSION\" in env) {\n    return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n  }\n  if (env.COLORTERM === \"truecolor\") {\n    return 3;\n  }\n  if (env.TERM === \"xterm-kitty\") {\n    return 3;\n  }\n  if (\"TERM_PROGRAM\" in env) {\n    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n    switch (env.TERM_PROGRAM) {\n      case \"iTerm.app\": {\n        return version >= 3 ? 3 : 2;\n      }\n      case \"Apple_Terminal\": {\n        return 2;\n      }\n    }\n  }\n  if (/-256(color)?$/i.test(env.TERM)) {\n    return 2;\n  }\n  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n    return 1;\n  }\n  if (\"COLORTERM\" in env) {\n    return 1;\n  }\n  return min;\n}\nfunction createSupportsColor(stream, options8 = {}) {\n  const level = _supportsColor(stream, {\n    streamIsTTY: stream && stream.isTTY,\n    ...options8\n  });\n  return translateLevel(level);\n}\nvar supportsColor = {\n  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),\n  stderr: createSupportsColor({ isTTY: tty.isatty(2) })\n};\nvar supports_color_default = supportsColor;\n\n// node_modules/chalk/source/utilities.js\nfunction stringReplaceAll(string, substring, replacer) {\n  let index = string.indexOf(substring);\n  if (index === -1) {\n    return string;\n  }\n  const substringLength = substring.length;\n  let endIndex = 0;\n  let returnValue = \"\";\n  do {\n    returnValue += string.slice(endIndex, index) + substring + replacer;\n    endIndex = index + substringLength;\n    index = string.indexOf(substring, endIndex);\n  } while (index !== -1);\n  returnValue += string.slice(endIndex);\n  return returnValue;\n}\nfunction stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {\n  let endIndex = 0;\n  let returnValue = \"\";\n  do {\n    const gotCR = string[index - 1] === \"\\r\";\n    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? \"\\r\\n\" : \"\\n\") + postfix;\n    endIndex = index + 1;\n    index = string.indexOf(\"\\n\", endIndex);\n  } while (index !== -1);\n  returnValue += string.slice(endIndex);\n  return returnValue;\n}\n\n// node_modules/chalk/source/index.js\nvar { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;\nvar GENERATOR = Symbol(\"GENERATOR\");\nvar STYLER = Symbol(\"STYLER\");\nvar IS_EMPTY = Symbol(\"IS_EMPTY\");\nvar levelMapping = [\n  \"ansi\",\n  \"ansi\",\n  \"ansi256\",\n  \"ansi16m\"\n];\nvar styles2 = /* @__PURE__ */ Object.create(null);\nvar applyOptions = (object, options8 = {}) => {\n  if (options8.level && !(Number.isInteger(options8.level) && options8.level >= 0 && options8.level <= 3)) {\n    throw new Error(\"The `level` option should be an integer from 0 to 3\");\n  }\n  const colorLevel = stdoutColor ? stdoutColor.level : 0;\n  object.level = options8.level === void 0 ? colorLevel : options8.level;\n};\nvar chalkFactory = (options8) => {\n  const chalk2 = (...strings) => strings.join(\" \");\n  applyOptions(chalk2, options8);\n  Object.setPrototypeOf(chalk2, createChalk.prototype);\n  return chalk2;\n};\nfunction createChalk(options8) {\n  return chalkFactory(options8);\n}\nObject.setPrototypeOf(createChalk.prototype, Function.prototype);\nfor (const [styleName, style] of Object.entries(ansi_styles_default)) {\n  styles2[styleName] = {\n    get() {\n      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);\n      Object.defineProperty(this, styleName, { value: builder });\n      return builder;\n    }\n  };\n}\nstyles2.visible = {\n  get() {\n    const builder = createBuilder(this, this[STYLER], true);\n    Object.defineProperty(this, \"visible\", { value: builder });\n    return builder;\n  }\n};\nvar getModelAnsi = (model, level, type2, ...arguments_) => {\n  if (model === \"rgb\") {\n    if (level === \"ansi16m\") {\n      return ansi_styles_default[type2].ansi16m(...arguments_);\n    }\n    if (level === \"ansi256\") {\n      return ansi_styles_default[type2].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));\n    }\n    return ansi_styles_default[type2].ansi(ansi_styles_default.rgbToAnsi(...arguments_));\n  }\n  if (model === \"hex\") {\n    return getModelAnsi(\"rgb\", level, type2, ...ansi_styles_default.hexToRgb(...arguments_));\n  }\n  return ansi_styles_default[type2][model](...arguments_);\n};\nvar usedModels = [\"rgb\", \"hex\", \"ansi256\"];\nfor (const model of usedModels) {\n  styles2[model] = {\n    get() {\n      const { level } = this;\n      return function(...arguments_) {\n        const styler = createStyler(getModelAnsi(model, levelMapping[level], \"color\", ...arguments_), ansi_styles_default.color.close, this[STYLER]);\n        return createBuilder(this, styler, this[IS_EMPTY]);\n      };\n    }\n  };\n  const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);\n  styles2[bgModel] = {\n    get() {\n      const { level } = this;\n      return function(...arguments_) {\n        const styler = createStyler(getModelAnsi(model, levelMapping[level], \"bgColor\", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);\n        return createBuilder(this, styler, this[IS_EMPTY]);\n      };\n    }\n  };\n}\nvar proto = Object.defineProperties(() => {\n}, {\n  ...styles2,\n  level: {\n    enumerable: true,\n    get() {\n      return this[GENERATOR].level;\n    },\n    set(level) {\n      this[GENERATOR].level = level;\n    }\n  }\n});\nvar createStyler = (open, close, parent) => {\n  let openAll;\n  let closeAll;\n  if (parent === void 0) {\n    openAll = open;\n    closeAll = close;\n  } else {\n    openAll = parent.openAll + open;\n    closeAll = close + parent.closeAll;\n  }\n  return {\n    open,\n    close,\n    openAll,\n    closeAll,\n    parent\n  };\n};\nvar createBuilder = (self, _styler, _isEmpty) => {\n  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? \"\" + arguments_[0] : arguments_.join(\" \"));\n  Object.setPrototypeOf(builder, proto);\n  builder[GENERATOR] = self;\n  builder[STYLER] = _styler;\n  builder[IS_EMPTY] = _isEmpty;\n  return builder;\n};\nvar applyStyle = (self, string) => {\n  if (self.level <= 0 || !string) {\n    return self[IS_EMPTY] ? \"\" : string;\n  }\n  let styler = self[STYLER];\n  if (styler === void 0) {\n    return string;\n  }\n  const { openAll, closeAll } = styler;\n  if (string.includes(\"\\x1B\")) {\n    while (styler !== void 0) {\n      string = stringReplaceAll(string, styler.close, styler.open);\n      styler = styler.parent;\n    }\n  }\n  const lfIndex = string.indexOf(\"\\n\");\n  if (lfIndex !== -1) {\n    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n  }\n  return openAll + string + closeAll;\n};\nObject.defineProperties(createChalk.prototype, styles2);\nvar chalk = createChalk();\nvar chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });\nvar source_default = chalk;\n\n// node_modules/vnopts/lib/handlers/deprecated/common.js\nvar commonDeprecatedHandler = (keyOrPair, redirectTo, { descriptor }) => {\n  const messages2 = [\n    `${source_default.yellow(typeof keyOrPair === \"string\" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`\n  ];\n  if (redirectTo) {\n    messages2.push(`we now treat it as ${source_default.blue(typeof redirectTo === \"string\" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`);\n  }\n  return messages2.join(\"; \") + \".\";\n};\n\n// node_modules/vnopts/lib/constants.js\nvar VALUE_NOT_EXIST = Symbol.for(\"vnopts.VALUE_NOT_EXIST\");\nvar VALUE_UNCHANGED = Symbol.for(\"vnopts.VALUE_UNCHANGED\");\n\n// node_modules/vnopts/lib/handlers/invalid/common.js\nvar INDENTATION = \" \".repeat(2);\nvar commonInvalidHandler = (key2, value, utils) => {\n  const { text, list } = utils.normalizeExpectedResult(utils.schemas[key2].expected(utils));\n  const descriptions = [];\n  if (text) {\n    descriptions.push(getDescription(key2, value, text, utils.descriptor));\n  }\n  if (list) {\n    descriptions.push([getDescription(key2, value, list.title, utils.descriptor)].concat(list.values.map((valueDescription) => getListDescription(valueDescription, utils.loggerPrintWidth))).join(\"\\n\"));\n  }\n  return chooseDescription(descriptions, utils.loggerPrintWidth);\n};\nfunction getDescription(key2, value, expected, descriptor) {\n  return [\n    `Invalid ${source_default.red(descriptor.key(key2))} value.`,\n    `Expected ${source_default.blue(expected)},`,\n    `but received ${value === VALUE_NOT_EXIST ? source_default.gray(\"nothing\") : source_default.red(descriptor.value(value))}.`\n  ].join(\" \");\n}\nfunction getListDescription({ text, list }, printWidth) {\n  const descriptions = [];\n  if (text) {\n    descriptions.push(`- ${source_default.blue(text)}`);\n  }\n  if (list) {\n    descriptions.push([`- ${source_default.blue(list.title)}:`].concat(list.values.map((valueDescription) => getListDescription(valueDescription, printWidth - INDENTATION.length).replace(/^|\\n/g, `$&${INDENTATION}`))).join(\"\\n\"));\n  }\n  return chooseDescription(descriptions, printWidth);\n}\nfunction chooseDescription(descriptions, printWidth) {\n  if (descriptions.length === 1) {\n    return descriptions[0];\n  }\n  const [firstDescription, secondDescription] = descriptions;\n  const [firstWidth, secondWidth] = descriptions.map((description) => description.split(\"\\n\", 1)[0].length);\n  return firstWidth > printWidth && firstWidth > secondWidth ? secondDescription : firstDescription;\n}\n\n// node_modules/leven/index.js\nvar array = [];\nvar characterCodeCache = [];\nfunction leven(first, second) {\n  if (first === second) {\n    return 0;\n  }\n  const swap = first;\n  if (first.length > second.length) {\n    first = second;\n    second = swap;\n  }\n  let firstLength = first.length;\n  let secondLength = second.length;\n  while (firstLength > 0 && first.charCodeAt(~-firstLength) === second.charCodeAt(~-secondLength)) {\n    firstLength--;\n    secondLength--;\n  }\n  let start = 0;\n  while (start < firstLength && first.charCodeAt(start) === second.charCodeAt(start)) {\n    start++;\n  }\n  firstLength -= start;\n  secondLength -= start;\n  if (firstLength === 0) {\n    return secondLength;\n  }\n  let bCharacterCode;\n  let result;\n  let temporary;\n  let temporary2;\n  let index = 0;\n  let index2 = 0;\n  while (index < firstLength) {\n    characterCodeCache[index] = first.charCodeAt(start + index);\n    array[index] = ++index;\n  }\n  while (index2 < secondLength) {\n    bCharacterCode = second.charCodeAt(start + index2);\n    temporary = index2++;\n    result = index2;\n    for (index = 0; index < firstLength; index++) {\n      temporary2 = bCharacterCode === characterCodeCache[index] ? temporary : temporary + 1;\n      temporary = array[index];\n      result = array[index] = temporary > result ? temporary2 > result ? result + 1 : temporary2 : temporary2 > temporary ? temporary + 1 : temporary2;\n    }\n  }\n  return result;\n}\n\n// node_modules/vnopts/lib/handlers/unknown/leven.js\nvar levenUnknownHandler = (key2, value, { descriptor, logger, schemas }) => {\n  const messages2 = [\n    `Ignored unknown option ${source_default.yellow(descriptor.pair({ key: key2, value }))}.`\n  ];\n  const suggestion = Object.keys(schemas).sort().find((knownKey) => leven(key2, knownKey) < 3);\n  if (suggestion) {\n    messages2.push(`Did you mean ${source_default.blue(descriptor.key(suggestion))}?`);\n  }\n  logger.warn(messages2.join(\" \"));\n};\n\n// node_modules/vnopts/lib/schema.js\nvar HANDLER_KEYS = [\n  \"default\",\n  \"expected\",\n  \"validate\",\n  \"deprecated\",\n  \"forward\",\n  \"redirect\",\n  \"overlap\",\n  \"preprocess\",\n  \"postprocess\"\n];\nfunction createSchema(SchemaConstructor, parameters) {\n  const schema2 = new SchemaConstructor(parameters);\n  const subSchema = Object.create(schema2);\n  for (const handlerKey of HANDLER_KEYS) {\n    if (handlerKey in parameters) {\n      subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema2, Schema.prototype[handlerKey].length);\n    }\n  }\n  return subSchema;\n}\nvar Schema = class {\n  static create(parameters) {\n    return createSchema(this, parameters);\n  }\n  constructor(parameters) {\n    this.name = parameters.name;\n  }\n  default(_utils) {\n    return void 0;\n  }\n  // this is actually an abstract method but we need a placeholder to get `function.length`\n  /* c8 ignore start */\n  expected(_utils) {\n    return \"nothing\";\n  }\n  /* c8 ignore stop */\n  // this is actually an abstract method but we need a placeholder to get `function.length`\n  /* c8 ignore start */\n  validate(_value, _utils) {\n    return false;\n  }\n  /* c8 ignore stop */\n  deprecated(_value, _utils) {\n    return false;\n  }\n  forward(_value, _utils) {\n    return void 0;\n  }\n  redirect(_value, _utils) {\n    return void 0;\n  }\n  overlap(currentValue, _newValue, _utils) {\n    return currentValue;\n  }\n  preprocess(value, _utils) {\n    return value;\n  }\n  postprocess(_value, _utils) {\n    return VALUE_UNCHANGED;\n  }\n};\nfunction normalizeHandler(handler, superSchema, handlerArgumentsLength) {\n  return typeof handler === \"function\" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;\n}\n\n// node_modules/vnopts/lib/schemas/alias.js\nvar AliasSchema = class extends Schema {\n  constructor(parameters) {\n    super(parameters);\n    this._sourceName = parameters.sourceName;\n  }\n  expected(utils) {\n    return utils.schemas[this._sourceName].expected(utils);\n  }\n  validate(value, utils) {\n    return utils.schemas[this._sourceName].validate(value, utils);\n  }\n  redirect(_value, _utils) {\n    return this._sourceName;\n  }\n};\n\n// node_modules/vnopts/lib/schemas/any.js\nvar AnySchema = class extends Schema {\n  expected() {\n    return \"anything\";\n  }\n  validate() {\n    return true;\n  }\n};\n\n// node_modules/vnopts/lib/schemas/array.js\nvar ArraySchema = class extends Schema {\n  constructor({ valueSchema, name = valueSchema.name, ...handlers }) {\n    super({ ...handlers, name });\n    this._valueSchema = valueSchema;\n  }\n  expected(utils) {\n    const { text, list } = utils.normalizeExpectedResult(this._valueSchema.expected(utils));\n    return {\n      text: text && `an array of ${text}`,\n      list: list && {\n        title: `an array of the following values`,\n        values: [{ list }]\n      }\n    };\n  }\n  validate(value, utils) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n    const invalidValues = [];\n    for (const subValue of value) {\n      const subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);\n      if (subValidateResult !== true) {\n        invalidValues.push(subValidateResult.value);\n      }\n    }\n    return invalidValues.length === 0 ? true : { value: invalidValues };\n  }\n  deprecated(value, utils) {\n    const deprecatedResult = [];\n    for (const subValue of value) {\n      const subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);\n      if (subDeprecatedResult !== false) {\n        deprecatedResult.push(...subDeprecatedResult.map(({ value: deprecatedValue }) => ({\n          value: [deprecatedValue]\n        })));\n      }\n    }\n    return deprecatedResult;\n  }\n  forward(value, utils) {\n    const forwardResult = [];\n    for (const subValue of value) {\n      const subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);\n      forwardResult.push(...subForwardResult.map(wrapTransferResult));\n    }\n    return forwardResult;\n  }\n  redirect(value, utils) {\n    const remain = [];\n    const redirect = [];\n    for (const subValue of value) {\n      const subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);\n      if (\"remain\" in subRedirectResult) {\n        remain.push(subRedirectResult.remain);\n      }\n      redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));\n    }\n    return remain.length === 0 ? { redirect } : { redirect, remain };\n  }\n  overlap(currentValue, newValue) {\n    return currentValue.concat(newValue);\n  }\n};\nfunction wrapTransferResult({ from, to }) {\n  return { from: [from], to };\n}\n\n// node_modules/vnopts/lib/schemas/boolean.js\nvar BooleanSchema = class extends Schema {\n  expected() {\n    return \"true or false\";\n  }\n  validate(value) {\n    return typeof value === \"boolean\";\n  }\n};\n\n// node_modules/vnopts/lib/utils.js\nfunction recordFromArray(array2, mainKey) {\n  const record = /* @__PURE__ */ Object.create(null);\n  for (const value of array2) {\n    const key2 = value[mainKey];\n    if (record[key2]) {\n      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);\n    }\n    record[key2] = value;\n  }\n  return record;\n}\nfunction mapFromArray(array2, mainKey) {\n  const map2 = /* @__PURE__ */ new Map();\n  for (const value of array2) {\n    const key2 = value[mainKey];\n    if (map2.has(key2)) {\n      throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key2)}`);\n    }\n    map2.set(key2, value);\n  }\n  return map2;\n}\nfunction createAutoChecklist() {\n  const map2 = /* @__PURE__ */ Object.create(null);\n  return (id) => {\n    const idString = JSON.stringify(id);\n    if (map2[idString]) {\n      return true;\n    }\n    map2[idString] = true;\n    return false;\n  };\n}\nfunction partition(array2, predicate) {\n  const trueArray = [];\n  const falseArray = [];\n  for (const value of array2) {\n    if (predicate(value)) {\n      trueArray.push(value);\n    } else {\n      falseArray.push(value);\n    }\n  }\n  return [trueArray, falseArray];\n}\nfunction isInt(value) {\n  return value === Math.floor(value);\n}\nfunction comparePrimitive(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  const typeofA = typeof a;\n  const typeofB = typeof b;\n  const orders = [\n    \"undefined\",\n    \"object\",\n    \"boolean\",\n    \"number\",\n    \"string\"\n  ];\n  if (typeofA !== typeofB) {\n    return orders.indexOf(typeofA) - orders.indexOf(typeofB);\n  }\n  if (typeofA !== \"string\") {\n    return Number(a) - Number(b);\n  }\n  return a.localeCompare(b);\n}\nfunction normalizeInvalidHandler(invalidHandler) {\n  return (...args) => {\n    const errorMessageOrError = invalidHandler(...args);\n    return typeof errorMessageOrError === \"string\" ? new Error(errorMessageOrError) : errorMessageOrError;\n  };\n}\nfunction normalizeDefaultResult(result) {\n  return result === void 0 ? {} : result;\n}\nfunction normalizeExpectedResult(result) {\n  if (typeof result === \"string\") {\n    return { text: result };\n  }\n  const { text, list } = result;\n  assert((text || list) !== void 0, \"Unexpected `expected` result, there should be at least one field.\");\n  if (!list) {\n    return { text };\n  }\n  return {\n    text,\n    list: {\n      title: list.title,\n      values: list.values.map(normalizeExpectedResult)\n    }\n  };\n}\nfunction normalizeValidateResult(result, value) {\n  return result === true ? true : result === false ? { value } : result;\n}\nfunction normalizeDeprecatedResult(result, value, doNotNormalizeTrue = false) {\n  return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{ value }] : \"value\" in result ? [result] : result.length === 0 ? false : result;\n}\nfunction normalizeTransferResult(result, value) {\n  return typeof result === \"string\" || \"key\" in result ? { from: value, to: result } : \"from\" in result ? { from: result.from, to: result.to } : { from: value, to: result.to };\n}\nfunction normalizeForwardResult(result, value) {\n  return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];\n}\nfunction normalizeRedirectResult(result, value) {\n  const redirect = normalizeForwardResult(typeof result === \"object\" && \"redirect\" in result ? result.redirect : result, value);\n  return redirect.length === 0 ? { remain: value, redirect } : typeof result === \"object\" && \"remain\" in result ? { remain: result.remain, redirect } : { redirect };\n}\nfunction assert(isValid, message) {\n  if (!isValid) {\n    throw new Error(message);\n  }\n}\n\n// node_modules/vnopts/lib/schemas/choice.js\nvar ChoiceSchema = class extends Schema {\n  constructor(parameters) {\n    super(parameters);\n    this._choices = mapFromArray(parameters.choices.map((choice) => choice && typeof choice === \"object\" ? choice : { value: choice }), \"value\");\n  }\n  expected({ descriptor }) {\n    const choiceDescriptions = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter(({ hidden }) => !hidden).map((choiceInfo) => choiceInfo.value).sort(comparePrimitive).map(descriptor.value);\n    const head = choiceDescriptions.slice(0, -2);\n    const tail = choiceDescriptions.slice(-2);\n    const message = head.concat(tail.join(\" or \")).join(\", \");\n    return {\n      text: message,\n      list: {\n        title: \"one of the following values\",\n        values: choiceDescriptions\n      }\n    };\n  }\n  validate(value) {\n    return this._choices.has(value);\n  }\n  deprecated(value) {\n    const choiceInfo = this._choices.get(value);\n    return choiceInfo && choiceInfo.deprecated ? { value } : false;\n  }\n  forward(value) {\n    const choiceInfo = this._choices.get(value);\n    return choiceInfo ? choiceInfo.forward : void 0;\n  }\n  redirect(value) {\n    const choiceInfo = this._choices.get(value);\n    return choiceInfo ? choiceInfo.redirect : void 0;\n  }\n};\n\n// node_modules/vnopts/lib/schemas/number.js\nvar NumberSchema = class extends Schema {\n  expected() {\n    return \"a number\";\n  }\n  validate(value, _utils) {\n    return typeof value === \"number\";\n  }\n};\n\n// node_modules/vnopts/lib/schemas/integer.js\nvar IntegerSchema = class extends NumberSchema {\n  expected() {\n    return \"an integer\";\n  }\n  validate(value, utils) {\n    return utils.normalizeValidateResult(super.validate(value, utils), value) === true && isInt(value);\n  }\n};\n\n// node_modules/vnopts/lib/schemas/string.js\nvar StringSchema = class extends Schema {\n  expected() {\n    return \"a string\";\n  }\n  validate(value) {\n    return typeof value === \"string\";\n  }\n};\n\n// node_modules/vnopts/lib/defaults.js\nvar defaultDescriptor = apiDescriptor;\nvar defaultUnknownHandler = levenUnknownHandler;\nvar defaultInvalidHandler = commonInvalidHandler;\nvar defaultDeprecatedHandler = commonDeprecatedHandler;\n\n// node_modules/vnopts/lib/normalize.js\nvar Normalizer = class {\n  constructor(schemas, opts) {\n    const { logger = console, loggerPrintWidth = 80, descriptor = defaultDescriptor, unknown = defaultUnknownHandler, invalid = defaultInvalidHandler, deprecated = defaultDeprecatedHandler, missing = () => false, required = () => false, preprocess = (x) => x, postprocess = () => VALUE_UNCHANGED } = opts || {};\n    this._utils = {\n      descriptor,\n      logger: (\n        /* c8 ignore next */\n        logger || { warn: () => {\n        } }\n      ),\n      loggerPrintWidth,\n      schemas: recordFromArray(schemas, \"name\"),\n      normalizeDefaultResult,\n      normalizeExpectedResult,\n      normalizeDeprecatedResult,\n      normalizeForwardResult,\n      normalizeRedirectResult,\n      normalizeValidateResult\n    };\n    this._unknownHandler = unknown;\n    this._invalidHandler = normalizeInvalidHandler(invalid);\n    this._deprecatedHandler = deprecated;\n    this._identifyMissing = (k, o) => !(k in o) || missing(k, o);\n    this._identifyRequired = required;\n    this._preprocess = preprocess;\n    this._postprocess = postprocess;\n    this.cleanHistory();\n  }\n  cleanHistory() {\n    this._hasDeprecationWarned = createAutoChecklist();\n  }\n  normalize(options8) {\n    const newOptions = {};\n    const preprocessed = this._preprocess(options8, this._utils);\n    const restOptionsArray = [preprocessed];\n    const applyNormalization = () => {\n      while (restOptionsArray.length !== 0) {\n        const currentOptions = restOptionsArray.shift();\n        const transferredOptionsArray = this._applyNormalization(currentOptions, newOptions);\n        restOptionsArray.push(...transferredOptionsArray);\n      }\n    };\n    applyNormalization();\n    for (const key2 of Object.keys(this._utils.schemas)) {\n      const schema2 = this._utils.schemas[key2];\n      if (!(key2 in newOptions)) {\n        const defaultResult = normalizeDefaultResult(schema2.default(this._utils));\n        if (\"value\" in defaultResult) {\n          restOptionsArray.push({ [key2]: defaultResult.value });\n        }\n      }\n    }\n    applyNormalization();\n    for (const key2 of Object.keys(this._utils.schemas)) {\n      if (!(key2 in newOptions)) {\n        continue;\n      }\n      const schema2 = this._utils.schemas[key2];\n      const value = newOptions[key2];\n      const newValue = schema2.postprocess(value, this._utils);\n      if (newValue === VALUE_UNCHANGED) {\n        continue;\n      }\n      this._applyValidation(newValue, key2, schema2);\n      newOptions[key2] = newValue;\n    }\n    this._applyPostprocess(newOptions);\n    this._applyRequiredCheck(newOptions);\n    return newOptions;\n  }\n  _applyNormalization(options8, newOptions) {\n    const transferredOptionsArray = [];\n    const { knownKeys, unknownKeys } = this._partitionOptionKeys(options8);\n    for (const key2 of knownKeys) {\n      const schema2 = this._utils.schemas[key2];\n      const value = schema2.preprocess(options8[key2], this._utils);\n      this._applyValidation(value, key2, schema2);\n      const appendTransferredOptions = ({ from, to }) => {\n        transferredOptionsArray.push(typeof to === \"string\" ? { [to]: from } : { [to.key]: to.value });\n      };\n      const warnDeprecated = ({ value: currentValue, redirectTo }) => {\n        const deprecatedResult = normalizeDeprecatedResult(\n          schema2.deprecated(currentValue, this._utils),\n          value,\n          /* doNotNormalizeTrue */\n          true\n        );\n        if (deprecatedResult === false) {\n          return;\n        }\n        if (deprecatedResult === true) {\n          if (!this._hasDeprecationWarned(key2)) {\n            this._utils.logger.warn(this._deprecatedHandler(key2, redirectTo, this._utils));\n          }\n        } else {\n          for (const { value: deprecatedValue } of deprecatedResult) {\n            const pair = { key: key2, value: deprecatedValue };\n            if (!this._hasDeprecationWarned(pair)) {\n              const redirectToPair = typeof redirectTo === \"string\" ? { key: redirectTo, value: deprecatedValue } : redirectTo;\n              this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));\n            }\n          }\n        }\n      };\n      const forwardResult = normalizeForwardResult(schema2.forward(value, this._utils), value);\n      forwardResult.forEach(appendTransferredOptions);\n      const redirectResult = normalizeRedirectResult(schema2.redirect(value, this._utils), value);\n      redirectResult.redirect.forEach(appendTransferredOptions);\n      if (\"remain\" in redirectResult) {\n        const remainingValue = redirectResult.remain;\n        newOptions[key2] = key2 in newOptions ? schema2.overlap(newOptions[key2], remainingValue, this._utils) : remainingValue;\n        warnDeprecated({ value: remainingValue });\n      }\n      for (const { from, to } of redirectResult.redirect) {\n        warnDeprecated({ value: from, redirectTo: to });\n      }\n    }\n    for (const key2 of unknownKeys) {\n      const value = options8[key2];\n      this._applyUnknownHandler(key2, value, newOptions, (knownResultKey, knownResultValue) => {\n        transferredOptionsArray.push({ [knownResultKey]: knownResultValue });\n      });\n    }\n    return transferredOptionsArray;\n  }\n  _applyRequiredCheck(options8) {\n    for (const key2 of Object.keys(this._utils.schemas)) {\n      if (this._identifyMissing(key2, options8)) {\n        if (this._identifyRequired(key2)) {\n          throw this._invalidHandler(key2, VALUE_NOT_EXIST, this._utils);\n        }\n      }\n    }\n  }\n  _partitionOptionKeys(options8) {\n    const [knownKeys, unknownKeys] = partition(Object.keys(options8).filter((key2) => !this._identifyMissing(key2, options8)), (key2) => key2 in this._utils.schemas);\n    return { knownKeys, unknownKeys };\n  }\n  _applyValidation(value, key2, schema2) {\n    const validateResult = normalizeValidateResult(schema2.validate(value, this._utils), value);\n    if (validateResult !== true) {\n      throw this._invalidHandler(key2, validateResult.value, this._utils);\n    }\n  }\n  _applyUnknownHandler(key2, value, newOptions, knownResultHandler) {\n    const unknownResult = this._unknownHandler(key2, value, this._utils);\n    if (!unknownResult) {\n      return;\n    }\n    for (const resultKey of Object.keys(unknownResult)) {\n      if (this._identifyMissing(resultKey, unknownResult)) {\n        continue;\n      }\n      const resultValue = unknownResult[resultKey];\n      if (resultKey in this._utils.schemas) {\n        knownResultHandler(resultKey, resultValue);\n      } else {\n        newOptions[resultKey] = resultValue;\n      }\n    }\n  }\n  _applyPostprocess(options8) {\n    const postprocessed = this._postprocess(options8, this._utils);\n    if (postprocessed === VALUE_UNCHANGED) {\n      return;\n    }\n    if (postprocessed.delete) {\n      for (const deleteKey of postprocessed.delete) {\n        delete options8[deleteKey];\n      }\n    }\n    if (postprocessed.override) {\n      const { knownKeys, unknownKeys } = this._partitionOptionKeys(postprocessed.override);\n      for (const key2 of knownKeys) {\n        const value = postprocessed.override[key2];\n        this._applyValidation(value, key2, this._utils.schemas[key2]);\n        options8[key2] = value;\n      }\n      for (const key2 of unknownKeys) {\n        const value = postprocessed.override[key2];\n        this._applyUnknownHandler(key2, value, options8, (knownResultKey, knownResultValue) => {\n          const schema2 = this._utils.schemas[knownResultKey];\n          this._applyValidation(knownResultValue, knownResultKey, schema2);\n          options8[knownResultKey] = knownResultValue;\n        });\n      }\n    }\n  }\n};\n\n// src/common/errors.js\nvar errors_exports = {};\n__export(errors_exports, {\n  ArgExpansionBailout: () => ArgExpansionBailout,\n  ConfigError: () => ConfigError,\n  UndefinedParserError: () => UndefinedParserError\n});\nvar ConfigError = class extends Error {\n  name = \"ConfigError\";\n};\nvar UndefinedParserError = class extends Error {\n  name = \"UndefinedParserError\";\n};\nvar ArgExpansionBailout = class extends Error {\n  name = \"ArgExpansionBailout\";\n};\n\n// src/config/resolve-config.js\nvar import_micromatch = __toESM(require_micromatch(), 1);\nimport path9 from \"path\";\n\n// node_modules/url-or-path/index.js\nimport { fileURLToPath, pathToFileURL } from \"url\";\nvar isUrlInstance = (value) => value instanceof URL;\nvar isUrlString = (value) => typeof value === \"string\" && value.startsWith(\"file://\");\nvar isUrl = (urlOrPath) => isUrlInstance(urlOrPath) || isUrlString(urlOrPath);\nvar toPath = (urlOrPath) => isUrl(urlOrPath) ? fileURLToPath(urlOrPath) : urlOrPath;\n\n// src/utils/partition.js\nfunction partition2(array2, predicate) {\n  const result = [[], []];\n  for (const value of array2) {\n    result[predicate(value) ? 0 : 1].push(value);\n  }\n  return result;\n}\nvar partition_default = partition2;\n\n// src/config/editorconfig/index.js\nvar import_editorconfig = __toESM(require_src(), 1);\nimport path4 from \"path\";\n\n// src/config/find-project-root.js\nimport * as path3 from \"path\";\n\n// src/utils/is-directory.js\nimport fs from \"fs/promises\";\nasync function isDirectory(directory, options8) {\n  const allowSymlinks = (options8 == null ? void 0 : options8.allowSymlinks) ?? true;\n  let stats;\n  try {\n    stats = await (allowSymlinks ? fs.stat : fs.lstat)(toPath(directory));\n  } catch {\n    return false;\n  }\n  return stats.isDirectory();\n}\nvar is_directory_default = isDirectory;\n\n// src/config/searcher.js\nimport path2 from \"path\";\n\n// node_modules/iterate-directory-up/index.js\nimport * as path from \"path\";\nvar toAbsolutePath = (value) => path.resolve(toPath(value));\nfunction* iterateDirectoryUp(from, to) {\n  from = toAbsolutePath(from);\n  const { root: root2 } = path.parse(from);\n  to = to ? toAbsolutePath(to) : root2;\n  if (from !== to && !from.startsWith(to)) {\n    return;\n  }\n  for (let directory = from; directory !== to; directory = path.dirname(directory)) {\n    yield directory;\n  }\n  yield to;\n}\nvar iterate_directory_up_default = iterateDirectoryUp;\n\n// src/config/searcher.js\nvar _names, _filter, _stopDirectory, _cache, _searchInDirectory, searchInDirectory_fn;\nvar Searcher = class {\n  /**\n   * @param {{\n   *   names: string[],\n   *   filter: (fileOrDirectory: {name: string, path: string}) => Promise<boolean>,\n   *   stopDirectory?: string,\n   * }} param0\n   */\n  constructor({ names, filter: filter2, stopDirectory }) {\n    __privateAdd(this, _searchInDirectory);\n    __privateAdd(this, _names, void 0);\n    __privateAdd(this, _filter, void 0);\n    __privateAdd(this, _stopDirectory, void 0);\n    __privateAdd(this, _cache, /* @__PURE__ */ new Map());\n    __privateSet(this, _names, names);\n    __privateSet(this, _filter, filter2);\n    __privateSet(this, _stopDirectory, stopDirectory);\n  }\n  async search(startDirectory, { shouldCache }) {\n    const cache3 = __privateGet(this, _cache);\n    if (shouldCache && cache3.has(startDirectory)) {\n      return cache3.get(startDirectory);\n    }\n    const searchedDirectories = [];\n    let result;\n    for (const directory of iterate_directory_up_default(\n      startDirectory,\n      __privateGet(this, _stopDirectory)\n    )) {\n      searchedDirectories.push(directory);\n      result = await __privateMethod(this, _searchInDirectory, searchInDirectory_fn).call(this, directory, shouldCache);\n      if (result) {\n        break;\n      }\n    }\n    for (const directory of searchedDirectories) {\n      cache3.set(directory, result);\n    }\n    return result;\n  }\n  clearCache() {\n    __privateGet(this, _cache).clear();\n  }\n};\n_names = new WeakMap();\n_filter = new WeakMap();\n_stopDirectory = new WeakMap();\n_cache = new WeakMap();\n_searchInDirectory = new WeakSet();\nsearchInDirectory_fn = async function(directory, shouldCache) {\n  const cache3 = __privateGet(this, _cache);\n  if (shouldCache && cache3.has(directory)) {\n    return cache3.get(directory);\n  }\n  for (const name of __privateGet(this, _names)) {\n    const fileOrDirectory = path2.join(directory, name);\n    if (await __privateGet(this, _filter).call(this, { name, path: fileOrDirectory })) {\n      return fileOrDirectory;\n    }\n  }\n};\nvar searcher_default = Searcher;\n\n// src/config/find-project-root.js\nvar MARKERS = [\".git\", \".hg\"];\nvar searcher;\nvar searchOptions = {\n  names: MARKERS,\n  filter: ({ path: directory }) => is_directory_default(directory, { allowSymlinks: false })\n};\nasync function findProjectRoot(startDirectory, options8) {\n  searcher ?? (searcher = new searcher_default(searchOptions));\n  const mark = await searcher.search(startDirectory, options8);\n  return mark ? path3.dirname(mark) : void 0;\n}\nfunction clearFindProjectRootCache() {\n  searcher == null ? void 0 : searcher.clearCache();\n}\n\n// src/config/editorconfig/editorconfig-to-prettier.js\nfunction removeUnset(editorConfig) {\n  const result = {};\n  const keys = Object.keys(editorConfig);\n  for (let i = 0; i < keys.length; i++) {\n    const key2 = keys[i];\n    if (editorConfig[key2] === \"unset\") {\n      continue;\n    }\n    result[key2] = editorConfig[key2];\n  }\n  return result;\n}\nfunction editorConfigToPrettier(editorConfig) {\n  if (!editorConfig) {\n    return null;\n  }\n  editorConfig = removeUnset(editorConfig);\n  if (Object.keys(editorConfig).length === 0) {\n    return null;\n  }\n  const result = {};\n  if (editorConfig.indent_style) {\n    result.useTabs = editorConfig.indent_style === \"tab\";\n  }\n  if (editorConfig.indent_size === \"tab\") {\n    result.useTabs = true;\n  }\n  if (result.useTabs && editorConfig.tab_width) {\n    result.tabWidth = editorConfig.tab_width;\n  } else if (editorConfig.indent_style === \"space\" && editorConfig.indent_size && editorConfig.indent_size !== \"tab\") {\n    result.tabWidth = editorConfig.indent_size;\n  } else if (editorConfig.tab_width !== void 0) {\n    result.tabWidth = editorConfig.tab_width;\n  }\n  if (editorConfig.max_line_length) {\n    if (editorConfig.max_line_length === \"off\") {\n      result.printWidth = Number.POSITIVE_INFINITY;\n    } else {\n      result.printWidth = editorConfig.max_line_length;\n    }\n  }\n  if (editorConfig.quote_type === \"single\") {\n    result.singleQuote = true;\n  } else if (editorConfig.quote_type === \"double\") {\n    result.singleQuote = false;\n  }\n  if ([\"cr\", \"crlf\", \"lf\"].includes(editorConfig.end_of_line)) {\n    result.endOfLine = editorConfig.end_of_line;\n  }\n  return result;\n}\nvar editorconfig_to_prettier_default = editorConfigToPrettier;\n\n// src/config/editorconfig/index.js\nvar editorconfigCache = /* @__PURE__ */ new Map();\nfunction clearEditorconfigCache() {\n  clearFindProjectRootCache();\n  editorconfigCache.clear();\n}\nasync function loadEditorconfigInternal(file, { shouldCache }) {\n  const directory = path4.dirname(file);\n  const root2 = await findProjectRoot(directory, { shouldCache });\n  const editorConfig = await import_editorconfig.default.parse(file, { root: root2 });\n  const config = editorconfig_to_prettier_default(editorConfig);\n  return config;\n}\nfunction loadEditorconfig(file, { shouldCache }) {\n  file = path4.resolve(file);\n  if (!shouldCache || !editorconfigCache.has(file)) {\n    editorconfigCache.set(\n      file,\n      loadEditorconfigInternal(file, { shouldCache })\n    );\n  }\n  return editorconfigCache.get(file);\n}\n\n// src/config/prettier-config/index.js\nimport path8 from \"path\";\n\n// src/common/mockable.js\nvar import_ci_info = __toESM(require_ci_info(), 1);\nimport fs2 from \"fs/promises\";\n\n// node_modules/get-stdin/index.js\nvar { stdin } = process;\nasync function getStdin() {\n  let result = \"\";\n  if (stdin.isTTY) {\n    return result;\n  }\n  stdin.setEncoding(\"utf8\");\n  for await (const chunk of stdin) {\n    result += chunk;\n  }\n  return result;\n}\ngetStdin.buffer = async () => {\n  const result = [];\n  let length = 0;\n  if (stdin.isTTY) {\n    return Buffer.concat([]);\n  }\n  for await (const chunk of stdin) {\n    result.push(chunk);\n    length += chunk.length;\n  }\n  return Buffer.concat(result, length);\n};\n\n// src/common/mockable.js\nfunction writeFormattedFile(file, data) {\n  return fs2.writeFile(file, data);\n}\nvar mockable = {\n  getPrettierConfigSearchStopDirectory: () => void 0,\n  getStdin,\n  isCI: () => import_ci_info.isCI,\n  writeFormattedFile\n};\nvar mockable_default = mockable;\n\n// src/utils/is-file.js\nimport fs3 from \"fs/promises\";\nasync function isFile(file, options8) {\n  const allowSymlinks = (options8 == null ? void 0 : options8.allowSymlinks) ?? true;\n  let stats;\n  try {\n    stats = await (allowSymlinks ? fs3.stat : fs3.lstat)(toPath(file));\n  } catch {\n    return false;\n  }\n  return stats.isFile();\n}\nvar is_file_default = isFile;\n\n// src/config/prettier-config/loaders.js\nvar import_parse_async = __toESM(require_parse_async(), 1);\nimport { pathToFileURL as pathToFileURL2 } from \"url\";\n\n// node_modules/js-yaml/dist/js-yaml.mjs\nfunction isNothing(subject) {\n  return typeof subject === \"undefined\" || subject === null;\n}\nfunction isObject(subject) {\n  return typeof subject === \"object\" && subject !== null;\n}\nfunction toArray(sequence) {\n  if (Array.isArray(sequence))\n    return sequence;\n  else if (isNothing(sequence))\n    return [];\n  return [sequence];\n}\nfunction extend(target, source2) {\n  var index, length, key2, sourceKeys;\n  if (source2) {\n    sourceKeys = Object.keys(source2);\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key2 = sourceKeys[index];\n      target[key2] = source2[key2];\n    }\n  }\n  return target;\n}\nfunction repeat(string, count) {\n  var result = \"\", cycle;\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n  return result;\n}\nfunction isNegativeZero(number) {\n  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n}\nvar isNothing_1 = isNothing;\nvar isObject_1 = isObject;\nvar toArray_1 = toArray;\nvar repeat_1 = repeat;\nvar isNegativeZero_1 = isNegativeZero;\nvar extend_1 = extend;\nvar common = {\n  isNothing: isNothing_1,\n  isObject: isObject_1,\n  toArray: toArray_1,\n  repeat: repeat_1,\n  isNegativeZero: isNegativeZero_1,\n  extend: extend_1\n};\nfunction formatError(exception2, compact) {\n  var where = \"\", message = exception2.reason || \"(unknown reason)\";\n  if (!exception2.mark)\n    return message;\n  if (exception2.mark.name) {\n    where += 'in \"' + exception2.mark.name + '\" ';\n  }\n  where += \"(\" + (exception2.mark.line + 1) + \":\" + (exception2.mark.column + 1) + \")\";\n  if (!compact && exception2.mark.snippet) {\n    where += \"\\n\\n\" + exception2.mark.snippet;\n  }\n  return message + \" \" + where;\n}\nfunction YAMLException$1(reason, mark) {\n  Error.call(this);\n  this.name = \"YAMLException\";\n  this.reason = reason;\n  this.mark = mark;\n  this.message = formatError(this, false);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    this.stack = new Error().stack || \"\";\n  }\n}\nYAMLException$1.prototype = Object.create(Error.prototype);\nYAMLException$1.prototype.constructor = YAMLException$1;\nYAMLException$1.prototype.toString = function toString(compact) {\n  return this.name + \": \" + formatError(this, compact);\n};\nvar exception = YAMLException$1;\nfunction getLine(buffer2, lineStart, lineEnd, position, maxLineLength) {\n  var head = \"\";\n  var tail = \"\";\n  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n  if (position - lineStart > maxHalfLength) {\n    head = \" ... \";\n    lineStart = position - maxHalfLength + head.length;\n  }\n  if (lineEnd - position > maxHalfLength) {\n    tail = \" ...\";\n    lineEnd = position + maxHalfLength - tail.length;\n  }\n  return {\n    str: head + buffer2.slice(lineStart, lineEnd).replace(/\\t/g, \"\\u2192\") + tail,\n    pos: position - lineStart + head.length\n    // relative position\n  };\n}\nfunction padStart(string, max) {\n  return common.repeat(\" \", max - string.length) + string;\n}\nfunction makeSnippet(mark, options8) {\n  options8 = Object.create(options8 || null);\n  if (!mark.buffer)\n    return null;\n  if (!options8.maxLength)\n    options8.maxLength = 79;\n  if (typeof options8.indent !== \"number\")\n    options8.indent = 1;\n  if (typeof options8.linesBefore !== \"number\")\n    options8.linesBefore = 3;\n  if (typeof options8.linesAfter !== \"number\")\n    options8.linesAfter = 2;\n  var re = /\\r?\\n|\\r|\\0/g;\n  var lineStarts = [0];\n  var lineEnds = [];\n  var match;\n  var foundLineNo = -1;\n  while (match = re.exec(mark.buffer)) {\n    lineEnds.push(match.index);\n    lineStarts.push(match.index + match[0].length);\n    if (mark.position <= match.index && foundLineNo < 0) {\n      foundLineNo = lineStarts.length - 2;\n    }\n  }\n  if (foundLineNo < 0)\n    foundLineNo = lineStarts.length - 1;\n  var result = \"\", i, line3;\n  var lineNoLength = Math.min(mark.line + options8.linesAfter, lineEnds.length).toString().length;\n  var maxLineLength = options8.maxLength - (options8.indent + lineNoLength + 3);\n  for (i = 1; i <= options8.linesBefore; i++) {\n    if (foundLineNo - i < 0)\n      break;\n    line3 = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo - i],\n      lineEnds[foundLineNo - i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n      maxLineLength\n    );\n    result = common.repeat(\" \", options8.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + \" | \" + line3.str + \"\\n\" + result;\n  }\n  line3 = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n  result += common.repeat(\" \", options8.indent) + padStart((mark.line + 1).toString(), lineNoLength) + \" | \" + line3.str + \"\\n\";\n  result += common.repeat(\"-\", options8.indent + lineNoLength + 3 + line3.pos) + \"^\\n\";\n  for (i = 1; i <= options8.linesAfter; i++) {\n    if (foundLineNo + i >= lineEnds.length)\n      break;\n    line3 = getLine(\n      mark.buffer,\n      lineStarts[foundLineNo + i],\n      lineEnds[foundLineNo + i],\n      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n      maxLineLength\n    );\n    result += common.repeat(\" \", options8.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + \" | \" + line3.str + \"\\n\";\n  }\n  return result.replace(/\\n$/, \"\");\n}\nvar snippet = makeSnippet;\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  \"kind\",\n  \"multi\",\n  \"resolve\",\n  \"construct\",\n  \"instanceOf\",\n  \"predicate\",\n  \"represent\",\n  \"representName\",\n  \"defaultStyle\",\n  \"styleAliases\"\n];\nvar YAML_NODE_KINDS = [\n  \"scalar\",\n  \"sequence\",\n  \"mapping\"\n];\nfunction compileStyleAliases(map2) {\n  var result = {};\n  if (map2 !== null) {\n    Object.keys(map2).forEach(function(style) {\n      map2[style].forEach(function(alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n  return result;\n}\nfunction Type$1(tag, options8) {\n  options8 = options8 || {};\n  Object.keys(options8).forEach(function(name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n  this.options = options8;\n  this.tag = tag;\n  this.kind = options8[\"kind\"] || null;\n  this.resolve = options8[\"resolve\"] || function() {\n    return true;\n  };\n  this.construct = options8[\"construct\"] || function(data) {\n    return data;\n  };\n  this.instanceOf = options8[\"instanceOf\"] || null;\n  this.predicate = options8[\"predicate\"] || null;\n  this.represent = options8[\"represent\"] || null;\n  this.representName = options8[\"representName\"] || null;\n  this.defaultStyle = options8[\"defaultStyle\"] || null;\n  this.multi = options8[\"multi\"] || false;\n  this.styleAliases = compileStyleAliases(options8[\"styleAliases\"] || null);\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\nvar type = Type$1;\nfunction compileList(schema2, name) {\n  var result = [];\n  schema2[name].forEach(function(currentType) {\n    var newIndex = result.length;\n    result.forEach(function(previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n        newIndex = previousIndex;\n      }\n    });\n    result[newIndex] = currentType;\n  });\n  return result;\n}\nfunction compileMap() {\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {},\n    multi: {\n      scalar: [],\n      sequence: [],\n      mapping: [],\n      fallback: []\n    }\n  }, index, length;\n  function collectType(type2) {\n    if (type2.multi) {\n      result.multi[type2.kind].push(type2);\n      result.multi[\"fallback\"].push(type2);\n    } else {\n      result[type2.kind][type2.tag] = result[\"fallback\"][type2.tag] = type2;\n    }\n  }\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\nfunction Schema$1(definition) {\n  return this.extend(definition);\n}\nSchema$1.prototype.extend = function extend2(definition) {\n  var implicit = [];\n  var explicit = [];\n  if (definition instanceof type) {\n    explicit.push(definition);\n  } else if (Array.isArray(definition)) {\n    explicit = explicit.concat(definition);\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    if (definition.implicit)\n      implicit = implicit.concat(definition.implicit);\n    if (definition.explicit)\n      explicit = explicit.concat(definition.explicit);\n  } else {\n    throw new exception(\"Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })\");\n  }\n  implicit.forEach(function(type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n    }\n    if (type$1.loadKind && type$1.loadKind !== \"scalar\") {\n      throw new exception(\"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.\");\n    }\n    if (type$1.multi) {\n      throw new exception(\"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.\");\n    }\n  });\n  explicit.forEach(function(type$1) {\n    if (!(type$1 instanceof type)) {\n      throw new exception(\"Specified list of YAML types (or a single Type object) contains a non-Type object.\");\n    }\n  });\n  var result = Object.create(Schema$1.prototype);\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n  result.compiledImplicit = compileList(result, \"implicit\");\n  result.compiledExplicit = compileList(result, \"explicit\");\n  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n  return result;\n};\nvar schema = Schema$1;\nvar str = new type(\"tag:yaml.org,2002:str\", {\n  kind: \"scalar\",\n  construct: function(data) {\n    return data !== null ? data : \"\";\n  }\n});\nvar seq = new type(\"tag:yaml.org,2002:seq\", {\n  kind: \"sequence\",\n  construct: function(data) {\n    return data !== null ? data : [];\n  }\n});\nvar map = new type(\"tag:yaml.org,2002:map\", {\n  kind: \"mapping\",\n  construct: function(data) {\n    return data !== null ? data : {};\n  }\n});\nvar failsafe = new schema({\n  explicit: [\n    str,\n    seq,\n    map\n  ]\n});\nfunction resolveYamlNull(data) {\n  if (data === null)\n    return true;\n  var max = data.length;\n  return max === 1 && data === \"~\" || max === 4 && (data === \"null\" || data === \"Null\" || data === \"NULL\");\n}\nfunction constructYamlNull() {\n  return null;\n}\nfunction isNull(object) {\n  return object === null;\n}\nvar _null = new type(\"tag:yaml.org,2002:null\", {\n  kind: \"scalar\",\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function() {\n      return \"~\";\n    },\n    lowercase: function() {\n      return \"null\";\n    },\n    uppercase: function() {\n      return \"NULL\";\n    },\n    camelcase: function() {\n      return \"Null\";\n    },\n    empty: function() {\n      return \"\";\n    }\n  },\n  defaultStyle: \"lowercase\"\n});\nfunction resolveYamlBoolean(data) {\n  if (data === null)\n    return false;\n  var max = data.length;\n  return max === 4 && (data === \"true\" || data === \"True\" || data === \"TRUE\") || max === 5 && (data === \"false\" || data === \"False\" || data === \"FALSE\");\n}\nfunction constructYamlBoolean(data) {\n  return data === \"true\" || data === \"True\" || data === \"TRUE\";\n}\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === \"[object Boolean]\";\n}\nvar bool = new type(\"tag:yaml.org,2002:bool\", {\n  kind: \"scalar\",\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function(object) {\n      return object ? \"true\" : \"false\";\n    },\n    uppercase: function(object) {\n      return object ? \"TRUE\" : \"FALSE\";\n    },\n    camelcase: function(object) {\n      return object ? \"True\" : \"False\";\n    }\n  },\n  defaultStyle: \"lowercase\"\n});\nfunction isHexCode(c2) {\n  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;\n}\nfunction isOctCode(c2) {\n  return 48 <= c2 && c2 <= 55;\n}\nfunction isDecCode(c2) {\n  return 48 <= c2 && c2 <= 57;\n}\nfunction resolveYamlInteger(data) {\n  if (data === null)\n    return false;\n  var max = data.length, index = 0, hasDigits = false, ch;\n  if (!max)\n    return false;\n  ch = data[index];\n  if (ch === \"-\" || ch === \"+\") {\n    ch = data[++index];\n  }\n  if (ch === \"0\") {\n    if (index + 1 === max)\n      return true;\n    ch = data[++index];\n    if (ch === \"b\") {\n      index++;\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === \"_\")\n          continue;\n        if (ch !== \"0\" && ch !== \"1\")\n          return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== \"_\";\n    }\n    if (ch === \"x\") {\n      index++;\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === \"_\")\n          continue;\n        if (!isHexCode(data.charCodeAt(index)))\n          return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== \"_\";\n    }\n    if (ch === \"o\") {\n      index++;\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === \"_\")\n          continue;\n        if (!isOctCode(data.charCodeAt(index)))\n          return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== \"_\";\n    }\n  }\n  if (ch === \"_\")\n    return false;\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === \"_\")\n      continue;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n  if (!hasDigits || ch === \"_\")\n    return false;\n  return true;\n}\nfunction constructYamlInteger(data) {\n  var value = data, sign2 = 1, ch;\n  if (value.indexOf(\"_\") !== -1) {\n    value = value.replace(/_/g, \"\");\n  }\n  ch = value[0];\n  if (ch === \"-\" || ch === \"+\") {\n    if (ch === \"-\")\n      sign2 = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n  if (value === \"0\")\n    return 0;\n  if (ch === \"0\") {\n    if (value[1] === \"b\")\n      return sign2 * parseInt(value.slice(2), 2);\n    if (value[1] === \"x\")\n      return sign2 * parseInt(value.slice(2), 16);\n    if (value[1] === \"o\")\n      return sign2 * parseInt(value.slice(2), 8);\n  }\n  return sign2 * parseInt(value, 10);\n}\nfunction isInteger(object) {\n  return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 === 0 && !common.isNegativeZero(object));\n}\nvar int = new type(\"tag:yaml.org,2002:int\", {\n  kind: \"scalar\",\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary: function(obj) {\n      return obj >= 0 ? \"0b\" + obj.toString(2) : \"-0b\" + obj.toString(2).slice(1);\n    },\n    octal: function(obj) {\n      return obj >= 0 ? \"0o\" + obj.toString(8) : \"-0o\" + obj.toString(8).slice(1);\n    },\n    decimal: function(obj) {\n      return obj.toString(10);\n    },\n    /* eslint-disable max-len */\n    hexadecimal: function(obj) {\n      return obj >= 0 ? \"0x\" + obj.toString(16).toUpperCase() : \"-0x\" + obj.toString(16).toUpperCase().slice(1);\n    }\n  },\n  defaultStyle: \"decimal\",\n  styleAliases: {\n    binary: [2, \"bin\"],\n    octal: [8, \"oct\"],\n    decimal: [10, \"dec\"],\n    hexadecimal: [16, \"hex\"]\n  }\n});\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  \"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\\\.(?:inf|Inf|INF)|\\\\.(?:nan|NaN|NAN))$\"\n);\nfunction resolveYamlFloat(data) {\n  if (data === null)\n    return false;\n  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n  // Probably should update regexp & check speed\n  data[data.length - 1] === \"_\") {\n    return false;\n  }\n  return true;\n}\nfunction constructYamlFloat(data) {\n  var value, sign2;\n  value = data.replace(/_/g, \"\").toLowerCase();\n  sign2 = value[0] === \"-\" ? -1 : 1;\n  if (\"+-\".indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n  if (value === \".inf\") {\n    return sign2 === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n  } else if (value === \".nan\") {\n    return NaN;\n  }\n  return sign2 * parseFloat(value, 10);\n}\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\nfunction representYamlFloat(object, style) {\n  var res;\n  if (isNaN(object)) {\n    switch (style) {\n      case \"lowercase\":\n        return \".nan\";\n      case \"uppercase\":\n        return \".NAN\";\n      case \"camelcase\":\n        return \".NaN\";\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case \"lowercase\":\n        return \".inf\";\n      case \"uppercase\":\n        return \".INF\";\n      case \"camelcase\":\n        return \".Inf\";\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case \"lowercase\":\n        return \"-.inf\";\n      case \"uppercase\":\n        return \"-.INF\";\n      case \"camelcase\":\n        return \"-.Inf\";\n    }\n  } else if (common.isNegativeZero(object)) {\n    return \"-0.0\";\n  }\n  res = object.toString(10);\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace(\"e\", \".e\") : res;\n}\nfunction isFloat(object) {\n  return Object.prototype.toString.call(object) === \"[object Number]\" && (object % 1 !== 0 || common.isNegativeZero(object));\n}\nvar float = new type(\"tag:yaml.org,2002:float\", {\n  kind: \"scalar\",\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: \"lowercase\"\n});\nvar json = failsafe.extend({\n  implicit: [\n    _null,\n    bool,\n    int,\n    float\n  ]\n});\nvar core = json;\nvar YAML_DATE_REGEXP = new RegExp(\n  \"^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$\"\n);\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  \"^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\\\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\\\.([0-9]*))?(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$\"\n);\nfunction resolveYamlTimestamp(data) {\n  if (data === null)\n    return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null)\n    return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)\n    return true;\n  return false;\n}\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null)\n    match = YAML_TIMESTAMP_REGEXP.exec(data);\n  if (match === null)\n    throw new Error(\"Date resolve error\");\n  year = +match[1];\n  month = +match[2] - 1;\n  day = +match[3];\n  if (!match[4]) {\n    return new Date(Date.UTC(year, month, day));\n  }\n  hour = +match[4];\n  minute = +match[5];\n  second = +match[6];\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) {\n      fraction += \"0\";\n    }\n    fraction = +fraction;\n  }\n  if (match[9]) {\n    tz_hour = +match[10];\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 6e4;\n    if (match[9] === \"-\")\n      delta = -delta;\n  }\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n  if (delta)\n    date.setTime(date.getTime() - delta);\n  return date;\n}\nfunction representYamlTimestamp(object) {\n  return object.toISOString();\n}\nvar timestamp = new type(\"tag:yaml.org,2002:timestamp\", {\n  kind: \"scalar\",\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\nfunction resolveYamlMerge(data) {\n  return data === \"<<\" || data === null;\n}\nvar merge = new type(\"tag:yaml.org,2002:merge\", {\n  kind: \"scalar\",\n  resolve: resolveYamlMerge\n});\nvar BASE64_MAP = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r\";\nfunction resolveYamlBinary(data) {\n  if (data === null)\n    return false;\n  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;\n  for (idx = 0; idx < max; idx++) {\n    code = map2.indexOf(data.charAt(idx));\n    if (code > 64)\n      continue;\n    if (code < 0)\n      return false;\n    bitlen += 6;\n  }\n  return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n  var idx, tailbits, input = data.replace(/[\\r\\n=]/g, \"\"), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 255);\n      result.push(bits >> 8 & 255);\n      result.push(bits & 255);\n    }\n    bits = bits << 6 | map2.indexOf(input.charAt(idx));\n  }\n  tailbits = max % 4 * 6;\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 255);\n    result.push(bits >> 8 & 255);\n    result.push(bits & 255);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 255);\n    result.push(bits >> 2 & 255);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 255);\n  }\n  return new Uint8Array(result);\n}\nfunction representYamlBinary(object) {\n  var result = \"\", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map2[bits >> 18 & 63];\n      result += map2[bits >> 12 & 63];\n      result += map2[bits >> 6 & 63];\n      result += map2[bits & 63];\n    }\n    bits = (bits << 8) + object[idx];\n  }\n  tail = max % 3;\n  if (tail === 0) {\n    result += map2[bits >> 18 & 63];\n    result += map2[bits >> 12 & 63];\n    result += map2[bits >> 6 & 63];\n    result += map2[bits & 63];\n  } else if (tail === 2) {\n    result += map2[bits >> 10 & 63];\n    result += map2[bits >> 4 & 63];\n    result += map2[bits << 2 & 63];\n    result += map2[64];\n  } else if (tail === 1) {\n    result += map2[bits >> 2 & 63];\n    result += map2[bits << 4 & 63];\n    result += map2[64];\n    result += map2[64];\n  }\n  return result;\n}\nfunction isBinary(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Uint8Array]\";\n}\nvar binary = new type(\"tag:yaml.org,2002:binary\", {\n  kind: \"scalar\",\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\nvar _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\nvar _toString$2 = Object.prototype.toString;\nfunction resolveYamlOmap(data) {\n  if (data === null)\n    return true;\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n    if (_toString$2.call(pair) !== \"[object Object]\")\n      return false;\n    for (pairKey in pair) {\n      if (_hasOwnProperty$3.call(pair, pairKey)) {\n        if (!pairHasKey)\n          pairHasKey = true;\n        else\n          return false;\n      }\n    }\n    if (!pairHasKey)\n      return false;\n    if (objectKeys.indexOf(pairKey) === -1)\n      objectKeys.push(pairKey);\n    else\n      return false;\n  }\n  return true;\n}\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\nvar omap = new type(\"tag:yaml.org,2002:omap\", {\n  kind: \"sequence\",\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\nvar _toString$1 = Object.prototype.toString;\nfunction resolveYamlPairs(data) {\n  if (data === null)\n    return true;\n  var index, length, pair, keys, result, object = data;\n  result = new Array(object.length);\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    if (_toString$1.call(pair) !== \"[object Object]\")\n      return false;\n    keys = Object.keys(pair);\n    if (keys.length !== 1)\n      return false;\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n  return true;\n}\nfunction constructYamlPairs(data) {\n  if (data === null)\n    return [];\n  var index, length, pair, keys, result, object = data;\n  result = new Array(object.length);\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    keys = Object.keys(pair);\n    result[index] = [keys[0], pair[keys[0]]];\n  }\n  return result;\n}\nvar pairs = new type(\"tag:yaml.org,2002:pairs\", {\n  kind: \"sequence\",\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\nvar _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\nfunction resolveYamlSet(data) {\n  if (data === null)\n    return true;\n  var key2, object = data;\n  for (key2 in object) {\n    if (_hasOwnProperty$2.call(object, key2)) {\n      if (object[key2] !== null)\n        return false;\n    }\n  }\n  return true;\n}\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\nvar set = new type(\"tag:yaml.org,2002:set\", {\n  kind: \"mapping\",\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\nvar _default = core.extend({\n  implicit: [\n    timestamp,\n    merge\n  ],\n  explicit: [\n    binary,\n    omap,\n    pairs,\n    set\n  ]\n});\nvar _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\nvar CONTEXT_FLOW_IN = 1;\nvar CONTEXT_FLOW_OUT = 2;\nvar CONTEXT_BLOCK_IN = 3;\nvar CONTEXT_BLOCK_OUT = 4;\nvar CHOMPING_CLIP = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP = 3;\nvar PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\nfunction _class(obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction is_EOL(c2) {\n  return c2 === 10 || c2 === 13;\n}\nfunction is_WHITE_SPACE(c2) {\n  return c2 === 9 || c2 === 32;\n}\nfunction is_WS_OR_EOL(c2) {\n  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;\n}\nfunction is_FLOW_INDICATOR(c2) {\n  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;\n}\nfunction fromHexCode(c2) {\n  var lc;\n  if (48 <= c2 && c2 <= 57) {\n    return c2 - 48;\n  }\n  lc = c2 | 32;\n  if (97 <= lc && lc <= 102) {\n    return lc - 97 + 10;\n  }\n  return -1;\n}\nfunction escapedHexLen(c2) {\n  if (c2 === 120) {\n    return 2;\n  }\n  if (c2 === 117) {\n    return 4;\n  }\n  if (c2 === 85) {\n    return 8;\n  }\n  return 0;\n}\nfunction fromDecimalCode(c2) {\n  if (48 <= c2 && c2 <= 57) {\n    return c2 - 48;\n  }\n  return -1;\n}\nfunction simpleEscapeSequence(c2) {\n  return c2 === 48 ? \"\\0\" : c2 === 97 ? \"\\x07\" : c2 === 98 ? \"\\b\" : c2 === 116 ? \"\t\" : c2 === 9 ? \"\t\" : c2 === 110 ? \"\\n\" : c2 === 118 ? \"\\v\" : c2 === 102 ? \"\\f\" : c2 === 114 ? \"\\r\" : c2 === 101 ? \"\\x1B\" : c2 === 32 ? \" \" : c2 === 34 ? '\"' : c2 === 47 ? \"/\" : c2 === 92 ? \"\\\\\" : c2 === 78 ? \"\\x85\" : c2 === 95 ? \"\\xA0\" : c2 === 76 ? \"\\u2028\" : c2 === 80 ? \"\\u2029\" : \"\";\n}\nfunction charFromCodepoint(c2) {\n  if (c2 <= 65535) {\n    return String.fromCharCode(c2);\n  }\n  return String.fromCharCode(\n    (c2 - 65536 >> 10) + 55296,\n    (c2 - 65536 & 1023) + 56320\n  );\n}\nvar simpleEscapeCheck = new Array(256);\nvar simpleEscapeMap = new Array(256);\nfor (i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\nvar i;\nfunction State$1(input, options8) {\n  this.input = input;\n  this.filename = options8[\"filename\"] || null;\n  this.schema = options8[\"schema\"] || _default;\n  this.onWarning = options8[\"onWarning\"] || null;\n  this.legacy = options8[\"legacy\"] || false;\n  this.json = options8[\"json\"] || false;\n  this.listener = options8[\"listener\"] || null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap = this.schema.compiledTypeMap;\n  this.length = input.length;\n  this.position = 0;\n  this.line = 0;\n  this.lineStart = 0;\n  this.lineIndent = 0;\n  this.firstTabInLine = -1;\n  this.documents = [];\n}\nfunction generateError(state, message) {\n  var mark = {\n    name: state.filename,\n    buffer: state.input.slice(0, -1),\n    // omit trailing \\0\n    position: state.position,\n    line: state.line,\n    column: state.position - state.lineStart\n  };\n  mark.snippet = snippet(mark);\n  return new exception(message, mark);\n}\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\nvar directiveHandlers = {\n  YAML: function handleYamlDirective(state, name, args) {\n    var match, major, minor;\n    if (state.version !== null) {\n      throwError(state, \"duplication of %YAML directive\");\n    }\n    if (args.length !== 1) {\n      throwError(state, \"YAML directive accepts exactly one argument\");\n    }\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n    if (match === null) {\n      throwError(state, \"ill-formed argument of the YAML directive\");\n    }\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n    if (major !== 1) {\n      throwError(state, \"unacceptable YAML version of the document\");\n    }\n    state.version = args[0];\n    state.checkLineBreaks = minor < 2;\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, \"unsupported YAML version of the document\");\n    }\n  },\n  TAG: function handleTagDirective(state, name, args) {\n    var handle, prefix;\n    if (args.length !== 2) {\n      throwError(state, \"TAG directive accepts exactly two arguments\");\n    }\n    handle = args[0];\n    prefix = args[1];\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, \"ill-formed tag handle (first argument) of the TAG directive\");\n    }\n    if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, \"ill-formed tag prefix (second argument) of the TAG directive\");\n    }\n    try {\n      prefix = decodeURIComponent(prefix);\n    } catch (err) {\n      throwError(state, \"tag prefix is malformed: \" + prefix);\n    }\n    state.tagMap[handle] = prefix;\n  }\n};\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n  if (start < end) {\n    _result = state.input.slice(start, end);\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {\n          throwError(state, \"expected valid JSON character\");\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, \"the stream contains non-printable characters\");\n    }\n    state.result += _result;\n  }\n}\nfunction mergeMappings(state, destination, source2, overridableKeys) {\n  var sourceKeys, key2, index, quantity;\n  if (!common.isObject(source2)) {\n    throwError(state, \"cannot merge mappings; the provided source object is unacceptable\");\n  }\n  sourceKeys = Object.keys(source2);\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key2 = sourceKeys[index];\n    if (!_hasOwnProperty$1.call(destination, key2)) {\n      destination[key2] = source2[key2];\n      overridableKeys[key2] = true;\n    }\n  }\n}\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {\n  var index, quantity;\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, \"nested arrays are not supported inside keys\");\n      }\n      if (typeof keyNode === \"object\" && _class(keyNode[index]) === \"[object Object]\") {\n        keyNode[index] = \"[object Object]\";\n      }\n    }\n  }\n  if (typeof keyNode === \"object\" && _class(keyNode) === \"[object Object]\") {\n    keyNode = \"[object Object]\";\n  }\n  keyNode = String(keyNode);\n  if (_result === null) {\n    _result = {};\n  }\n  if (keyTag === \"tag:yaml.org,2002:merge\") {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.lineStart = startLineStart || state.lineStart;\n      state.position = startPos || state.position;\n      throwError(state, \"duplicated mapping key\");\n    }\n    if (keyNode === \"__proto__\") {\n      Object.defineProperty(_result, keyNode, {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: valueNode\n      });\n    } else {\n      _result[keyNode] = valueNode;\n    }\n    delete overridableKeys[keyNode];\n  }\n  return _result;\n}\nfunction readLineBreak(state) {\n  var ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch === 10) {\n    state.position++;\n  } else if (ch === 13) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 10) {\n      state.position++;\n    }\n  } else {\n    throwError(state, \"a line break is expected\");\n  }\n  state.line += 1;\n  state.lineStart = state.position;\n  state.firstTabInLine = -1;\n}\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      if (ch === 9 && state.firstTabInLine === -1) {\n        state.firstTabInLine = state.position;\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n    if (allowComments && ch === 35) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 10 && ch !== 13 && ch !== 0);\n    }\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n      while (ch === 32) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, \"deficient indentation\");\n  }\n  return lineBreaks;\n}\nfunction testDocumentSeparator(state) {\n  var _position = state.position, ch;\n  ch = state.input.charCodeAt(_position);\n  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n    _position += 3;\n    ch = state.input.charCodeAt(_position);\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += \" \";\n  } else if (count > 1) {\n    state.result += common.repeat(\"\\n\", count - 1);\n  }\n}\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {\n    return false;\n  }\n  if (ch === 63 || ch === 45) {\n    following = state.input.charCodeAt(state.position + 1);\n    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n  state.kind = \"scalar\";\n  state.result = \"\";\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n  while (ch !== 0) {\n    if (ch === 58) {\n      following = state.input.charCodeAt(state.position + 1);\n      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n    } else if (ch === 35) {\n      preceding = state.input.charCodeAt(state.position - 1);\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n    ch = state.input.charCodeAt(++state.position);\n  }\n  captureSegment(state, captureStart, captureEnd, false);\n  if (state.result) {\n    return true;\n  }\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch, captureStart, captureEnd;\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 39) {\n    return false;\n  }\n  state.kind = \"scalar\";\n  state.result = \"\";\n  state.position++;\n  captureStart = captureEnd = state.position;\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 39) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n      if (ch === 39) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, \"unexpected end of the document within a single quoted scalar\");\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n  throwError(state, \"unexpected end of the stream within a single quoted scalar\");\n}\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 34) {\n    return false;\n  }\n  state.kind = \"scalar\";\n  state.result = \"\";\n  state.position++;\n  captureStart = captureEnd = state.position;\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 34) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n    } else if (ch === 92) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n          } else {\n            throwError(state, \"expected hexadecimal character\");\n          }\n        }\n        state.result += charFromCodepoint(hexResult);\n        state.position++;\n      } else {\n        throwError(state, \"unknown escape sequence\");\n      }\n      captureStart = captureEnd = state.position;\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, \"unexpected end of the document within a double quoted scalar\");\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n  throwError(state, \"unexpected end of the stream within a double quoted scalar\");\n}\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch === 91) {\n    terminator = 93;\n    isMapping = false;\n    _result = [];\n  } else if (ch === 123) {\n    terminator = 125;\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n  ch = state.input.charCodeAt(++state.position);\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? \"mapping\" : \"sequence\";\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, \"missed comma between flow collection entries\");\n    } else if (ch === 44) {\n      throwError(state, \"expected the node content, but found ','\");\n    }\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n    if (ch === 63) {\n      following = state.input.charCodeAt(state.position + 1);\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n    _line = state.line;\n    _lineStart = state.lineStart;\n    _pos = state.position;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n    if ((isExplicitPair || state.line === _line) && ch === 58) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n    } else {\n      _result.push(keyNode);\n    }\n    skipSeparationSpace(state, true, nodeIndent);\n    ch = state.input.charCodeAt(state.position);\n    if (ch === 44) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n  throwError(state, \"unexpected end of the stream within a flow collection\");\n}\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch === 124) {\n    folding = false;\n  } else if (ch === 62) {\n    folding = true;\n  } else {\n    return false;\n  }\n  state.kind = \"scalar\";\n  state.result = \"\";\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n    if (ch === 43 || ch === 45) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, \"repeat of a chomping mode identifier\");\n      }\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, \"bad explicit indentation width of a block scalar; it cannot be less than one\");\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, \"repeat of an indentation width identifier\");\n      }\n    } else {\n      break;\n    }\n  }\n  if (is_WHITE_SPACE(ch)) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (is_WHITE_SPACE(ch));\n    if (ch === 35) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (!is_EOL(ch) && ch !== 0);\n    }\n  }\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n    ch = state.input.charCodeAt(state.position);\n    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n    if (state.lineIndent < textIndent) {\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) {\n          state.result += \"\\n\";\n        }\n      }\n      break;\n    }\n    if (folding) {\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat(\"\\n\", emptyLines + 1);\n      } else if (emptyLines === 0) {\n        if (didReadContent) {\n          state.result += \" \";\n        }\n      } else {\n        state.result += common.repeat(\"\\n\", emptyLines);\n      }\n    } else {\n      state.result += common.repeat(\"\\n\", didReadContent ? 1 + emptyLines : emptyLines);\n    }\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n    while (!is_EOL(ch) && ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n    captureSegment(state, captureStart, state.position, false);\n  }\n  return true;\n}\nfunction readBlockSequence(state, nodeIndent) {\n  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;\n  if (state.firstTabInLine !== -1)\n    return false;\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n  ch = state.input.charCodeAt(state.position);\n  while (ch !== 0) {\n    if (state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, \"tab characters must not be used in indentation\");\n    }\n    if (ch !== 45) {\n      break;\n    }\n    following = state.input.charCodeAt(state.position + 1);\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n    detected = true;\n    state.position++;\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, \"bad indentation of a sequence entry\");\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = \"sequence\";\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;\n  if (state.firstTabInLine !== -1)\n    return false;\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n  ch = state.input.charCodeAt(state.position);\n  while (ch !== 0) {\n    if (!atExplicitKey && state.firstTabInLine !== -1) {\n      state.position = state.firstTabInLine;\n      throwError(state, \"tab characters must not be used in indentation\");\n    }\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line;\n    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {\n      if (ch === 63) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n      } else if (atExplicitKey) {\n        atExplicitKey = false;\n        allowCompact = true;\n      } else {\n        throwError(state, \"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line\");\n      }\n      state.position += 1;\n      ch = following;\n    } else {\n      _keyLine = state.line;\n      _keyLineStart = state.lineStart;\n      _keyPos = state.position;\n      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n        break;\n      }\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n        if (ch === 58) {\n          ch = state.input.charCodeAt(++state.position);\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, \"a whitespace character is expected after the key-value separator within a block mapping\");\n          }\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n        } else if (detected) {\n          throwError(state, \"can not read an implicit mapping pair; a colon is missed\");\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true;\n        }\n      } else if (detected) {\n        throwError(state, \"can not read a block mapping entry; a multiline key may not be an implicit key\");\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true;\n      }\n    }\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (atExplicitKey) {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n      }\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n        keyTag = keyNode = valueNode = null;\n      }\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n      throwError(state, \"bad indentation of a mapping entry\");\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n  }\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = \"mapping\";\n    state.result = _result;\n  }\n  return detected;\n}\nfunction readTagProperty(state) {\n  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 33)\n    return false;\n  if (state.tag !== null) {\n    throwError(state, \"duplication of a tag property\");\n  }\n  ch = state.input.charCodeAt(++state.position);\n  if (ch === 60) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n  } else if (ch === 33) {\n    isNamed = true;\n    tagHandle = \"!!\";\n    ch = state.input.charCodeAt(++state.position);\n  } else {\n    tagHandle = \"!\";\n  }\n  _position = state.position;\n  if (isVerbatim) {\n    do {\n      ch = state.input.charCodeAt(++state.position);\n    } while (ch !== 0 && ch !== 62);\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, \"unexpected end of the stream within a verbatim tag\");\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      if (ch === 33) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, \"named tag handle cannot contain such characters\");\n          }\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, \"tag suffix cannot contain exclamation marks\");\n        }\n      }\n      ch = state.input.charCodeAt(++state.position);\n    }\n    tagName = state.input.slice(_position, state.position);\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, \"tag suffix cannot contain flow indicator characters\");\n    }\n  }\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, \"tag name cannot contain such characters: \" + tagName);\n  }\n  try {\n    tagName = decodeURIComponent(tagName);\n  } catch (err) {\n    throwError(state, \"tag name is malformed: \" + tagName);\n  }\n  if (isVerbatim) {\n    state.tag = tagName;\n  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n  } else if (tagHandle === \"!\") {\n    state.tag = \"!\" + tagName;\n  } else if (tagHandle === \"!!\") {\n    state.tag = \"tag:yaml.org,2002:\" + tagName;\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n  return true;\n}\nfunction readAnchorProperty(state) {\n  var _position, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 38)\n    return false;\n  if (state.anchor !== null) {\n    throwError(state, \"duplication of an anchor property\");\n  }\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n  if (state.position === _position) {\n    throwError(state, \"name of an anchor node must contain at least one character\");\n  }\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\nfunction readAlias(state) {\n  var _position, alias, ch;\n  ch = state.input.charCodeAt(state.position);\n  if (ch !== 42)\n    return false;\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n  if (state.position === _position) {\n    throwError(state, \"name of an alias node must contain at least one character\");\n  }\n  alias = state.input.slice(_position, state.position);\n  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;\n  if (state.listener !== null) {\n    state.listener(\"open\", state);\n  }\n  state.tag = null;\n  state.anchor = null;\n  state.kind = null;\n  state.result = null;\n  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n    blockIndent = state.position - state.lineStart;\n    if (indentStatus === 1) {\n      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n        } else if (readAlias(state)) {\n          hasContent = true;\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, \"alias node should not have any properties\");\n          }\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n          if (state.tag === null) {\n            state.tag = \"?\";\n          }\n        }\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n  if (state.tag === null) {\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = state.result;\n    }\n  } else if (state.tag === \"?\") {\n    if (state.result !== null && state.kind !== \"scalar\") {\n      throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n    }\n    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n      type2 = state.implicitTypes[typeIndex];\n      if (type2.resolve(state.result)) {\n        state.result = type2.construct(state.result);\n        state.tag = type2.tag;\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n        break;\n      }\n    }\n  } else if (state.tag !== \"!\") {\n    if (_hasOwnProperty$1.call(state.typeMap[state.kind || \"fallback\"], state.tag)) {\n      type2 = state.typeMap[state.kind || \"fallback\"][state.tag];\n    } else {\n      type2 = null;\n      typeList = state.typeMap.multi[state.kind || \"fallback\"];\n      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n          type2 = typeList[typeIndex];\n          break;\n        }\n      }\n    }\n    if (!type2) {\n      throwError(state, \"unknown tag !<\" + state.tag + \">\");\n    }\n    if (state.result !== null && type2.kind !== state.kind) {\n      throwError(state, \"unacceptable node kind for !<\" + state.tag + '> tag; it should be \"' + type2.kind + '\", not \"' + state.kind + '\"');\n    }\n    if (!type2.resolve(state.result, state.tag)) {\n      throwError(state, \"cannot resolve a node with !<\" + state.tag + \"> explicit tag\");\n    } else {\n      state.result = type2.construct(state.result, state.tag);\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n    }\n  }\n  if (state.listener !== null) {\n    state.listener(\"close\", state);\n  }\n  return state.tag !== null || state.anchor !== null || hasContent;\n}\nfunction readDocument(state) {\n  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = /* @__PURE__ */ Object.create(null);\n  state.anchorMap = /* @__PURE__ */ Object.create(null);\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n    ch = state.input.charCodeAt(state.position);\n    if (state.lineIndent > 0 || ch !== 37) {\n      break;\n    }\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n    if (directiveName.length < 1) {\n      throwError(state, \"directive name must not be less than one character in length\");\n    }\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      if (ch === 35) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n      if (is_EOL(ch))\n        break;\n      _position = state.position;\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n    if (ch !== 0)\n      readLineBreak(state);\n    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n  skipSeparationSpace(state, true, -1);\n  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n  } else if (hasDirectives) {\n    throwError(state, \"directives end mark is expected\");\n  }\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, \"non-ASCII line breaks are interpreted as content\");\n  }\n  state.documents.push(state.result);\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n    if (state.input.charCodeAt(state.position) === 46) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n  if (state.position < state.length - 1) {\n    throwError(state, \"end of the stream or a document separator is expected\");\n  } else {\n    return;\n  }\n}\nfunction loadDocuments(input, options8) {\n  input = String(input);\n  options8 = options8 || {};\n  if (input.length !== 0) {\n    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {\n      input += \"\\n\";\n    }\n    if (input.charCodeAt(0) === 65279) {\n      input = input.slice(1);\n    }\n  }\n  var state = new State$1(input, options8);\n  var nullpos = input.indexOf(\"\\0\");\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, \"null byte is not allowed in input\");\n  }\n  state.input += \"\\0\";\n  while (state.input.charCodeAt(state.position) === 32) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n  while (state.position < state.length - 1) {\n    readDocument(state);\n  }\n  return state.documents;\n}\nfunction loadAll$1(input, iterator, options8) {\n  if (iterator !== null && typeof iterator === \"object\" && typeof options8 === \"undefined\") {\n    options8 = iterator;\n    iterator = null;\n  }\n  var documents = loadDocuments(input, options8);\n  if (typeof iterator !== \"function\") {\n    return documents;\n  }\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\nfunction load$1(input, options8) {\n  var documents = loadDocuments(input, options8);\n  if (documents.length === 0) {\n    return void 0;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new exception(\"expected a single document in the stream, but found more\");\n}\nvar loadAll_1 = loadAll$1;\nvar load_1 = load$1;\nvar loader = {\n  loadAll: loadAll_1,\n  load: load_1\n};\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0] = \"\\\\0\";\nESCAPE_SEQUENCES[7] = \"\\\\a\";\nESCAPE_SEQUENCES[8] = \"\\\\b\";\nESCAPE_SEQUENCES[9] = \"\\\\t\";\nESCAPE_SEQUENCES[10] = \"\\\\n\";\nESCAPE_SEQUENCES[11] = \"\\\\v\";\nESCAPE_SEQUENCES[12] = \"\\\\f\";\nESCAPE_SEQUENCES[13] = \"\\\\r\";\nESCAPE_SEQUENCES[27] = \"\\\\e\";\nESCAPE_SEQUENCES[34] = '\\\\\"';\nESCAPE_SEQUENCES[92] = \"\\\\\\\\\";\nESCAPE_SEQUENCES[133] = \"\\\\N\";\nESCAPE_SEQUENCES[160] = \"\\\\_\";\nESCAPE_SEQUENCES[8232] = \"\\\\L\";\nESCAPE_SEQUENCES[8233] = \"\\\\P\";\nfunction renamed(from, to) {\n  return function() {\n    throw new Error(\"Function yaml.\" + from + \" is removed in js-yaml 4. Use yaml.\" + to + \" instead, which is now safe by default.\");\n  };\n}\nvar load = loader.load;\nvar loadAll = loader.loadAll;\nvar safeLoad = renamed(\"safeLoad\", \"load\");\nvar safeLoadAll = renamed(\"safeLoadAll\", \"loadAll\");\nvar safeDump = renamed(\"safeDump\", \"dump\");\n\n// node_modules/json5/dist/index.mjs\nvar Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\nvar ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\nvar ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\nvar unicode = {\n  Space_Separator,\n  ID_Start,\n  ID_Continue\n};\nvar util = {\n  isSpaceSeparator(c2) {\n    return typeof c2 === \"string\" && unicode.Space_Separator.test(c2);\n  },\n  isIdStartChar(c2) {\n    return typeof c2 === \"string\" && (c2 >= \"a\" && c2 <= \"z\" || c2 >= \"A\" && c2 <= \"Z\" || c2 === \"$\" || c2 === \"_\" || unicode.ID_Start.test(c2));\n  },\n  isIdContinueChar(c2) {\n    return typeof c2 === \"string\" && (c2 >= \"a\" && c2 <= \"z\" || c2 >= \"A\" && c2 <= \"Z\" || c2 >= \"0\" && c2 <= \"9\" || c2 === \"$\" || c2 === \"_\" || c2 === \"\\u200C\" || c2 === \"\\u200D\" || unicode.ID_Continue.test(c2));\n  },\n  isDigit(c2) {\n    return typeof c2 === \"string\" && /[0-9]/.test(c2);\n  },\n  isHexDigit(c2) {\n    return typeof c2 === \"string\" && /[0-9A-Fa-f]/.test(c2);\n  }\n};\nvar source;\nvar parseState;\nvar stack;\nvar pos;\nvar line;\nvar column;\nvar token;\nvar key;\nvar root;\nvar parse2 = function parse3(text, reviver) {\n  source = String(text);\n  parseState = \"start\";\n  stack = [];\n  pos = 0;\n  line = 1;\n  column = 0;\n  token = void 0;\n  key = void 0;\n  root = void 0;\n  do {\n    token = lex();\n    parseStates[parseState]();\n  } while (token.type !== \"eof\");\n  if (typeof reviver === \"function\") {\n    return internalize({ \"\": root }, \"\", reviver);\n  }\n  return root;\n};\nfunction internalize(holder, name, reviver) {\n  const value = holder[name];\n  if (value != null && typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        const key2 = String(i);\n        const replacement = internalize(value, key2, reviver);\n        if (replacement === void 0) {\n          delete value[key2];\n        } else {\n          Object.defineProperty(value, key2, {\n            value: replacement,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    } else {\n      for (const key2 in value) {\n        const replacement = internalize(value, key2, reviver);\n        if (replacement === void 0) {\n          delete value[key2];\n        } else {\n          Object.defineProperty(value, key2, {\n            value: replacement,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n  }\n  return reviver.call(holder, name, value);\n}\nvar lexState;\nvar buffer;\nvar doubleQuote;\nvar sign;\nvar c;\nfunction lex() {\n  lexState = \"default\";\n  buffer = \"\";\n  doubleQuote = false;\n  sign = 1;\n  for (; ; ) {\n    c = peek();\n    const token2 = lexStates[lexState]();\n    if (token2) {\n      return token2;\n    }\n  }\n}\nfunction peek() {\n  if (source[pos]) {\n    return String.fromCodePoint(source.codePointAt(pos));\n  }\n}\nfunction read() {\n  const c2 = peek();\n  if (c2 === \"\\n\") {\n    line++;\n    column = 0;\n  } else if (c2) {\n    column += c2.length;\n  } else {\n    column++;\n  }\n  if (c2) {\n    pos += c2.length;\n  }\n  return c2;\n}\nvar lexStates = {\n  default() {\n    switch (c) {\n      case \"\t\":\n      case \"\\v\":\n      case \"\\f\":\n      case \" \":\n      case \"\\xA0\":\n      case \"\\uFEFF\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        read();\n        return;\n      case \"/\":\n        read();\n        lexState = \"comment\";\n        return;\n      case void 0:\n        read();\n        return newToken(\"eof\");\n    }\n    if (util.isSpaceSeparator(c)) {\n      read();\n      return;\n    }\n    return lexStates[parseState]();\n  },\n  comment() {\n    switch (c) {\n      case \"*\":\n        read();\n        lexState = \"multiLineComment\";\n        return;\n      case \"/\":\n        read();\n        lexState = \"singleLineComment\";\n        return;\n    }\n    throw invalidChar(read());\n  },\n  multiLineComment() {\n    switch (c) {\n      case \"*\":\n        read();\n        lexState = \"multiLineCommentAsterisk\";\n        return;\n      case void 0:\n        throw invalidChar(read());\n    }\n    read();\n  },\n  multiLineCommentAsterisk() {\n    switch (c) {\n      case \"*\":\n        read();\n        return;\n      case \"/\":\n        read();\n        lexState = \"default\";\n        return;\n      case void 0:\n        throw invalidChar(read());\n    }\n    read();\n    lexState = \"multiLineComment\";\n  },\n  singleLineComment() {\n    switch (c) {\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        read();\n        lexState = \"default\";\n        return;\n      case void 0:\n        read();\n        return newToken(\"eof\");\n    }\n    read();\n  },\n  value() {\n    switch (c) {\n      case \"{\":\n      case \"[\":\n        return newToken(\"punctuator\", read());\n      case \"n\":\n        read();\n        literal(\"ull\");\n        return newToken(\"null\", null);\n      case \"t\":\n        read();\n        literal(\"rue\");\n        return newToken(\"boolean\", true);\n      case \"f\":\n        read();\n        literal(\"alse\");\n        return newToken(\"boolean\", false);\n      case \"-\":\n      case \"+\":\n        if (read() === \"-\") {\n          sign = -1;\n        }\n        lexState = \"sign\";\n        return;\n      case \".\":\n        buffer = read();\n        lexState = \"decimalPointLeading\";\n        return;\n      case \"0\":\n        buffer = read();\n        lexState = \"zero\";\n        return;\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        buffer = read();\n        lexState = \"decimalInteger\";\n        return;\n      case \"I\":\n        read();\n        literal(\"nfinity\");\n        return newToken(\"numeric\", Infinity);\n      case \"N\":\n        read();\n        literal(\"aN\");\n        return newToken(\"numeric\", NaN);\n      case '\"':\n      case \"'\":\n        doubleQuote = read() === '\"';\n        buffer = \"\";\n        lexState = \"string\";\n        return;\n    }\n    throw invalidChar(read());\n  },\n  identifierNameStartEscape() {\n    if (c !== \"u\") {\n      throw invalidChar(read());\n    }\n    read();\n    const u = unicodeEscape();\n    switch (u) {\n      case \"$\":\n      case \"_\":\n        break;\n      default:\n        if (!util.isIdStartChar(u)) {\n          throw invalidIdentifier();\n        }\n        break;\n    }\n    buffer += u;\n    lexState = \"identifierName\";\n  },\n  identifierName() {\n    switch (c) {\n      case \"$\":\n      case \"_\":\n      case \"\\u200C\":\n      case \"\\u200D\":\n        buffer += read();\n        return;\n      case \"\\\\\":\n        read();\n        lexState = \"identifierNameEscape\";\n        return;\n    }\n    if (util.isIdContinueChar(c)) {\n      buffer += read();\n      return;\n    }\n    return newToken(\"identifier\", buffer);\n  },\n  identifierNameEscape() {\n    if (c !== \"u\") {\n      throw invalidChar(read());\n    }\n    read();\n    const u = unicodeEscape();\n    switch (u) {\n      case \"$\":\n      case \"_\":\n      case \"\\u200C\":\n      case \"\\u200D\":\n        break;\n      default:\n        if (!util.isIdContinueChar(u)) {\n          throw invalidIdentifier();\n        }\n        break;\n    }\n    buffer += u;\n    lexState = \"identifierName\";\n  },\n  sign() {\n    switch (c) {\n      case \".\":\n        buffer = read();\n        lexState = \"decimalPointLeading\";\n        return;\n      case \"0\":\n        buffer = read();\n        lexState = \"zero\";\n        return;\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        buffer = read();\n        lexState = \"decimalInteger\";\n        return;\n      case \"I\":\n        read();\n        literal(\"nfinity\");\n        return newToken(\"numeric\", sign * Infinity);\n      case \"N\":\n        read();\n        literal(\"aN\");\n        return newToken(\"numeric\", NaN);\n    }\n    throw invalidChar(read());\n  },\n  zero() {\n    switch (c) {\n      case \".\":\n        buffer += read();\n        lexState = \"decimalPoint\";\n        return;\n      case \"e\":\n      case \"E\":\n        buffer += read();\n        lexState = \"decimalExponent\";\n        return;\n      case \"x\":\n      case \"X\":\n        buffer += read();\n        lexState = \"hexadecimal\";\n        return;\n    }\n    return newToken(\"numeric\", sign * 0);\n  },\n  decimalInteger() {\n    switch (c) {\n      case \".\":\n        buffer += read();\n        lexState = \"decimalPoint\";\n        return;\n      case \"e\":\n      case \"E\":\n        buffer += read();\n        lexState = \"decimalExponent\";\n        return;\n    }\n    if (util.isDigit(c)) {\n      buffer += read();\n      return;\n    }\n    return newToken(\"numeric\", sign * Number(buffer));\n  },\n  decimalPointLeading() {\n    if (util.isDigit(c)) {\n      buffer += read();\n      lexState = \"decimalFraction\";\n      return;\n    }\n    throw invalidChar(read());\n  },\n  decimalPoint() {\n    switch (c) {\n      case \"e\":\n      case \"E\":\n        buffer += read();\n        lexState = \"decimalExponent\";\n        return;\n    }\n    if (util.isDigit(c)) {\n      buffer += read();\n      lexState = \"decimalFraction\";\n      return;\n    }\n    return newToken(\"numeric\", sign * Number(buffer));\n  },\n  decimalFraction() {\n    switch (c) {\n      case \"e\":\n      case \"E\":\n        buffer += read();\n        lexState = \"decimalExponent\";\n        return;\n    }\n    if (util.isDigit(c)) {\n      buffer += read();\n      return;\n    }\n    return newToken(\"numeric\", sign * Number(buffer));\n  },\n  decimalExponent() {\n    switch (c) {\n      case \"+\":\n      case \"-\":\n        buffer += read();\n        lexState = \"decimalExponentSign\";\n        return;\n    }\n    if (util.isDigit(c)) {\n      buffer += read();\n      lexState = \"decimalExponentInteger\";\n      return;\n    }\n    throw invalidChar(read());\n  },\n  decimalExponentSign() {\n    if (util.isDigit(c)) {\n      buffer += read();\n      lexState = \"decimalExponentInteger\";\n      return;\n    }\n    throw invalidChar(read());\n  },\n  decimalExponentInteger() {\n    if (util.isDigit(c)) {\n      buffer += read();\n      return;\n    }\n    return newToken(\"numeric\", sign * Number(buffer));\n  },\n  hexadecimal() {\n    if (util.isHexDigit(c)) {\n      buffer += read();\n      lexState = \"hexadecimalInteger\";\n      return;\n    }\n    throw invalidChar(read());\n  },\n  hexadecimalInteger() {\n    if (util.isHexDigit(c)) {\n      buffer += read();\n      return;\n    }\n    return newToken(\"numeric\", sign * Number(buffer));\n  },\n  string() {\n    switch (c) {\n      case \"\\\\\":\n        read();\n        buffer += escape();\n        return;\n      case '\"':\n        if (doubleQuote) {\n          read();\n          return newToken(\"string\", buffer);\n        }\n        buffer += read();\n        return;\n      case \"'\":\n        if (!doubleQuote) {\n          read();\n          return newToken(\"string\", buffer);\n        }\n        buffer += read();\n        return;\n      case \"\\n\":\n      case \"\\r\":\n        throw invalidChar(read());\n      case \"\\u2028\":\n      case \"\\u2029\":\n        separatorChar(c);\n        break;\n      case void 0:\n        throw invalidChar(read());\n    }\n    buffer += read();\n  },\n  start() {\n    switch (c) {\n      case \"{\":\n      case \"[\":\n        return newToken(\"punctuator\", read());\n    }\n    lexState = \"value\";\n  },\n  beforePropertyName() {\n    switch (c) {\n      case \"$\":\n      case \"_\":\n        buffer = read();\n        lexState = \"identifierName\";\n        return;\n      case \"\\\\\":\n        read();\n        lexState = \"identifierNameStartEscape\";\n        return;\n      case \"}\":\n        return newToken(\"punctuator\", read());\n      case '\"':\n      case \"'\":\n        doubleQuote = read() === '\"';\n        lexState = \"string\";\n        return;\n    }\n    if (util.isIdStartChar(c)) {\n      buffer += read();\n      lexState = \"identifierName\";\n      return;\n    }\n    throw invalidChar(read());\n  },\n  afterPropertyName() {\n    if (c === \":\") {\n      return newToken(\"punctuator\", read());\n    }\n    throw invalidChar(read());\n  },\n  beforePropertyValue() {\n    lexState = \"value\";\n  },\n  afterPropertyValue() {\n    switch (c) {\n      case \",\":\n      case \"}\":\n        return newToken(\"punctuator\", read());\n    }\n    throw invalidChar(read());\n  },\n  beforeArrayValue() {\n    if (c === \"]\") {\n      return newToken(\"punctuator\", read());\n    }\n    lexState = \"value\";\n  },\n  afterArrayValue() {\n    switch (c) {\n      case \",\":\n      case \"]\":\n        return newToken(\"punctuator\", read());\n    }\n    throw invalidChar(read());\n  },\n  end() {\n    throw invalidChar(read());\n  }\n};\nfunction newToken(type2, value) {\n  return {\n    type: type2,\n    value,\n    line,\n    column\n  };\n}\nfunction literal(s) {\n  for (const c2 of s) {\n    const p = peek();\n    if (p !== c2) {\n      throw invalidChar(read());\n    }\n    read();\n  }\n}\nfunction escape() {\n  const c2 = peek();\n  switch (c2) {\n    case \"b\":\n      read();\n      return \"\\b\";\n    case \"f\":\n      read();\n      return \"\\f\";\n    case \"n\":\n      read();\n      return \"\\n\";\n    case \"r\":\n      read();\n      return \"\\r\";\n    case \"t\":\n      read();\n      return \"\t\";\n    case \"v\":\n      read();\n      return \"\\v\";\n    case \"0\":\n      read();\n      if (util.isDigit(peek())) {\n        throw invalidChar(read());\n      }\n      return \"\\0\";\n    case \"x\":\n      read();\n      return hexEscape();\n    case \"u\":\n      read();\n      return unicodeEscape();\n    case \"\\n\":\n    case \"\\u2028\":\n    case \"\\u2029\":\n      read();\n      return \"\";\n    case \"\\r\":\n      read();\n      if (peek() === \"\\n\") {\n        read();\n      }\n      return \"\";\n    case \"1\":\n    case \"2\":\n    case \"3\":\n    case \"4\":\n    case \"5\":\n    case \"6\":\n    case \"7\":\n    case \"8\":\n    case \"9\":\n      throw invalidChar(read());\n    case void 0:\n      throw invalidChar(read());\n  }\n  return read();\n}\nfunction hexEscape() {\n  let buffer2 = \"\";\n  let c2 = peek();\n  if (!util.isHexDigit(c2)) {\n    throw invalidChar(read());\n  }\n  buffer2 += read();\n  c2 = peek();\n  if (!util.isHexDigit(c2)) {\n    throw invalidChar(read());\n  }\n  buffer2 += read();\n  return String.fromCodePoint(parseInt(buffer2, 16));\n}\nfunction unicodeEscape() {\n  let buffer2 = \"\";\n  let count = 4;\n  while (count-- > 0) {\n    const c2 = peek();\n    if (!util.isHexDigit(c2)) {\n      throw invalidChar(read());\n    }\n    buffer2 += read();\n  }\n  return String.fromCodePoint(parseInt(buffer2, 16));\n}\nvar parseStates = {\n  start() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    push();\n  },\n  beforePropertyName() {\n    switch (token.type) {\n      case \"identifier\":\n      case \"string\":\n        key = token.value;\n        parseState = \"afterPropertyName\";\n        return;\n      case \"punctuator\":\n        pop();\n        return;\n      case \"eof\":\n        throw invalidEOF();\n    }\n  },\n  afterPropertyName() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    parseState = \"beforePropertyValue\";\n  },\n  beforePropertyValue() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    push();\n  },\n  beforeArrayValue() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    if (token.type === \"punctuator\" && token.value === \"]\") {\n      pop();\n      return;\n    }\n    push();\n  },\n  afterPropertyValue() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    switch (token.value) {\n      case \",\":\n        parseState = \"beforePropertyName\";\n        return;\n      case \"}\":\n        pop();\n    }\n  },\n  afterArrayValue() {\n    if (token.type === \"eof\") {\n      throw invalidEOF();\n    }\n    switch (token.value) {\n      case \",\":\n        parseState = \"beforeArrayValue\";\n        return;\n      case \"]\":\n        pop();\n    }\n  },\n  end() {\n  }\n};\nfunction push() {\n  let value;\n  switch (token.type) {\n    case \"punctuator\":\n      switch (token.value) {\n        case \"{\":\n          value = {};\n          break;\n        case \"[\":\n          value = [];\n          break;\n      }\n      break;\n    case \"null\":\n    case \"boolean\":\n    case \"numeric\":\n    case \"string\":\n      value = token.value;\n      break;\n  }\n  if (root === void 0) {\n    root = value;\n  } else {\n    const parent = stack[stack.length - 1];\n    if (Array.isArray(parent)) {\n      parent.push(value);\n    } else {\n      Object.defineProperty(parent, key, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    }\n  }\n  if (value !== null && typeof value === \"object\") {\n    stack.push(value);\n    if (Array.isArray(value)) {\n      parseState = \"beforeArrayValue\";\n    } else {\n      parseState = \"beforePropertyName\";\n    }\n  } else {\n    const current = stack[stack.length - 1];\n    if (current == null) {\n      parseState = \"end\";\n    } else if (Array.isArray(current)) {\n      parseState = \"afterArrayValue\";\n    } else {\n      parseState = \"afterPropertyValue\";\n    }\n  }\n}\nfunction pop() {\n  stack.pop();\n  const current = stack[stack.length - 1];\n  if (current == null) {\n    parseState = \"end\";\n  } else if (Array.isArray(current)) {\n    parseState = \"afterArrayValue\";\n  } else {\n    parseState = \"afterPropertyValue\";\n  }\n}\nfunction invalidChar(c2) {\n  if (c2 === void 0) {\n    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);\n  }\n  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);\n}\nfunction invalidEOF() {\n  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);\n}\nfunction invalidIdentifier() {\n  column -= 5;\n  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);\n}\nfunction separatorChar(c2) {\n  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);\n}\nfunction formatChar(c2) {\n  const replacements = {\n    \"'\": \"\\\\'\",\n    '\"': '\\\\\"',\n    \"\\\\\": \"\\\\\\\\\",\n    \"\\b\": \"\\\\b\",\n    \"\\f\": \"\\\\f\",\n    \"\\n\": \"\\\\n\",\n    \"\\r\": \"\\\\r\",\n    \"\t\": \"\\\\t\",\n    \"\\v\": \"\\\\v\",\n    \"\\0\": \"\\\\0\",\n    \"\\u2028\": \"\\\\u2028\",\n    \"\\u2029\": \"\\\\u2029\"\n  };\n  if (replacements[c2]) {\n    return replacements[c2];\n  }\n  if (c2 < \" \") {\n    const hexString = c2.charCodeAt(0).toString(16);\n    return \"\\\\x\" + (\"00\" + hexString).substring(hexString.length);\n  }\n  return c2;\n}\nfunction syntaxError(message) {\n  const err = new SyntaxError(message);\n  err.lineNumber = line;\n  err.columnNumber = column;\n  return err;\n}\nvar dist_default = { parse: parse2 };\n\n// node_modules/parse-json/index.js\nvar import_code_frame = __toESM(require_lib3(), 1);\n\n// node_modules/index-to-position/index.js\nvar safeLastIndexOf = (string, searchString, index) => index < 0 ? -1 : string.lastIndexOf(searchString, index);\nfunction getPosition(text, textIndex) {\n  const lineBreakBefore = safeLastIndexOf(text, \"\\n\", textIndex - 1);\n  const column2 = textIndex - lineBreakBefore - 1;\n  let line3 = 0;\n  for (let index = lineBreakBefore; index >= 0; index = safeLastIndexOf(text, \"\\n\", index - 1)) {\n    line3++;\n  }\n  return { line: line3, column: column2 };\n}\nfunction indexToLineColumn(text, textIndex, { oneBased = false } = {}) {\n  if (textIndex < 0 || textIndex >= text.length && text.length > 0) {\n    throw new RangeError(\"Index out of bounds\");\n  }\n  const position = getPosition(text, textIndex);\n  return oneBased ? { line: position.line + 1, column: position.column + 1 } : position;\n}\n\n// node_modules/parse-json/index.js\nvar getCodePoint = (character) => `\\\\u{${character.codePointAt(0).toString(16)}}`;\nvar _message;\nvar _JSONError = class _JSONError extends Error {\n  constructor(message) {\n    var _a;\n    super();\n    __publicField(this, \"name\", \"JSONError\");\n    __publicField(this, \"fileName\");\n    __publicField(this, \"codeFrame\");\n    __publicField(this, \"rawCodeFrame\");\n    __privateAdd(this, _message, void 0);\n    __privateSet(this, _message, message);\n    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, _JSONError);\n  }\n  get message() {\n    const { fileName, codeFrame } = this;\n    return `${__privateGet(this, _message)}${fileName ? ` in ${fileName}` : \"\"}${codeFrame ? `\n\n${codeFrame}\n` : \"\"}`;\n  }\n  set message(message) {\n    __privateSet(this, _message, message);\n  }\n};\n_message = new WeakMap();\nvar JSONError = _JSONError;\nvar generateCodeFrame = (string, location, highlightCode = true) => (0, import_code_frame.codeFrameColumns)(string, { start: location }, { highlightCode });\nvar getErrorLocation = (string, message) => {\n  const match = message.match(/in JSON at position (?<index>\\d+)(?: \\(line (?<line>\\d+) column (?<column>\\d+)\\))?$/);\n  if (!match) {\n    return;\n  }\n  let { index, line: line3, column: column2 } = match.groups;\n  if (line3 && column2) {\n    return { line: Number(line3), column: Number(column2) };\n  }\n  index = Number(index);\n  if (index === string.length) {\n    const { line: line4, column: column3 } = indexToLineColumn(string, string.length - 1, { oneBased: true });\n    return { line: line4, column: column3 + 1 };\n  }\n  return indexToLineColumn(string, index, { oneBased: true });\n};\nvar addCodePointToUnexpectedToken = (message) => message.replace(\n  // TODO[engine:node@>=20]: The token always quoted after Node.js 20\n  /(?<=^Unexpected token )(?<quote>')?(.)\\k<quote>/,\n  (_, _quote, token2) => `\"${token2}\"(${getCodePoint(token2)})`\n);\nfunction parseJson(string, reviver, fileName) {\n  if (typeof reviver === \"string\") {\n    fileName = reviver;\n    reviver = void 0;\n  }\n  let message;\n  try {\n    return JSON.parse(string, reviver);\n  } catch (error) {\n    message = error.message;\n  }\n  let location;\n  if (string) {\n    location = getErrorLocation(string, message);\n    message = addCodePointToUnexpectedToken(message);\n  } else {\n    message += \" while parsing empty string\";\n  }\n  const jsonError = new JSONError(message);\n  jsonError.fileName = fileName;\n  if (location) {\n    jsonError.codeFrame = generateCodeFrame(string, location);\n    jsonError.rawCodeFrame = generateCodeFrame(\n      string,\n      location,\n      /* highlightCode */\n      false\n    );\n  }\n  throw jsonError;\n}\n\n// src/utils/read-file.js\nimport fs4 from \"fs/promises\";\nasync function readFile(file) {\n  if (isUrlString(file)) {\n    file = new URL(file);\n  }\n  try {\n    return await fs4.readFile(file, \"utf8\");\n  } catch (error) {\n    if (error.code === \"ENOENT\") {\n      return;\n    }\n    throw new Error(`Unable to read '${file}': ${error.message}`);\n  }\n}\nvar read_file_default = readFile;\n\n// src/config/prettier-config/loaders.js\nasync function readJson(file) {\n  const content = await read_file_default(file);\n  try {\n    return parseJson(content);\n  } catch (error) {\n    error.message = `JSON Error in ${file}:\n${error.message}`;\n    throw error;\n  }\n}\nasync function loadJs(file) {\n  const module = await import(pathToFileURL2(file).href);\n  return module.default;\n}\nasync function loadConfigFromPackageJson(file) {\n  const { prettier } = await readJson(file);\n  return prettier;\n}\nasync function loadYaml(file) {\n  const content = await read_file_default(file);\n  try {\n    return load(content);\n  } catch (error) {\n    error.message = `YAML Error in ${file}:\n${error.message}`;\n    throw error;\n  }\n}\nvar loaders = {\n  async \".toml\"(file) {\n    const content = await read_file_default(file);\n    try {\n      return await (0, import_parse_async.default)(content);\n    } catch (error) {\n      error.message = `TOML Error in ${file}:\n${error.message}`;\n      throw error;\n    }\n  },\n  async \".json5\"(file) {\n    const content = await read_file_default(file);\n    try {\n      return dist_default.parse(content);\n    } catch (error) {\n      error.message = `JSON5 Error in ${file}:\n${error.message}`;\n      throw error;\n    }\n  },\n  \".json\": readJson,\n  \".js\": loadJs,\n  \".mjs\": loadJs,\n  \".cjs\": loadJs,\n  \".yaml\": loadYaml,\n  \".yml\": loadYaml,\n  // No extension\n  \"\": loadYaml\n};\nvar loaders_default = loaders;\n\n// src/config/prettier-config/config-searcher.js\nvar CONFIG_FILE_NAMES = [\n  \"package.json\",\n  \".prettierrc\",\n  \".prettierrc.json\",\n  \".prettierrc.yaml\",\n  \".prettierrc.yml\",\n  \".prettierrc.json5\",\n  \".prettierrc.js\",\n  \".prettierrc.mjs\",\n  \".prettierrc.cjs\",\n  \"prettier.config.js\",\n  \"prettier.config.mjs\",\n  \"prettier.config.cjs\",\n  \".prettierrc.toml\"\n];\nasync function filter({ name, path: file }) {\n  if (!await is_file_default(file)) {\n    return false;\n  }\n  if (name === \"package.json\") {\n    try {\n      return Boolean(await loadConfigFromPackageJson(file));\n    } catch {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getSearcher(stopDirectory) {\n  return new searcher_default({ names: CONFIG_FILE_NAMES, filter, stopDirectory });\n}\nvar config_searcher_default = getSearcher;\n\n// src/config/prettier-config/load-config.js\nimport path7 from \"path\";\n\n// src/utils/import-from-file.js\nimport { pathToFileURL as pathToFileURL4 } from \"url\";\n\n// node_modules/import-meta-resolve/lib/resolve.js\nimport assert3 from \"assert\";\nimport { Stats, statSync, realpathSync } from \"fs\";\nimport process3 from \"process\";\nimport { URL as URL3, fileURLToPath as fileURLToPath5, pathToFileURL as pathToFileURL3 } from \"url\";\nimport path6 from \"path\";\nimport { builtinModules } from \"module\";\n\n// node_modules/import-meta-resolve/lib/get-format.js\nimport { fileURLToPath as fileURLToPath4 } from \"url\";\n\n// node_modules/import-meta-resolve/lib/package-config.js\nimport { URL as URL2, fileURLToPath as fileURLToPath3 } from \"url\";\n\n// node_modules/import-meta-resolve/lib/package-json-reader.js\nimport fs5 from \"fs\";\nimport path5 from \"path\";\nimport { fileURLToPath as fileURLToPath2 } from \"url\";\n\n// node_modules/import-meta-resolve/lib/errors.js\nimport v8 from \"v8\";\nimport assert2 from \"assert\";\nimport { format, inspect } from \"util\";\nvar own = {}.hasOwnProperty;\nvar classRegExp = /^([A-Z][a-z\\d]*)+$/;\nvar kTypes = /* @__PURE__ */ new Set([\n  \"string\",\n  \"function\",\n  \"number\",\n  \"object\",\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  \"Function\",\n  \"Object\",\n  \"boolean\",\n  \"bigint\",\n  \"symbol\"\n]);\nvar codes = {};\nfunction formatList(array2, type2 = \"and\") {\n  return array2.length < 3 ? array2.join(` ${type2} `) : `${array2.slice(0, -1).join(\", \")}, ${type2} ${array2[array2.length - 1]}`;\n}\nvar messages = /* @__PURE__ */ new Map();\nvar nodeInternalPrefix = \"__node_internal_\";\nvar userStackTraceLimit;\ncodes.ERR_INVALID_ARG_TYPE = createError(\n  \"ERR_INVALID_ARG_TYPE\",\n  /**\n   * @param {string} name\n   * @param {Array<string> | string} expected\n   * @param {unknown} actual\n   */\n  (name, expected, actual) => {\n    assert2(typeof name === \"string\", \"'name' must be a string\");\n    if (!Array.isArray(expected)) {\n      expected = [expected];\n    }\n    let message = \"The \";\n    if (name.endsWith(\" argument\")) {\n      message += `${name} `;\n    } else {\n      const type2 = name.includes(\".\") ? \"property\" : \"argument\";\n      message += `\"${name}\" ${type2} `;\n    }\n    message += \"must be \";\n    const types = [];\n    const instances = [];\n    const other = [];\n    for (const value of expected) {\n      assert2(\n        typeof value === \"string\",\n        \"All expected entries have to be of type string\"\n      );\n      if (kTypes.has(value)) {\n        types.push(value.toLowerCase());\n      } else if (classRegExp.exec(value) === null) {\n        assert2(\n          value !== \"object\",\n          'The value \"object\" should be written as \"Object\"'\n        );\n        other.push(value);\n      } else {\n        instances.push(value);\n      }\n    }\n    if (instances.length > 0) {\n      const pos2 = types.indexOf(\"object\");\n      if (pos2 !== -1) {\n        types.slice(pos2, 1);\n        instances.push(\"Object\");\n      }\n    }\n    if (types.length > 0) {\n      message += `${types.length > 1 ? \"one of type\" : \"of type\"} ${formatList(\n        types,\n        \"or\"\n      )}`;\n      if (instances.length > 0 || other.length > 0)\n        message += \" or \";\n    }\n    if (instances.length > 0) {\n      message += `an instance of ${formatList(instances, \"or\")}`;\n      if (other.length > 0)\n        message += \" or \";\n    }\n    if (other.length > 0) {\n      if (other.length > 1) {\n        message += `one of ${formatList(other, \"or\")}`;\n      } else {\n        if (other[0].toLowerCase() !== other[0])\n          message += \"an \";\n        message += `${other[0]}`;\n      }\n    }\n    message += `. Received ${determineSpecificType(actual)}`;\n    return message;\n  },\n  TypeError\n);\ncodes.ERR_INVALID_MODULE_SPECIFIER = createError(\n  \"ERR_INVALID_MODULE_SPECIFIER\",\n  /**\n   * @param {string} request\n   * @param {string} reason\n   * @param {string} [base]\n   */\n  (request, reason, base = void 0) => {\n    return `Invalid module \"${request}\" ${reason}${base ? ` imported from ${base}` : \"\"}`;\n  },\n  TypeError\n);\ncodes.ERR_INVALID_PACKAGE_CONFIG = createError(\n  \"ERR_INVALID_PACKAGE_CONFIG\",\n  /**\n   * @param {string} path\n   * @param {string} [base]\n   * @param {string} [message]\n   */\n  (path13, base, message) => {\n    return `Invalid package config ${path13}${base ? ` while importing ${base}` : \"\"}${message ? `. ${message}` : \"\"}`;\n  },\n  Error\n);\ncodes.ERR_INVALID_PACKAGE_TARGET = createError(\n  \"ERR_INVALID_PACKAGE_TARGET\",\n  /**\n   * @param {string} pkgPath\n   * @param {string} key\n   * @param {unknown} target\n   * @param {boolean} [isImport=false]\n   * @param {string} [base]\n   */\n  (pkgPath, key2, target, isImport = false, base = void 0) => {\n    const relError = typeof target === \"string\" && !isImport && target.length > 0 && !target.startsWith(\"./\");\n    if (key2 === \".\") {\n      assert2(isImport === false);\n      return `Invalid \"exports\" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}${relError ? '; targets must start with \"./\"' : \"\"}`;\n    }\n    return `Invalid \"${isImport ? \"imports\" : \"exports\"}\" target ${JSON.stringify(\n      target\n    )} defined for '${key2}' in the package config ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}${relError ? '; targets must start with \"./\"' : \"\"}`;\n  },\n  Error\n);\ncodes.ERR_MODULE_NOT_FOUND = createError(\n  \"ERR_MODULE_NOT_FOUND\",\n  /**\n   * @param {string} path\n   * @param {string} base\n   * @param {boolean} [exactUrl]\n   */\n  (path13, base, exactUrl = false) => {\n    return `Cannot find ${exactUrl ? \"module\" : \"package\"} '${path13}' imported from ${base}`;\n  },\n  Error\n);\ncodes.ERR_NETWORK_IMPORT_DISALLOWED = createError(\n  \"ERR_NETWORK_IMPORT_DISALLOWED\",\n  \"import of '%s' by %s is not supported: %s\",\n  Error\n);\ncodes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(\n  \"ERR_PACKAGE_IMPORT_NOT_DEFINED\",\n  /**\n   * @param {string} specifier\n   * @param {string} packagePath\n   * @param {string} base\n   */\n  (specifier, packagePath, base) => {\n    return `Package import specifier \"${specifier}\" is not defined${packagePath ? ` in package ${packagePath}package.json` : \"\"} imported from ${base}`;\n  },\n  TypeError\n);\ncodes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(\n  \"ERR_PACKAGE_PATH_NOT_EXPORTED\",\n  /**\n   * @param {string} pkgPath\n   * @param {string} subpath\n   * @param {string} [base]\n   */\n  (pkgPath, subpath, base = void 0) => {\n    if (subpath === \".\")\n      return `No \"exports\" main defined in ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}`;\n    return `Package subpath '${subpath}' is not defined by \"exports\" in ${pkgPath}package.json${base ? ` imported from ${base}` : \"\"}`;\n  },\n  Error\n);\ncodes.ERR_UNSUPPORTED_DIR_IMPORT = createError(\n  \"ERR_UNSUPPORTED_DIR_IMPORT\",\n  \"Directory import '%s' is not supported resolving ES modules imported from %s\",\n  Error\n);\ncodes.ERR_UNKNOWN_FILE_EXTENSION = createError(\n  \"ERR_UNKNOWN_FILE_EXTENSION\",\n  /**\n   * @param {string} ext\n   * @param {string} path\n   */\n  (ext, path13) => {\n    return `Unknown file extension \"${ext}\" for ${path13}`;\n  },\n  TypeError\n);\ncodes.ERR_INVALID_ARG_VALUE = createError(\n  \"ERR_INVALID_ARG_VALUE\",\n  /**\n   * @param {string} name\n   * @param {unknown} value\n   * @param {string} [reason='is invalid']\n   */\n  (name, value, reason = \"is invalid\") => {\n    let inspected = inspect(value);\n    if (inspected.length > 128) {\n      inspected = `${inspected.slice(0, 128)}...`;\n    }\n    const type2 = name.includes(\".\") ? \"property\" : \"argument\";\n    return `The ${type2} '${name}' ${reason}. Received ${inspected}`;\n  },\n  TypeError\n  // Note: extra classes have been shaken out.\n  // , RangeError\n);\nfunction createError(sym, value, def) {\n  messages.set(sym, value);\n  return makeNodeErrorWithCode(def, sym);\n}\nfunction makeNodeErrorWithCode(Base, key2) {\n  return NodeError;\n  function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = 0;\n    const error = new Base();\n    if (isErrorStackTraceLimitWritable())\n      Error.stackTraceLimit = limit;\n    const message = getMessage(key2, args, error);\n    Object.defineProperties(error, {\n      // Note: no need to implement `kIsNodeError` symbol, would be hard,\n      // probably.\n      message: {\n        value: message,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      },\n      toString: {\n        /** @this {Error} */\n        value() {\n          return `${this.name} [${key2}]: ${this.message}`;\n        },\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    captureLargerStackTrace(error);\n    error.code = key2;\n    return error;\n  }\n}\nfunction isErrorStackTraceLimitWritable() {\n  try {\n    if (v8.startupSnapshot.isBuildingSnapshot()) {\n      return false;\n    }\n  } catch {\n  }\n  const desc = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n  if (desc === void 0) {\n    return Object.isExtensible(Error);\n  }\n  return own.call(desc, \"writable\") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;\n}\nfunction hideStackFrames(fn) {\n  const hidden = nodeInternalPrefix + fn.name;\n  Object.defineProperty(fn, \"name\", { value: hidden });\n  return fn;\n}\nvar captureLargerStackTrace = hideStackFrames(\n  /**\n   * @param {Error} error\n   * @returns {Error}\n   */\n  // @ts-expect-error: fine\n  function(error) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Number.POSITIVE_INFINITY;\n    }\n    Error.captureStackTrace(error);\n    if (stackTraceLimitIsWritable)\n      Error.stackTraceLimit = userStackTraceLimit;\n    return error;\n  }\n);\nfunction getMessage(key2, args, self) {\n  const message = messages.get(key2);\n  assert2(message !== void 0, \"expected `message` to be found\");\n  if (typeof message === \"function\") {\n    assert2(\n      message.length <= args.length,\n      // Default options do not count.\n      `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`\n    );\n    return Reflect.apply(message, self, args);\n  }\n  const regex = /%[dfijoOs]/g;\n  let expectedLength = 0;\n  while (regex.exec(message) !== null)\n    expectedLength++;\n  assert2(\n    expectedLength === args.length,\n    `Code: ${key2}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return message;\n  args.unshift(message);\n  return Reflect.apply(format, null, args);\n}\nfunction determineSpecificType(value) {\n  if (value === null || value === void 0) {\n    return String(value);\n  }\n  if (typeof value === \"function\" && value.name) {\n    return `function ${value.name}`;\n  }\n  if (typeof value === \"object\") {\n    if (value.constructor && value.constructor.name) {\n      return `an instance of ${value.constructor.name}`;\n    }\n    return `${inspect(value, { depth: -1 })}`;\n  }\n  let inspected = inspect(value, { colors: false });\n  if (inspected.length > 28) {\n    inspected = `${inspected.slice(0, 25)}...`;\n  }\n  return `type ${typeof value} (${inspected})`;\n}\n\n// node_modules/import-meta-resolve/lib/package-json-reader.js\nvar hasOwnProperty = {}.hasOwnProperty;\nvar { ERR_INVALID_PACKAGE_CONFIG } = codes;\nvar cache = /* @__PURE__ */ new Map();\nvar reader = { read: read2 };\nvar package_json_reader_default = reader;\nfunction read2(jsonPath, { base, specifier }) {\n  const existing = cache.get(jsonPath);\n  if (existing) {\n    return existing;\n  }\n  let string;\n  try {\n    string = fs5.readFileSync(path5.toNamespacedPath(jsonPath), \"utf8\");\n  } catch (error) {\n    const exception2 = (\n      /** @type {ErrnoException} */\n      error\n    );\n    if (exception2.code !== \"ENOENT\") {\n      throw exception2;\n    }\n  }\n  const result = {\n    exists: false,\n    pjsonPath: jsonPath,\n    main: void 0,\n    name: void 0,\n    type: \"none\",\n    // Ignore unknown types for forwards compatibility\n    exports: void 0,\n    imports: void 0\n  };\n  if (string !== void 0) {\n    let parsed;\n    try {\n      parsed = JSON.parse(string);\n    } catch (error_) {\n      const cause = (\n        /** @type {ErrnoException} */\n        error_\n      );\n      const error = new ERR_INVALID_PACKAGE_CONFIG(\n        jsonPath,\n        (base ? `\"${specifier}\" from ` : \"\") + fileURLToPath2(base || specifier),\n        cause.message\n      );\n      error.cause = cause;\n      throw error;\n    }\n    result.exists = true;\n    if (hasOwnProperty.call(parsed, \"name\") && typeof parsed.name === \"string\") {\n      result.name = parsed.name;\n    }\n    if (hasOwnProperty.call(parsed, \"main\") && typeof parsed.main === \"string\") {\n      result.main = parsed.main;\n    }\n    if (hasOwnProperty.call(parsed, \"exports\")) {\n      result.exports = parsed.exports;\n    }\n    if (hasOwnProperty.call(parsed, \"imports\")) {\n      result.imports = parsed.imports;\n    }\n    if (hasOwnProperty.call(parsed, \"type\") && (parsed.type === \"commonjs\" || parsed.type === \"module\")) {\n      result.type = parsed.type;\n    }\n  }\n  cache.set(jsonPath, result);\n  return result;\n}\n\n// node_modules/import-meta-resolve/lib/package-config.js\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL2(\"package.json\", resolved);\n  while (true) {\n    const packageJSONPath2 = packageJSONUrl.pathname;\n    if (packageJSONPath2.endsWith(\"node_modules/package.json\")) {\n      break;\n    }\n    const packageConfig = package_json_reader_default.read(\n      fileURLToPath3(packageJSONUrl),\n      { specifier: resolved }\n    );\n    if (packageConfig.exists) {\n      return packageConfig;\n    }\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL2(\"../package.json\", packageJSONUrl);\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {\n      break;\n    }\n  }\n  const packageJSONPath = fileURLToPath3(packageJSONUrl);\n  return {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: void 0,\n    name: void 0,\n    type: \"none\",\n    exports: void 0,\n    imports: void 0\n  };\n}\n\n// node_modules/import-meta-resolve/lib/resolve-get-package-type.js\nfunction getPackageType(url2) {\n  const packageConfig = getPackageScopeConfig(url2);\n  return packageConfig.type;\n}\n\n// node_modules/import-meta-resolve/lib/get-format.js\nvar { ERR_UNKNOWN_FILE_EXTENSION } = codes;\nvar hasOwnProperty2 = {}.hasOwnProperty;\nvar extensionFormatMap = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  \".cjs\": \"commonjs\",\n  \".js\": \"module\",\n  \".json\": \"json\",\n  \".mjs\": \"module\"\n};\nfunction mimeToFormat(mime) {\n  if (mime && /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i.test(mime))\n    return \"module\";\n  if (mime === \"application/json\")\n    return \"json\";\n  return null;\n}\nvar protocolHandlers = {\n  // @ts-expect-error: hush.\n  __proto__: null,\n  \"data:\": getDataProtocolModuleFormat,\n  \"file:\": getFileProtocolModuleFormat,\n  \"http:\": getHttpProtocolModuleFormat,\n  \"https:\": getHttpProtocolModuleFormat,\n  \"node:\"() {\n    return \"builtin\";\n  }\n};\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = /^([^/]+\\/[^;,]+)[^,]*?(;base64)?,/.exec(\n    parsed.pathname\n  ) || [null, null, null];\n  return mimeToFormat(mime);\n}\nfunction extname(url2) {\n  const pathname = url2.pathname;\n  let index = pathname.length;\n  while (index--) {\n    const code = pathname.codePointAt(index);\n    if (code === 47) {\n      return \"\";\n    }\n    if (code === 46) {\n      return pathname.codePointAt(index - 1) === 47 ? \"\" : pathname.slice(index);\n    }\n  }\n  return \"\";\n}\nfunction getFileProtocolModuleFormat(url2, _context, ignoreErrors) {\n  const ext = extname(url2);\n  if (ext === \".js\") {\n    const packageType = getPackageType(url2);\n    if (packageType !== \"none\") {\n      return packageType;\n    }\n    return \"commonjs\";\n  }\n  if (ext === \"\") {\n    const packageType = getPackageType(url2);\n    if (packageType === \"none\" || packageType === \"commonjs\") {\n      return \"commonjs\";\n    }\n    return \"module\";\n  }\n  const format3 = extensionFormatMap[ext];\n  if (format3)\n    return format3;\n  if (ignoreErrors) {\n    return void 0;\n  }\n  const filepath = fileURLToPath4(url2);\n  throw new ERR_UNKNOWN_FILE_EXTENSION(ext, filepath);\n}\nfunction getHttpProtocolModuleFormat() {\n}\nfunction defaultGetFormatWithoutErrors(url2, context) {\n  const protocol = url2.protocol;\n  if (!hasOwnProperty2.call(protocolHandlers, protocol)) {\n    return null;\n  }\n  return protocolHandlers[protocol](url2, context, true) || null;\n}\n\n// node_modules/import-meta-resolve/lib/utils.js\nvar { ERR_INVALID_ARG_VALUE } = codes;\nvar DEFAULT_CONDITIONS = Object.freeze([\"node\", \"import\"]);\nvar DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);\nfunction getDefaultConditions() {\n  return DEFAULT_CONDITIONS;\n}\nfunction getDefaultConditionsSet() {\n  return DEFAULT_CONDITIONS_SET;\n}\nfunction getConditionsSet(conditions) {\n  if (conditions !== void 0 && conditions !== getDefaultConditions()) {\n    if (!Array.isArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE(\n        \"conditions\",\n        conditions,\n        \"expected an array\"\n      );\n    }\n    return new Set(conditions);\n  }\n  return getDefaultConditionsSet();\n}\n\n// node_modules/import-meta-resolve/lib/resolve.js\nvar RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];\nvar {\n  ERR_NETWORK_IMPORT_DISALLOWED,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT\n} = codes;\nvar own2 = {}.hasOwnProperty;\nvar invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\\\|\\/|$)/i;\nvar deprecatedInvalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nvar invalidPackageNameRegEx = /^\\.|%|\\\\/;\nvar patternRegEx = /\\*/g;\nvar encodedSepRegEx = /%2f|%5c/i;\nvar emittedPackageWarnings = /* @__PURE__ */ new Set();\nvar doubleSlashRegEx = /[/\\\\]{2}/;\nfunction emitInvalidSegmentDeprecation(target, request, match, packageJsonUrl, internal, base, isTarget) {\n  if (process3.noDeprecation) {\n    return;\n  }\n  const pjsonPath = fileURLToPath5(packageJsonUrl);\n  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;\n  process3.emitWarning(\n    `Use of deprecated ${double ? \"double slash\" : \"leading or trailing slash matching\"} resolving \"${target}\" for module request \"${request}\" ${request === match ? \"\" : `matched to \"${match}\" `}in the \"${internal ? \"imports\" : \"exports\"}\" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath5(base)}` : \"\"}.`,\n    \"DeprecationWarning\",\n    \"DEP0166\"\n  );\n}\nfunction emitLegacyIndexDeprecation(url2, packageJsonUrl, base, main) {\n  if (process3.noDeprecation) {\n    return;\n  }\n  const format3 = defaultGetFormatWithoutErrors(url2, { parentURL: base.href });\n  if (format3 !== \"module\")\n    return;\n  const urlPath = fileURLToPath5(url2.href);\n  const pkgPath = fileURLToPath5(new URL3(\".\", packageJsonUrl));\n  const basePath = fileURLToPath5(base);\n  if (!main) {\n    process3.emitWarning(\n      `No \"main\" or \"exports\" field defined in the package.json for ${pkgPath} resolving the main entry point \"${urlPath.slice(\n        pkgPath.length\n      )}\", imported from ${basePath}.\nDefault \"index\" lookups for the main are deprecated for ES modules.`,\n      \"DeprecationWarning\",\n      \"DEP0151\"\n    );\n  } else if (path6.resolve(pkgPath, main) !== urlPath) {\n    process3.emitWarning(\n      `Package ${pkgPath} has a \"main\" field set to \"${main}\", excluding the full filename and extension to the resolved file at \"${urlPath.slice(\n        pkgPath.length\n      )}\", imported from ${basePath}.\n Automatic extension resolution of the \"main\" field is deprecated for ES modules.`,\n      \"DeprecationWarning\",\n      \"DEP0151\"\n    );\n  }\n}\nfunction tryStatSync(path13) {\n  try {\n    return statSync(path13);\n  } catch {\n    return new Stats();\n  }\n}\nfunction fileExists(url2) {\n  const stats = statSync(url2, { throwIfNoEntry: false });\n  const isFile2 = stats ? stats.isFile() : void 0;\n  return isFile2 === null || isFile2 === void 0 ? false : isFile2;\n}\nfunction legacyMainResolve(packageJsonUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== void 0) {\n    guess = new URL3(packageConfig.main, packageJsonUrl);\n    if (fileExists(guess))\n      return guess;\n    const tries2 = [\n      `./${packageConfig.main}.js`,\n      `./${packageConfig.main}.json`,\n      `./${packageConfig.main}.node`,\n      `./${packageConfig.main}/index.js`,\n      `./${packageConfig.main}/index.json`,\n      `./${packageConfig.main}/index.node`\n    ];\n    let i2 = -1;\n    while (++i2 < tries2.length) {\n      guess = new URL3(tries2[i2], packageJsonUrl);\n      if (fileExists(guess))\n        break;\n      guess = void 0;\n    }\n    if (guess) {\n      emitLegacyIndexDeprecation(\n        guess,\n        packageJsonUrl,\n        base,\n        packageConfig.main\n      );\n      return guess;\n    }\n  }\n  const tries = [\"./index.js\", \"./index.json\", \"./index.node\"];\n  let i = -1;\n  while (++i < tries.length) {\n    guess = new URL3(tries[i], packageJsonUrl);\n    if (fileExists(guess))\n      break;\n    guess = void 0;\n  }\n  if (guess) {\n    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);\n    return guess;\n  }\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath5(new URL3(\".\", packageJsonUrl)),\n    fileURLToPath5(base)\n  );\n}\nfunction finalizeResolution(resolved, base, preserveSymlinks) {\n  if (encodedSepRegEx.exec(resolved.pathname) !== null) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname,\n      'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath5(base)\n    );\n  }\n  let filePath;\n  try {\n    filePath = fileURLToPath5(resolved);\n  } catch (error) {\n    const cause = (\n      /** @type {ErrnoException} */\n      error\n    );\n    Object.defineProperty(cause, \"input\", { value: String(resolved) });\n    Object.defineProperty(cause, \"module\", { value: String(base) });\n    throw cause;\n  }\n  const stats = tryStatSync(\n    filePath.endsWith(\"/\") ? filePath.slice(-1) : filePath\n  );\n  if (stats.isDirectory()) {\n    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath5(base));\n    error.url = String(resolved);\n    throw error;\n  }\n  if (!stats.isFile()) {\n    const error = new ERR_MODULE_NOT_FOUND(\n      filePath || resolved.pathname,\n      base && fileURLToPath5(base),\n      true\n    );\n    error.url = String(resolved);\n    throw error;\n  }\n  if (!preserveSymlinks) {\n    const real = realpathSync(filePath);\n    const { search, hash } = resolved;\n    resolved = pathToFileURL3(real + (filePath.endsWith(path6.sep) ? \"/\" : \"\"));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n  return resolved;\n}\nfunction importNotDefined(specifier, packageJsonUrl, base) {\n  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier,\n    packageJsonUrl && fileURLToPath5(new URL3(\".\", packageJsonUrl)),\n    fileURLToPath5(base)\n  );\n}\nfunction exportsNotFound(subpath, packageJsonUrl, base) {\n  return new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath5(new URL3(\".\", packageJsonUrl)),\n    subpath,\n    base && fileURLToPath5(base)\n  );\n}\nfunction throwInvalidSubpath(request, match, packageJsonUrl, internal, base) {\n  const reason = `request is not a valid match in pattern \"${match}\" for the \"${internal ? \"imports\" : \"exports\"}\" resolution of ${fileURLToPath5(packageJsonUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(\n    request,\n    reason,\n    base && fileURLToPath5(base)\n  );\n}\nfunction invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {\n  target = typeof target === \"object\" && target !== null ? JSON.stringify(target, null, \"\") : `${target}`;\n  return new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath5(new URL3(\".\", packageJsonUrl)),\n    subpath,\n    target,\n    internal,\n    base && fileURLToPath5(base)\n  );\n}\nfunction resolvePackageTargetString(target, subpath, match, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {\n  if (subpath !== \"\" && !pattern && target[target.length - 1] !== \"/\")\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  if (!target.startsWith(\"./\")) {\n    if (internal && !target.startsWith(\"../\") && !target.startsWith(\"/\")) {\n      let isURL2 = false;\n      try {\n        new URL3(target);\n        isURL2 = true;\n      } catch {\n      }\n      if (!isURL2) {\n        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(\n          patternRegEx,\n          target,\n          () => subpath\n        ) : target + subpath;\n        return packageResolve(exportTarget, packageJsonUrl, conditions);\n      }\n    }\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  }\n  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {\n    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {\n      if (!isPathMap) {\n        const request = pattern ? match.replace(\"*\", () => subpath) : match + subpath;\n        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(\n          patternRegEx,\n          target,\n          () => subpath\n        ) : target;\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          true\n        );\n      }\n    } else {\n      throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);\n    }\n  }\n  const resolved = new URL3(target, packageJsonUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL3(\".\", packageJsonUrl).pathname;\n  if (!resolvedPath.startsWith(packagePath))\n    throw invalidPackageTarget(match, target, packageJsonUrl, internal, base);\n  if (subpath === \"\")\n    return resolved;\n  if (invalidSegmentRegEx.exec(subpath) !== null) {\n    const request = pattern ? match.replace(\"*\", () => subpath) : match + subpath;\n    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {\n      if (!isPathMap) {\n        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(\n          patternRegEx,\n          target,\n          () => subpath\n        ) : target;\n        emitInvalidSegmentDeprecation(\n          resolvedTarget,\n          request,\n          match,\n          packageJsonUrl,\n          internal,\n          base,\n          false\n        );\n      }\n    } else {\n      throwInvalidSubpath(request, match, packageJsonUrl, internal, base);\n    }\n  }\n  if (pattern) {\n    return new URL3(\n      RegExpPrototypeSymbolReplace.call(\n        patternRegEx,\n        resolved.href,\n        () => subpath\n      )\n    );\n  }\n  return new URL3(subpath, resolved);\n}\nfunction isArrayIndex(key2) {\n  const keyNumber = Number(key2);\n  if (`${keyNumber}` !== key2)\n    return false;\n  return keyNumber >= 0 && keyNumber < 4294967295;\n}\nfunction resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {\n  if (typeof target === \"string\") {\n    return resolvePackageTargetString(\n      target,\n      subpath,\n      packageSubpath,\n      packageJsonUrl,\n      base,\n      pattern,\n      internal,\n      isPathMap,\n      conditions\n    );\n  }\n  if (Array.isArray(target)) {\n    const targetList = target;\n    if (targetList.length === 0)\n      return null;\n    let lastException;\n    let i = -1;\n    while (++i < targetList.length) {\n      const targetItem = targetList[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          targetItem,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        );\n      } catch (error) {\n        const exception2 = (\n          /** @type {ErrnoException} */\n          error\n        );\n        lastException = exception2;\n        if (exception2.code === \"ERR_INVALID_PACKAGE_TARGET\")\n          continue;\n        throw error;\n      }\n      if (resolveResult === void 0)\n        continue;\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === void 0 || lastException === null) {\n      return null;\n    }\n    throw lastException;\n  }\n  if (typeof target === \"object\" && target !== null) {\n    const keys = Object.getOwnPropertyNames(target);\n    let i = -1;\n    while (++i < keys.length) {\n      const key2 = keys[i];\n      if (isArrayIndex(key2)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG2(\n          fileURLToPath5(packageJsonUrl),\n          base,\n          '\"exports\" cannot contain numeric property keys.'\n        );\n      }\n    }\n    i = -1;\n    while (++i < keys.length) {\n      const key2 = keys[i];\n      if (key2 === \"default\" || conditions && conditions.has(key2)) {\n        const conditionalTarget = (\n          /** @type {unknown} */\n          target[key2]\n        );\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          conditionalTarget,\n          subpath,\n          packageSubpath,\n          base,\n          pattern,\n          internal,\n          isPathMap,\n          conditions\n        );\n        if (resolveResult === void 0)\n          continue;\n        return resolveResult;\n      }\n    }\n    return null;\n  }\n  if (target === null) {\n    return null;\n  }\n  throw invalidPackageTarget(\n    packageSubpath,\n    target,\n    packageJsonUrl,\n    internal,\n    base\n  );\n}\nfunction isConditionalExportsMainSugar(exports, packageJsonUrl, base) {\n  if (typeof exports === \"string\" || Array.isArray(exports))\n    return true;\n  if (typeof exports !== \"object\" || exports === null)\n    return false;\n  const keys = Object.getOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  let j = -1;\n  while (++j < keys.length) {\n    const key2 = keys[j];\n    const curIsConditionalSugar = key2 === \"\" || key2[0] !== \".\";\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG2(\n        fileURLToPath5(packageJsonUrl),\n        base,\n        `\"exports\" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`\n      );\n    }\n  }\n  return isConditionalSugar;\n}\nfunction emitTrailingSlashPatternDeprecation(match, pjsonUrl, base) {\n  if (process3.noDeprecation) {\n    return;\n  }\n  const pjsonPath = fileURLToPath5(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + \"|\" + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + \"|\" + match);\n  process3.emitWarning(\n    `Use of deprecated trailing slash pattern mapping \"${match}\" in the \"exports\" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath5(base)}` : \"\"}. Mapping specifiers ending in \"/\" is no longer supported.`,\n    \"DeprecationWarning\",\n    \"DEP0155\"\n  );\n}\nfunction packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {\n    exports = { \".\": exports };\n  }\n  if (own2.call(exports, packageSubpath) && !packageSubpath.includes(\"*\") && !packageSubpath.endsWith(\"/\")) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      \"\",\n      packageSubpath,\n      base,\n      false,\n      false,\n      false,\n      conditions\n    );\n    if (resolveResult === null || resolveResult === void 0) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base);\n    }\n    return resolveResult;\n  }\n  let bestMatch = \"\";\n  let bestMatchSubpath = \"\";\n  const keys = Object.getOwnPropertyNames(exports);\n  let i = -1;\n  while (++i < keys.length) {\n    const key2 = keys[i];\n    const patternIndex = key2.indexOf(\"*\");\n    if (patternIndex !== -1 && packageSubpath.startsWith(key2.slice(0, patternIndex))) {\n      if (packageSubpath.endsWith(\"/\")) {\n        emitTrailingSlashPatternDeprecation(\n          packageSubpath,\n          packageJsonUrl,\n          base\n        );\n      }\n      const patternTrailer = key2.slice(patternIndex + 1);\n      if (packageSubpath.length >= key2.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf(\"*\") === patternIndex) {\n        bestMatch = key2;\n        bestMatchSubpath = packageSubpath.slice(\n          patternIndex,\n          packageSubpath.length - patternTrailer.length\n        );\n      }\n    }\n  }\n  if (bestMatch) {\n    const target = (\n      /** @type {unknown} */\n      exports[bestMatch]\n    );\n    const resolveResult = resolvePackageTarget(\n      packageJsonUrl,\n      target,\n      bestMatchSubpath,\n      bestMatch,\n      base,\n      true,\n      false,\n      packageSubpath.endsWith(\"/\"),\n      conditions\n    );\n    if (resolveResult === null || resolveResult === void 0) {\n      throw exportsNotFound(packageSubpath, packageJsonUrl, base);\n    }\n    return resolveResult;\n  }\n  throw exportsNotFound(packageSubpath, packageJsonUrl, base);\n}\nfunction patternKeyCompare(a, b) {\n  const aPatternIndex = a.indexOf(\"*\");\n  const bPatternIndex = b.indexOf(\"*\");\n  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLengthA > baseLengthB)\n    return -1;\n  if (baseLengthB > baseLengthA)\n    return 1;\n  if (aPatternIndex === -1)\n    return 1;\n  if (bPatternIndex === -1)\n    return -1;\n  if (a.length > b.length)\n    return -1;\n  if (b.length > a.length)\n    return 1;\n  return 0;\n}\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === \"#\" || name.startsWith(\"#/\") || name.endsWith(\"/\")) {\n    const reason = \"is not a valid internal imports specifier name\";\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath5(base));\n  }\n  let packageJsonUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJsonUrl = pathToFileURL3(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (own2.call(imports, name) && !name.includes(\"*\")) {\n        const resolveResult = resolvePackageTarget(\n          packageJsonUrl,\n          imports[name],\n          \"\",\n          name,\n          base,\n          false,\n          true,\n          false,\n          conditions\n        );\n        if (resolveResult !== null && resolveResult !== void 0) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = \"\";\n        let bestMatchSubpath = \"\";\n        const keys = Object.getOwnPropertyNames(imports);\n        let i = -1;\n        while (++i < keys.length) {\n          const key2 = keys[i];\n          const patternIndex = key2.indexOf(\"*\");\n          if (patternIndex !== -1 && name.startsWith(key2.slice(0, -1))) {\n            const patternTrailer = key2.slice(patternIndex + 1);\n            if (name.length >= key2.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf(\"*\") === patternIndex) {\n              bestMatch = key2;\n              bestMatchSubpath = name.slice(\n                patternIndex,\n                name.length - patternTrailer.length\n              );\n            }\n          }\n        }\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(\n            packageJsonUrl,\n            target,\n            bestMatchSubpath,\n            bestMatch,\n            base,\n            true,\n            true,\n            false,\n            conditions\n          );\n          if (resolveResult !== null && resolveResult !== void 0) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throw importNotDefined(name, packageJsonUrl, base);\n}\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = specifier.indexOf(\"/\");\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === \"@\") {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = specifier.indexOf(\"/\", separatorIndex + 1);\n    }\n  }\n  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);\n  if (invalidPackageNameRegEx.exec(packageName) !== null) {\n    validPackageName = false;\n  }\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier,\n      \"is not a valid package name\",\n      fileURLToPath5(base)\n    );\n  }\n  const packageSubpath = \".\" + (separatorIndex === -1 ? \"\" : specifier.slice(separatorIndex));\n  return { packageName, packageSubpath, isScoped };\n}\nfunction packageResolve(specifier, base, conditions) {\n  if (builtinModules.includes(specifier)) {\n    return new URL3(\"node:\" + specifier);\n  }\n  const { packageName, packageSubpath, isScoped } = parsePackageName(\n    specifier,\n    base\n  );\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJsonUrl2 = pathToFileURL3(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJsonUrl2,\n        packageSubpath,\n        packageConfig,\n        base,\n        conditions\n      );\n    }\n  }\n  let packageJsonUrl = new URL3(\n    \"./node_modules/\" + packageName + \"/package.json\",\n    base\n  );\n  let packageJsonPath = fileURLToPath5(packageJsonUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(packageJsonPath.slice(0, -13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJsonPath;\n      packageJsonUrl = new URL3(\n        (isScoped ? \"../../../../node_modules/\" : \"../../../node_modules/\") + packageName + \"/package.json\",\n        packageJsonUrl\n      );\n      packageJsonPath = fileURLToPath5(packageJsonUrl);\n      continue;\n    }\n    const packageConfig2 = package_json_reader_default.read(packageJsonPath, {\n      base,\n      specifier\n    });\n    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {\n      return packageExportsResolve(\n        packageJsonUrl,\n        packageSubpath,\n        packageConfig2,\n        base,\n        conditions\n      );\n    }\n    if (packageSubpath === \".\") {\n      return legacyMainResolve(packageJsonUrl, packageConfig2, base);\n    }\n    return new URL3(packageSubpath, packageJsonUrl);\n  } while (packageJsonPath.length !== lastPath.length);\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath5(base), false);\n}\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === \".\") {\n    if (specifier.length === 1 || specifier[1] === \"/\")\n      return true;\n    if (specifier[1] === \".\" && (specifier.length === 2 || specifier[2] === \"/\")) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === \"\")\n    return false;\n  if (specifier[0] === \"/\")\n    return true;\n  return isRelativeSpecifier(specifier);\n}\nfunction moduleResolve(specifier, base, conditions, preserveSymlinks) {\n  const protocol = base.protocol;\n  const isRemote = protocol === \"http:\" || protocol === \"https:\";\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL3(specifier, base);\n  } else if (!isRemote && specifier[0] === \"#\") {\n    resolved = packageImportsResolve(specifier, base, conditions);\n  } else {\n    try {\n      resolved = new URL3(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier, base, conditions);\n      }\n    }\n  }\n  assert3(resolved !== void 0, \"expected to be defined\");\n  if (resolved.protocol !== \"file:\") {\n    return resolved;\n  }\n  return finalizeResolution(resolved, base, preserveSymlinks);\n}\nfunction checkIfDisallowedImport(specifier, parsed, parsedParentURL) {\n  if (parsedParentURL) {\n    const parentProtocol = parsedParentURL.protocol;\n    if (parentProtocol === \"http:\" || parentProtocol === \"https:\") {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        const parsedProtocol = parsed == null ? void 0 : parsed.protocol;\n        if (parsedProtocol && parsedProtocol !== \"https:\" && parsedProtocol !== \"http:\") {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier,\n            parsedParentURL,\n            \"remote imports cannot import from a local location.\"\n          );\n        }\n        return { url: (parsed == null ? void 0 : parsed.href) || \"\" };\n      }\n      if (builtinModules.includes(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier,\n          parsedParentURL,\n          \"remote imports cannot import from a local location.\"\n        );\n      }\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier,\n        parsedParentURL,\n        \"only relative and absolute specifiers are supported.\"\n      );\n    }\n  }\n}\nfunction isURL(self) {\n  return Boolean(\n    self && typeof self === \"object\" && \"href\" in self && typeof self.href === \"string\" && \"protocol\" in self && typeof self.protocol === \"string\" && self.href && self.protocol\n  );\n}\nfunction throwIfInvalidParentURL(parentURL) {\n  if (parentURL === void 0) {\n    return;\n  }\n  if (typeof parentURL !== \"string\" && !isURL(parentURL)) {\n    throw new codes.ERR_INVALID_ARG_TYPE(\n      \"parentURL\",\n      [\"string\", \"URL\"],\n      parentURL\n    );\n  }\n}\nfunction defaultResolve(specifier, context = {}) {\n  const { parentURL } = context;\n  assert3(parentURL !== void 0, \"expected `parentURL` to be defined\");\n  throwIfInvalidParentURL(parentURL);\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL3(parentURL);\n    } catch {\n    }\n  }\n  let parsed;\n  try {\n    parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new URL3(specifier, parsedParentURL) : new URL3(specifier);\n    const protocol = parsed.protocol;\n    if (protocol === \"data:\") {\n      return { url: parsed.href, format: null };\n    }\n  } catch {\n  }\n  const maybeReturn = checkIfDisallowedImport(\n    specifier,\n    parsed,\n    parsedParentURL\n  );\n  if (maybeReturn)\n    return maybeReturn;\n  if (parsed && parsed.protocol === \"node:\")\n    return { url: specifier };\n  const conditions = getConditionsSet(context.conditions);\n  const url2 = moduleResolve(specifier, new URL3(parentURL), conditions, false);\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems, silencing them\n    url: url2.href,\n    format: defaultGetFormatWithoutErrors(url2, { parentURL })\n  };\n}\n\n// node_modules/import-meta-resolve/index.js\nfunction resolve2(specifier, parent) {\n  if (!parent) {\n    throw new Error(\n      \"Please pass `parent`: `import-meta-resolve` cannot ponyfill that\"\n    );\n  }\n  try {\n    return defaultResolve(specifier, { parentURL: parent }).url;\n  } catch (error) {\n    const exception2 = (\n      /** @type {ErrnoException} */\n      error\n    );\n    if ((exception2.code === \"ERR_UNSUPPORTED_DIR_IMPORT\" || exception2.code === \"ERR_MODULE_NOT_FOUND\") && typeof exception2.url === \"string\") {\n      return exception2.url;\n    }\n    throw error;\n  }\n}\n\n// src/utils/import-from-file.js\nfunction importFromFile(specifier, parent) {\n  const url2 = resolve2(specifier, pathToFileURL4(parent).href);\n  return import(url2);\n}\nvar import_from_file_default = importFromFile;\n\n// src/utils/require-from-file.js\nimport { createRequire } from \"module\";\nfunction requireFromFile(id, parent) {\n  const require2 = createRequire(parent);\n  return require2(id);\n}\nvar require_from_file_default = requireFromFile;\n\n// src/config/prettier-config/load-external-config.js\nvar requireErrorCodesShouldBeIgnored = /* @__PURE__ */ new Set([\n  \"MODULE_NOT_FOUND\",\n  \"ERR_REQUIRE_ESM\",\n  \"ERR_PACKAGE_PATH_NOT_EXPORTED\"\n]);\nasync function loadExternalConfig(externalConfig, configFile) {\n  try {\n    return require_from_file_default(externalConfig, configFile);\n  } catch (error) {\n    if (!requireErrorCodesShouldBeIgnored.has(error == null ? void 0 : error.code)) {\n      throw error;\n    }\n  }\n  const module = await import_from_file_default(externalConfig, configFile);\n  return module.default;\n}\nvar load_external_config_default = loadExternalConfig;\n\n// src/config/prettier-config/load-config.js\nasync function loadConfig(configFile) {\n  const { base: fileName, ext: extension } = path7.parse(configFile);\n  const load2 = fileName === \"package.json\" ? loadConfigFromPackageJson : loaders_default[extension];\n  if (!load2) {\n    throw new Error(\n      `No loader specified for extension \"${extension || \"noExt\"}\"`\n    );\n  }\n  let config = await load2(configFile);\n  if (!config) {\n    return;\n  }\n  if (typeof config === \"string\") {\n    config = await load_external_config_default(config, configFile);\n  }\n  if (typeof config !== \"object\") {\n    throw new TypeError(\n      `Config is only allowed to be an object, but received ${typeof config} in \"${configFile}\"`\n    );\n  }\n  delete config.$schema;\n  return config;\n}\nvar load_config_default = loadConfig;\n\n// src/config/prettier-config/index.js\nvar loadCache = /* @__PURE__ */ new Map();\nvar searchCache = /* @__PURE__ */ new Map();\nfunction clearPrettierConfigCache() {\n  loadCache.clear();\n  searchCache.clear();\n}\nfunction loadPrettierConfig(configFile, { shouldCache }) {\n  configFile = path8.resolve(configFile);\n  if (!shouldCache || !loadCache.has(configFile)) {\n    loadCache.set(configFile, load_config_default(configFile));\n  }\n  return loadCache.get(configFile);\n}\nfunction getSearchFunction(stopDirectory) {\n  stopDirectory = stopDirectory ? path8.resolve(stopDirectory) : void 0;\n  if (!searchCache.has(stopDirectory)) {\n    const searcher2 = config_searcher_default(stopDirectory);\n    const searchFunction = searcher2.search.bind(searcher2);\n    searchCache.set(stopDirectory, searchFunction);\n  }\n  return searchCache.get(stopDirectory);\n}\nfunction searchPrettierConfig(startDirectory, options8 = {}) {\n  startDirectory = startDirectory ? path8.resolve(startDirectory) : process.cwd();\n  const stopDirectory = mockable_default.getPrettierConfigSearchStopDirectory();\n  const search = getSearchFunction(stopDirectory);\n  return search(startDirectory, { shouldCache: options8.shouldCache });\n}\n\n// src/config/resolve-config.js\nfunction clearCache() {\n  clearPrettierConfigCache();\n  clearEditorconfigCache();\n}\nfunction loadEditorconfig2(file, options8) {\n  if (!file || !options8.editorconfig) {\n    return;\n  }\n  const shouldCache = options8.useCache;\n  return loadEditorconfig(file, { shouldCache });\n}\nasync function loadPrettierConfig2(file, options8) {\n  const shouldCache = options8.useCache;\n  let configFile = options8.config;\n  if (!configFile) {\n    const directory = file ? path9.dirname(path9.resolve(file)) : void 0;\n    configFile = await searchPrettierConfig(directory, { shouldCache });\n  }\n  if (!configFile) {\n    return;\n  }\n  const config = await loadPrettierConfig(configFile, { shouldCache });\n  return { config, configFile };\n}\nasync function resolveConfig(fileUrlOrPath, options8) {\n  options8 = { useCache: true, ...options8 };\n  const filePath = toPath(fileUrlOrPath);\n  const [result, editorConfigured] = await Promise.all([\n    loadPrettierConfig2(filePath, options8),\n    loadEditorconfig2(filePath, options8)\n  ]);\n  if (!result && !editorConfigured) {\n    return null;\n  }\n  const merged = {\n    ...editorConfigured,\n    ...mergeOverrides(result, filePath)\n  };\n  if (Array.isArray(merged.plugins)) {\n    merged.plugins = merged.plugins.map(\n      (value) => typeof value === \"string\" && value.startsWith(\".\") ? path9.resolve(path9.dirname(result.configFile), value) : value\n    );\n  }\n  return merged;\n}\nasync function resolveConfigFile(fileUrlOrPath) {\n  const directory = fileUrlOrPath ? path9.dirname(path9.resolve(toPath(fileUrlOrPath))) : void 0;\n  const result = await searchPrettierConfig(directory, { shouldCache: false });\n  return result ?? null;\n}\nfunction mergeOverrides(configResult, filePath) {\n  const { config, configFile } = configResult || {};\n  const { overrides, ...options8 } = config || {};\n  if (filePath && overrides) {\n    const relativeFilePath = path9.relative(path9.dirname(configFile), filePath);\n    for (const override of overrides) {\n      if (pathMatchesGlobs(\n        relativeFilePath,\n        override.files,\n        override.excludeFiles\n      )) {\n        Object.assign(options8, override.options);\n      }\n    }\n  }\n  return options8;\n}\nfunction pathMatchesGlobs(filePath, patterns, excludedPatterns) {\n  const patternList = Array.isArray(patterns) ? patterns : [patterns];\n  const [withSlashes, withoutSlashes] = partition_default(\n    patternList,\n    (pattern) => pattern.includes(\"/\")\n  );\n  return import_micromatch.default.isMatch(filePath, withoutSlashes, {\n    ignore: excludedPatterns,\n    basename: true,\n    dot: true\n  }) || import_micromatch.default.isMatch(filePath, withSlashes, {\n    ignore: excludedPatterns,\n    basename: false,\n    dot: true\n  });\n}\n\n// scripts/build/shims/string-replace-all.js\nvar stringReplaceAll2 = (isOptionalObject, original, pattern, replacement) => {\n  if (isOptionalObject && (original === void 0 || original === null)) {\n    return;\n  }\n  if (original.replaceAll) {\n    return original.replaceAll(pattern, replacement);\n  }\n  if (pattern.global) {\n    return original.replace(pattern, replacement);\n  }\n  return original.split(pattern).join(replacement);\n};\nvar string_replace_all_default = stringReplaceAll2;\n\n// src/utils/ignore.js\nvar import_ignore = __toESM(require_ignore(), 1);\nimport path10 from \"path\";\nimport url from \"url\";\nvar createIgnore = import_ignore.default.default;\nvar slash = path10.sep === \"\\\\\" ? (filePath) => string_replace_all_default(\n  /* isOptionalObject*/\n  false,\n  filePath,\n  \"\\\\\",\n  \"/\"\n) : (filePath) => filePath;\nfunction getRelativePath(file, ignoreFile) {\n  const ignoreFilePath = toPath(ignoreFile);\n  const filePath = isUrl(file) ? url.fileURLToPath(file) : path10.resolve(file);\n  return path10.relative(\n    // If there's an ignore-path set, the filename must be relative to the\n    // ignore path, not the current working directory.\n    ignoreFilePath ? path10.dirname(ignoreFilePath) : process.cwd(),\n    filePath\n  );\n}\nasync function createSingleIsIgnoredFunction(ignoreFile, withNodeModules) {\n  let content = \"\";\n  if (ignoreFile) {\n    content += await read_file_default(ignoreFile) ?? \"\";\n  }\n  if (!withNodeModules) {\n    content += \"\\nnode_modules\";\n  }\n  if (!content) {\n    return;\n  }\n  const ignore = createIgnore({\n    allowRelativePaths: true\n  }).add(content);\n  return (file) => ignore.ignores(slash(getRelativePath(file, ignoreFile)));\n}\nasync function createIsIgnoredFunction(ignoreFiles, withNodeModules) {\n  if (ignoreFiles.length === 0 && !withNodeModules) {\n    ignoreFiles = [void 0];\n  }\n  const isIgnoredFunctions = (await Promise.all(ignoreFiles.map((ignoreFile) => createSingleIsIgnoredFunction(ignoreFile, withNodeModules)))).filter(Boolean);\n  return (file) => isIgnoredFunctions.some((isIgnored2) => isIgnored2(file));\n}\nasync function isIgnored(file, options8) {\n  const {\n    ignorePath: ignoreFiles,\n    withNodeModules\n  } = options8;\n  const isIgnored2 = await createIsIgnoredFunction(ignoreFiles, withNodeModules);\n  return isIgnored2(file);\n}\n\n// src/utils/get-interpreter.js\nvar import_n_readlines = __toESM(require_readlines(), 1);\nimport fs6 from \"fs\";\nfunction getInterpreter(file) {\n  let fd;\n  try {\n    fd = fs6.openSync(file, \"r\");\n  } catch {\n    return;\n  }\n  try {\n    const liner = new import_n_readlines.default(fd);\n    const firstLine = liner.next().toString(\"utf8\");\n    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);\n    if (m1) {\n      return m1[1];\n    }\n    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);\n    if (m2) {\n      return m2[1];\n    }\n  } finally {\n    try {\n      fs6.closeSync(fd);\n    } catch {\n    }\n  }\n}\nvar get_interpreter_default = getInterpreter;\n\n// src/utils/infer-parser.js\nvar getFileBasename = (file) => String(file).split(/[/\\\\]/).pop();\nfunction getLanguageByFileName(languages2, file) {\n  if (!file) {\n    return;\n  }\n  const basename = getFileBasename(file).toLowerCase();\n  return languages2.find(\n    ({ filenames }) => filenames == null ? void 0 : filenames.some((name) => name.toLowerCase() === basename)\n  ) ?? languages2.find(\n    ({ extensions }) => extensions == null ? void 0 : extensions.some((extension) => basename.endsWith(extension))\n  );\n}\nfunction getLanguageByLanguageName(languages2, languageName) {\n  if (!languageName) {\n    return;\n  }\n  return languages2.find(({ name }) => name.toLowerCase() === languageName) ?? languages2.find(({ aliases }) => aliases == null ? void 0 : aliases.includes(languageName)) ?? languages2.find(({ extensions }) => extensions == null ? void 0 : extensions.includes(`.${languageName}`));\n}\nfunction getLanguageByInterpreter(languages2, file) {\n  if (!file || getFileBasename(file).includes(\".\")) {\n    return;\n  }\n  const interpreter = get_interpreter_default(file);\n  if (!interpreter) {\n    return;\n  }\n  return languages2.find(\n    ({ interpreters }) => interpreters == null ? void 0 : interpreters.includes(interpreter)\n  );\n}\nfunction inferParser(options8, fileInfo) {\n  const languages2 = options8.plugins.flatMap(\n    (plugin) => (\n      // @ts-expect-error -- Safe\n      plugin.languages ?? []\n    )\n  );\n  const language = getLanguageByLanguageName(languages2, fileInfo.language) ?? getLanguageByFileName(languages2, fileInfo.physicalFile) ?? getLanguageByFileName(languages2, fileInfo.file) ?? getLanguageByInterpreter(languages2, fileInfo.physicalFile);\n  return language == null ? void 0 : language.parsers[0];\n}\nvar infer_parser_default = inferParser;\n\n// src/common/get-file-info.js\nasync function getFileInfo(file, options8) {\n  if (typeof file !== \"string\" && !(file instanceof URL)) {\n    throw new TypeError(\n      `expect \\`file\\` to be a string or URL, got \\`${typeof file}\\``\n    );\n  }\n  let { ignorePath, withNodeModules } = options8;\n  if (!Array.isArray(ignorePath)) {\n    ignorePath = [ignorePath];\n  }\n  const ignored = await isIgnored(file, { ignorePath, withNodeModules });\n  let inferredParser;\n  if (!ignored) {\n    inferredParser = await getParser(file, options8);\n  }\n  return {\n    ignored,\n    inferredParser: inferredParser ?? null\n  };\n}\nasync function getParser(file, options8) {\n  let config;\n  if (options8.resolveConfig !== false) {\n    config = await resolveConfig(file);\n  }\n  return (config == null ? void 0 : config.parser) ?? infer_parser_default(options8, { physicalFile: file });\n}\nvar get_file_info_default = getFileInfo;\n\n// src/main/core.js\nvar import_diff = __toESM(require_array2(), 1);\n\n// src/common/end-of-line.js\nfunction guessEndOfLine(text) {\n  const index = text.indexOf(\"\\r\");\n  if (index >= 0) {\n    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";\n  }\n  return \"lf\";\n}\nfunction convertEndOfLineToChars(value) {\n  switch (value) {\n    case \"cr\":\n      return \"\\r\";\n    case \"crlf\":\n      return \"\\r\\n\";\n    default:\n      return \"\\n\";\n  }\n}\nfunction countEndOfLineChars(text, eol) {\n  let regex;\n  switch (eol) {\n    case \"\\n\":\n      regex = /\\n/g;\n      break;\n    case \"\\r\":\n      regex = /\\r/g;\n      break;\n    case \"\\r\\n\":\n      regex = /\\r\\n/g;\n      break;\n    default:\n      throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);\n  }\n  const endOfLines = text.match(regex);\n  return endOfLines ? endOfLines.length : 0;\n}\nfunction normalizeEndOfLine(text) {\n  return string_replace_all_default(\n    /* isOptionalObject*/\n    false,\n    text,\n    /\\r\\n?/g,\n    \"\\n\"\n  );\n}\n\n// src/document/constants.js\nvar DOC_TYPE_STRING = \"string\";\nvar DOC_TYPE_ARRAY = \"array\";\nvar DOC_TYPE_CURSOR = \"cursor\";\nvar DOC_TYPE_INDENT = \"indent\";\nvar DOC_TYPE_ALIGN = \"align\";\nvar DOC_TYPE_TRIM = \"trim\";\nvar DOC_TYPE_GROUP = \"group\";\nvar DOC_TYPE_FILL = \"fill\";\nvar DOC_TYPE_IF_BREAK = \"if-break\";\nvar DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";\nvar DOC_TYPE_LINE_SUFFIX = \"line-suffix\";\nvar DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";\nvar DOC_TYPE_LINE = \"line\";\nvar DOC_TYPE_LABEL = \"label\";\nvar DOC_TYPE_BREAK_PARENT = \"break-parent\";\nvar VALID_OBJECT_DOC_TYPES = /* @__PURE__ */ new Set([\n  DOC_TYPE_CURSOR,\n  DOC_TYPE_INDENT,\n  DOC_TYPE_ALIGN,\n  DOC_TYPE_TRIM,\n  DOC_TYPE_GROUP,\n  DOC_TYPE_FILL,\n  DOC_TYPE_IF_BREAK,\n  DOC_TYPE_INDENT_IF_BREAK,\n  DOC_TYPE_LINE_SUFFIX,\n  DOC_TYPE_LINE_SUFFIX_BOUNDARY,\n  DOC_TYPE_LINE,\n  DOC_TYPE_LABEL,\n  DOC_TYPE_BREAK_PARENT\n]);\n\n// src/document/utils/get-doc-type.js\nfunction getDocType(doc2) {\n  if (typeof doc2 === \"string\") {\n    return DOC_TYPE_STRING;\n  }\n  if (Array.isArray(doc2)) {\n    return DOC_TYPE_ARRAY;\n  }\n  if (!doc2) {\n    return;\n  }\n  const { type: type2 } = doc2;\n  if (VALID_OBJECT_DOC_TYPES.has(type2)) {\n    return type2;\n  }\n}\nvar get_doc_type_default = getDocType;\n\n// src/document/invalid-doc-error.js\nvar disjunctionListFormat = (list) => new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);\nfunction getDocErrorMessage(doc2) {\n  const type2 = doc2 === null ? \"null\" : typeof doc2;\n  if (type2 !== \"string\" && type2 !== \"object\") {\n    return `Unexpected doc '${type2}', \nExpected it to be 'string' or 'object'.`;\n  }\n  if (get_doc_type_default(doc2)) {\n    throw new Error(\"doc is valid.\");\n  }\n  const objectType = Object.prototype.toString.call(doc2);\n  if (objectType !== \"[object Object]\") {\n    return `Unexpected doc '${objectType}'.`;\n  }\n  const EXPECTED_TYPE_VALUES = disjunctionListFormat(\n    [...VALID_OBJECT_DOC_TYPES].map((type3) => `'${type3}'`)\n  );\n  return `Unexpected doc.type '${doc2.type}'.\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;\n}\nvar InvalidDocError = class extends Error {\n  name = \"InvalidDocError\";\n  constructor(doc2) {\n    super(getDocErrorMessage(doc2));\n    this.doc = doc2;\n  }\n};\nvar invalid_doc_error_default = InvalidDocError;\n\n// src/document/utils/traverse-doc.js\nvar traverseDocOnExitStackMarker = {};\nfunction traverseDoc(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {\n  const docsStack = [doc2];\n  while (docsStack.length > 0) {\n    const doc3 = docsStack.pop();\n    if (doc3 === traverseDocOnExitStackMarker) {\n      onExit(docsStack.pop());\n      continue;\n    }\n    if (onExit) {\n      docsStack.push(doc3, traverseDocOnExitStackMarker);\n    }\n    const docType = get_doc_type_default(doc3);\n    if (!docType) {\n      throw new invalid_doc_error_default(doc3);\n    }\n    if ((onEnter == null ? void 0 : onEnter(doc3)) === false) {\n      continue;\n    }\n    switch (docType) {\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = docType === DOC_TYPE_ARRAY ? doc3 : doc3.parts;\n        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n          docsStack.push(parts[i]);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n        docsStack.push(doc3.flatContents, doc3.breakContents);\n        break;\n      case DOC_TYPE_GROUP:\n        if (shouldTraverseConditionalGroups && doc3.expandedStates) {\n          for (let ic = doc3.expandedStates.length, i = ic - 1; i >= 0; --i) {\n            docsStack.push(doc3.expandedStates[i]);\n          }\n        } else {\n          docsStack.push(doc3.contents);\n        }\n        break;\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        docsStack.push(doc3.contents);\n        break;\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc3);\n    }\n  }\n}\nvar traverse_doc_default = traverseDoc;\n\n// src/document/utils/assert-doc.js\nvar noop = () => {\n};\nvar assertDoc = true ? noop : function(doc2) {\n  traverse_doc_default(doc2, (doc3) => {\n    if (checked.has(doc3)) {\n      return false;\n    }\n    if (typeof doc3 !== \"string\") {\n      checked.add(doc3);\n    }\n  });\n};\nvar assertDocArray = true ? noop : function(docs, optional = false) {\n  if (optional && !docs) {\n    return;\n  }\n  if (!Array.isArray(docs)) {\n    throw new TypeError(\"Unexpected doc array.\");\n  }\n  for (const doc2 of docs) {\n    assertDoc(doc2);\n  }\n};\n\n// src/document/builders.js\nfunction indent(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_INDENT, contents };\n}\nfunction align(widthOrString, contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };\n}\nfunction fill(parts) {\n  assertDocArray(parts);\n  return { type: DOC_TYPE_FILL, parts };\n}\nfunction lineSuffix(contents) {\n  assertDoc(contents);\n  return { type: DOC_TYPE_LINE_SUFFIX, contents };\n}\nvar breakParent = { type: DOC_TYPE_BREAK_PARENT };\nvar hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };\nvar line2 = { type: DOC_TYPE_LINE };\nvar hardline = [hardlineWithoutBreakParent, breakParent];\nvar cursor = { type: DOC_TYPE_CURSOR };\nfunction addAlignmentToDoc(doc2, size, tabWidth) {\n  assertDoc(doc2);\n  let aligned = doc2;\n  if (size > 0) {\n    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n      aligned = indent(aligned);\n    }\n    aligned = align(size % tabWidth, aligned);\n    aligned = align(Number.NEGATIVE_INFINITY, aligned);\n  }\n  return aligned;\n}\n\n// src/document/debug.js\nfunction flattenDoc(doc2) {\n  var _a;\n  if (!doc2) {\n    return \"\";\n  }\n  if (Array.isArray(doc2)) {\n    const res = [];\n    for (const part of doc2) {\n      if (Array.isArray(part)) {\n        res.push(...flattenDoc(part));\n      } else {\n        const flattened = flattenDoc(part);\n        if (flattened !== \"\") {\n          res.push(flattened);\n        }\n      }\n    }\n    return res;\n  }\n  if (doc2.type === DOC_TYPE_IF_BREAK) {\n    return {\n      ...doc2,\n      breakContents: flattenDoc(doc2.breakContents),\n      flatContents: flattenDoc(doc2.flatContents)\n    };\n  }\n  if (doc2.type === DOC_TYPE_GROUP) {\n    return {\n      ...doc2,\n      contents: flattenDoc(doc2.contents),\n      expandedStates: (_a = doc2.expandedStates) == null ? void 0 : _a.map(flattenDoc)\n    };\n  }\n  if (doc2.type === DOC_TYPE_FILL) {\n    return { type: \"fill\", parts: doc2.parts.map(flattenDoc) };\n  }\n  if (doc2.contents) {\n    return { ...doc2, contents: flattenDoc(doc2.contents) };\n  }\n  return doc2;\n}\nfunction printDocToDebug(doc2) {\n  const printedSymbols = /* @__PURE__ */ Object.create(null);\n  const usedKeysForSymbols = /* @__PURE__ */ new Set();\n  return printDoc(flattenDoc(doc2));\n  function printDoc(doc3, index, parentParts) {\n    var _a, _b;\n    if (typeof doc3 === \"string\") {\n      return JSON.stringify(doc3);\n    }\n    if (Array.isArray(doc3)) {\n      const printed = doc3.map(printDoc).filter(Boolean);\n      return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;\n    }\n    if (doc3.type === DOC_TYPE_LINE) {\n      const withBreakParent = ((_a = parentParts == null ? void 0 : parentParts[index + 1]) == null ? void 0 : _a.type) === DOC_TYPE_BREAK_PARENT;\n      if (doc3.literal) {\n        return withBreakParent ? \"literalline\" : \"literallineWithoutBreakParent\";\n      }\n      if (doc3.hard) {\n        return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";\n      }\n      if (doc3.soft) {\n        return \"softline\";\n      }\n      return \"line\";\n    }\n    if (doc3.type === DOC_TYPE_BREAK_PARENT) {\n      const afterHardline = ((_b = parentParts == null ? void 0 : parentParts[index - 1]) == null ? void 0 : _b.type) === DOC_TYPE_LINE && parentParts[index - 1].hard;\n      return afterHardline ? void 0 : \"breakParent\";\n    }\n    if (doc3.type === DOC_TYPE_TRIM) {\n      return \"trim\";\n    }\n    if (doc3.type === DOC_TYPE_INDENT) {\n      return \"indent(\" + printDoc(doc3.contents) + \")\";\n    }\n    if (doc3.type === DOC_TYPE_ALIGN) {\n      return doc3.n === Number.NEGATIVE_INFINITY ? \"dedentToRoot(\" + printDoc(doc3.contents) + \")\" : doc3.n < 0 ? \"dedent(\" + printDoc(doc3.contents) + \")\" : doc3.n.type === \"root\" ? \"markAsRoot(\" + printDoc(doc3.contents) + \")\" : \"align(\" + JSON.stringify(doc3.n) + \", \" + printDoc(doc3.contents) + \")\";\n    }\n    if (doc3.type === DOC_TYPE_IF_BREAK) {\n      return \"ifBreak(\" + printDoc(doc3.breakContents) + (doc3.flatContents ? \", \" + printDoc(doc3.flatContents) : \"\") + (doc3.groupId ? (!doc3.flatContents ? ', \"\"' : \"\") + `, { groupId: ${printGroupId(doc3.groupId)} }` : \"\") + \")\";\n    }\n    if (doc3.type === DOC_TYPE_INDENT_IF_BREAK) {\n      const optionsParts = [];\n      if (doc3.negate) {\n        optionsParts.push(\"negate: true\");\n      }\n      if (doc3.groupId) {\n        optionsParts.push(`groupId: ${printGroupId(doc3.groupId)}`);\n      }\n      const options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n      return `indentIfBreak(${printDoc(doc3.contents)}${options8})`;\n    }\n    if (doc3.type === DOC_TYPE_GROUP) {\n      const optionsParts = [];\n      if (doc3.break && doc3.break !== \"propagated\") {\n        optionsParts.push(\"shouldBreak: true\");\n      }\n      if (doc3.id) {\n        optionsParts.push(`id: ${printGroupId(doc3.id)}`);\n      }\n      const options8 = optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";\n      if (doc3.expandedStates) {\n        return `conditionalGroup([${doc3.expandedStates.map((part) => printDoc(part)).join(\",\")}]${options8})`;\n      }\n      return `group(${printDoc(doc3.contents)}${options8})`;\n    }\n    if (doc3.type === DOC_TYPE_FILL) {\n      return `fill([${doc3.parts.map((part) => printDoc(part)).join(\", \")}])`;\n    }\n    if (doc3.type === DOC_TYPE_LINE_SUFFIX) {\n      return \"lineSuffix(\" + printDoc(doc3.contents) + \")\";\n    }\n    if (doc3.type === DOC_TYPE_LINE_SUFFIX_BOUNDARY) {\n      return \"lineSuffixBoundary\";\n    }\n    if (doc3.type === DOC_TYPE_LABEL) {\n      return `label(${JSON.stringify(doc3.label)}, ${printDoc(doc3.contents)})`;\n    }\n    throw new Error(\"Unknown doc type \" + doc3.type);\n  }\n  function printGroupId(id) {\n    if (typeof id !== \"symbol\") {\n      return JSON.stringify(String(id));\n    }\n    if (id in printedSymbols) {\n      return printedSymbols[id];\n    }\n    const prefix = id.description || \"symbol\";\n    for (let counter = 0; ; counter++) {\n      const key2 = prefix + (counter > 0 ? ` #${counter}` : \"\");\n      if (!usedKeysForSymbols.has(key2)) {\n        usedKeysForSymbols.add(key2);\n        return printedSymbols[id] = `Symbol.for(${JSON.stringify(key2)})`;\n      }\n    }\n  }\n}\n\n// scripts/build/shims/at.js\nvar at = (isOptionalObject, object, index) => {\n  if (isOptionalObject && (object === void 0 || object === null)) {\n    return;\n  }\n  if (Array.isArray(object) || typeof object === \"string\") {\n    return object[index < 0 ? object.length + index : index];\n  }\n  return object.at(index);\n};\nvar at_default = at;\n\n// node_modules/emoji-regex/index.mjs\nvar emoji_regex_default = () => {\n  return /[#*0-9]\\uFE0F?\\u20E3|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26AA\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C8\\u26CF\\u26D1\\u26E9\\u26F0-\\u26F5\\u26F7\\u26F8\\u26FA\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2757\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B55\\u3030\\u303D\\u3297\\u3299]\\uFE0F?|[\\u261D\\u270C\\u270D](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\u270A\\u270B](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u2693\\u26A1\\u26AB\\u26C5\\u26CE\\u26D4\\u26EA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2795-\\u2797\\u27B0\\u27BF\\u2B50]|\\u26D3\\uFE0F?(?:\\u200D\\uD83D\\uDCA5)?|\\u26F9(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\u2764\\uFE0F?(?:\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79))?|\\uD83C(?:[\\uDC04\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]\\uFE0F?|[\\uDF85\\uDFC2\\uDFC7](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDFC4\\uDFCA](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDFCB\\uDFCC](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF43\\uDF45-\\uDF4A\\uDF4C-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uDDE6\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF]|\\uDDE7\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF]|\\uDDE8\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF]|\\uDDE9\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF]|\\uDDEA\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA]|\\uDDEB\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7]|\\uDDEC\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE]|\\uDDED\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA]|\\uDDEE\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9]|\\uDDEF\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5]|\\uDDF0\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF]|\\uDDF1\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE]|\\uDDF2\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF]|\\uDDF3\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF]|\\uDDF4\\uD83C\\uDDF2|\\uDDF5\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE]|\\uDDF6\\uD83C\\uDDE6|\\uDDF7\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC]|\\uDDF8\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF]|\\uDDF9\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF]|\\uDDFA\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF]|\\uDDFB\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA]|\\uDDFC\\uD83C[\\uDDEB\\uDDF8]|\\uDDFD\\uD83C\\uDDF0|\\uDDFE\\uD83C[\\uDDEA\\uDDF9]|\\uDDFF\\uD83C[\\uDDE6\\uDDF2\\uDDFC]|\\uDF44(?:\\u200D\\uD83D\\uDFEB)?|\\uDF4B(?:\\u200D\\uD83D\\uDFE9)?|\\uDFC3(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDFF3\\uFE0F?(?:\\u200D(?:\\u26A7\\uFE0F?|\\uD83C\\uDF08))?|\\uDFF4(?:\\u200D\\u2620\\uFE0F?|\\uDB40\\uDC67\\uDB40\\uDC62\\uDB40(?:\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F)?)|\\uD83D(?:[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3]\\uFE0F?|[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4\\uDEB5](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD74\\uDD90](?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC25\\uDC27-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE41\\uDE43\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEDC-\\uDEDF\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB\\uDFF0]|\\uDC08(?:\\u200D\\u2B1B)?|\\uDC15(?:\\u200D\\uD83E\\uDDBA)?|\\uDC26(?:\\u200D(?:\\u2B1B|\\uD83D\\uDD25))?|\\uDC3B(?:\\u200D\\u2744\\uFE0F?)?|\\uDC41\\uFE0F?(?:\\u200D\\uD83D\\uDDE8\\uFE0F?)?|\\uDC68(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDC68\\uDC69]\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?)|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?\\uDC68\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC69(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:\\uDC8B\\u200D\\uD83D)?[\\uDC68\\uDC69]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D(?:[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?|\\uDC69\\u200D\\uD83D(?:\\uDC66(?:\\u200D\\uD83D\\uDC66)?|\\uDC67(?:\\u200D\\uD83D[\\uDC66\\uDC67])?))|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFC-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D\\uD83D(?:[\\uDC68\\uDC69]|\\uDC8B\\u200D\\uD83D[\\uDC68\\uDC69])\\uD83C[\\uDFFB-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83D[\\uDC68\\uDC69]\\uD83C[\\uDFFB-\\uDFFE])))?))?|\\uDC6F(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDD75(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|\\uDE2E(?:\\u200D\\uD83D\\uDCA8)?|\\uDE35(?:\\u200D\\uD83D\\uDCAB)?|\\uDE36(?:\\u200D\\uD83C\\uDF2B\\uFE0F?)?|\\uDE42(?:\\u200D[\\u2194\\u2195]\\uFE0F?)?|\\uDEB6(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?)|\\uD83E(?:[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5\\uDEC3-\\uDEC5\\uDEF0\\uDEF2-\\uDEF8](?:\\uD83C[\\uDFFB-\\uDFFF])?|[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD\\uDDCF\\uDDD4\\uDDD6-\\uDDDD](?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDDDE\\uDDDF](?:\\u200D[\\u2640\\u2642]\\uFE0F?)?|[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCC\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE7C\\uDE80-\\uDE88\\uDE90-\\uDEBD\\uDEBF-\\uDEC2\\uDECE-\\uDEDB\\uDEE0-\\uDEE8]|\\uDD3C(?:\\u200D[\\u2640\\u2642]\\uFE0F?|\\uD83C[\\uDFFB-\\uDFFF])?|\\uDDCE(?:\\uD83C[\\uDFFB-\\uDFFF])?(?:\\u200D(?:[\\u2640\\u2642]\\uFE0F?(?:\\u200D\\u27A1\\uFE0F?)?|\\u27A1\\uFE0F?))?|\\uDDD1(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1|\\uDDD1\\u200D\\uD83E\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?|\\uDDD2(?:\\u200D\\uD83E\\uDDD2)?))|\\uD83C(?:\\uDFFB(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFC-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFC(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFD-\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFD(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFE(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFD\\uDFFF]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?|\\uDFFF(?:\\u200D(?:[\\u2695\\u2696\\u2708]\\uFE0F?|\\u2764\\uFE0F?\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFE]|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E(?:[\\uDDAF\\uDDBC\\uDDBD](?:\\u200D\\u27A1\\uFE0F?)?|[\\uDDB0-\\uDDB3]|\\uDD1D\\u200D\\uD83E\\uDDD1\\uD83C[\\uDFFB-\\uDFFF])))?))?|\\uDEF1(?:\\uD83C(?:\\uDFFB(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFC-\\uDFFF])?|\\uDFFC(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])?|\\uDFFD(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])?|\\uDFFE(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])?|\\uDFFF(?:\\u200D\\uD83E\\uDEF2\\uD83C[\\uDFFB-\\uDFFE])?))?)/g;\n};\n\n// node_modules/get-east-asian-width/lookup.js\nfunction isFullWidth(x) {\n  return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;\n}\nfunction isWide(x) {\n  return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;\n}\n\n// node_modules/get-east-asian-width/index.js\nvar _isNarrowWidth = (codePoint) => !(isFullWidth(codePoint) || isWide(codePoint));\n\n// src/utils/get-string-width.js\nvar notAsciiRegex = /[^\\x20-\\x7F]/;\nfunction getStringWidth(text) {\n  if (!text) {\n    return 0;\n  }\n  if (!notAsciiRegex.test(text)) {\n    return text.length;\n  }\n  text = text.replace(emoji_regex_default(), \"  \");\n  let width = 0;\n  for (const character of text) {\n    const codePoint = character.codePointAt(0);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    width += _isNarrowWidth(codePoint) ? 1 : 2;\n  }\n  return width;\n}\nvar get_string_width_default = getStringWidth;\n\n// src/document/utils.js\nvar getDocParts = (doc2) => {\n  if (Array.isArray(doc2)) {\n    return doc2;\n  }\n  if (doc2.type !== DOC_TYPE_FILL) {\n    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);\n  }\n  return doc2.parts;\n};\nfunction mapDoc(doc2, cb) {\n  if (typeof doc2 === \"string\") {\n    return cb(doc2);\n  }\n  const mapped = /* @__PURE__ */ new Map();\n  return rec(doc2);\n  function rec(doc3) {\n    if (mapped.has(doc3)) {\n      return mapped.get(doc3);\n    }\n    const result = process4(doc3);\n    mapped.set(doc3, result);\n    return result;\n  }\n  function process4(doc3) {\n    switch (get_doc_type_default(doc3)) {\n      case DOC_TYPE_ARRAY:\n        return cb(doc3.map(rec));\n      case DOC_TYPE_FILL:\n        return cb({\n          ...doc3,\n          parts: doc3.parts.map(rec)\n        });\n      case DOC_TYPE_IF_BREAK:\n        return cb({\n          ...doc3,\n          breakContents: rec(doc3.breakContents),\n          flatContents: rec(doc3.flatContents)\n        });\n      case DOC_TYPE_GROUP: {\n        let {\n          expandedStates,\n          contents\n        } = doc3;\n        if (expandedStates) {\n          expandedStates = expandedStates.map(rec);\n          contents = expandedStates[0];\n        } else {\n          contents = rec(contents);\n        }\n        return cb({\n          ...doc3,\n          contents,\n          expandedStates\n        });\n      }\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n      case DOC_TYPE_LINE_SUFFIX:\n        return cb({\n          ...doc3,\n          contents: rec(doc3.contents)\n        });\n      case DOC_TYPE_STRING:\n      case DOC_TYPE_CURSOR:\n      case DOC_TYPE_TRIM:\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n      case DOC_TYPE_LINE:\n      case DOC_TYPE_BREAK_PARENT:\n        return cb(doc3);\n      default:\n        throw new invalid_doc_error_default(doc3);\n    }\n  }\n}\nfunction breakParentGroup(groupStack) {\n  if (groupStack.length > 0) {\n    const parentGroup = at_default(\n      /* isOptionalObject*/\n      false,\n      groupStack,\n      -1\n    );\n    if (!parentGroup.expandedStates && !parentGroup.break) {\n      parentGroup.break = \"propagated\";\n    }\n  }\n  return null;\n}\nfunction propagateBreaks(doc2) {\n  const alreadyVisitedSet = /* @__PURE__ */ new Set();\n  const groupStack = [];\n  function propagateBreaksOnEnterFn(doc3) {\n    if (doc3.type === DOC_TYPE_BREAK_PARENT) {\n      breakParentGroup(groupStack);\n    }\n    if (doc3.type === DOC_TYPE_GROUP) {\n      groupStack.push(doc3);\n      if (alreadyVisitedSet.has(doc3)) {\n        return false;\n      }\n      alreadyVisitedSet.add(doc3);\n    }\n  }\n  function propagateBreaksOnExitFn(doc3) {\n    if (doc3.type === DOC_TYPE_GROUP) {\n      const group = groupStack.pop();\n      if (group.break) {\n        breakParentGroup(groupStack);\n      }\n    }\n  }\n  traverse_doc_default(\n    doc2,\n    propagateBreaksOnEnterFn,\n    propagateBreaksOnExitFn,\n    /* shouldTraverseConditionalGroups */\n    true\n  );\n}\nfunction stripTrailingHardlineFromParts(parts) {\n  parts = [...parts];\n  while (parts.length >= 2 && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -2\n  ).type === DOC_TYPE_LINE && at_default(\n    /* isOptionalObject*/\n    false,\n    parts,\n    -1\n  ).type === DOC_TYPE_BREAK_PARENT) {\n    parts.length -= 2;\n  }\n  if (parts.length > 0) {\n    const lastPart = stripTrailingHardlineFromDoc(at_default(\n      /* isOptionalObject*/\n      false,\n      parts,\n      -1\n    ));\n    parts[parts.length - 1] = lastPart;\n  }\n  return parts;\n}\nfunction stripTrailingHardlineFromDoc(doc2) {\n  switch (get_doc_type_default(doc2)) {\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_GROUP:\n    case DOC_TYPE_LINE_SUFFIX:\n    case DOC_TYPE_LABEL: {\n      const contents = stripTrailingHardlineFromDoc(doc2.contents);\n      return {\n        ...doc2,\n        contents\n      };\n    }\n    case DOC_TYPE_IF_BREAK:\n      return {\n        ...doc2,\n        breakContents: stripTrailingHardlineFromDoc(doc2.breakContents),\n        flatContents: stripTrailingHardlineFromDoc(doc2.flatContents)\n      };\n    case DOC_TYPE_FILL:\n      return {\n        ...doc2,\n        parts: stripTrailingHardlineFromParts(doc2.parts)\n      };\n    case DOC_TYPE_ARRAY:\n      return stripTrailingHardlineFromParts(doc2);\n    case DOC_TYPE_STRING:\n      return doc2.replace(/[\\n\\r]*$/, \"\");\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc2);\n  }\n  return doc2;\n}\nfunction stripTrailingHardline(doc2) {\n  return stripTrailingHardlineFromDoc(cleanDoc(doc2));\n}\nfunction cleanDocFn(doc2) {\n  switch (get_doc_type_default(doc2)) {\n    case DOC_TYPE_FILL:\n      if (doc2.parts.every((part) => part === \"\")) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_GROUP:\n      if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates) {\n        return \"\";\n      }\n      if (doc2.contents.type === DOC_TYPE_GROUP && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates) {\n        return doc2.contents;\n      }\n      break;\n    case DOC_TYPE_ALIGN:\n    case DOC_TYPE_INDENT:\n    case DOC_TYPE_INDENT_IF_BREAK:\n    case DOC_TYPE_LINE_SUFFIX:\n      if (!doc2.contents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_IF_BREAK:\n      if (!doc2.flatContents && !doc2.breakContents) {\n        return \"\";\n      }\n      break;\n    case DOC_TYPE_ARRAY: {\n      const parts = [];\n      for (const part of doc2) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];\n        if (typeof currentPart === \"string\" && typeof at_default(\n          /* isOptionalObject*/\n          false,\n          parts,\n          -1\n        ) === \"string\") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return \"\";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return parts;\n    }\n    case DOC_TYPE_STRING:\n    case DOC_TYPE_CURSOR:\n    case DOC_TYPE_TRIM:\n    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n    case DOC_TYPE_LINE:\n    case DOC_TYPE_LABEL:\n    case DOC_TYPE_BREAK_PARENT:\n      break;\n    default:\n      throw new invalid_doc_error_default(doc2);\n  }\n  return doc2;\n}\nfunction cleanDoc(doc2) {\n  return mapDoc(doc2, (currentDoc) => cleanDocFn(currentDoc));\n}\nfunction inheritLabel(doc2, fn) {\n  return doc2.type === DOC_TYPE_LABEL ? {\n    ...doc2,\n    contents: fn(doc2.contents)\n  } : fn(doc2);\n}\n\n// src/document/printer.js\nvar MODE_BREAK = Symbol(\"MODE_BREAK\");\nvar MODE_FLAT = Symbol(\"MODE_FLAT\");\nvar CURSOR_PLACEHOLDER = Symbol(\"cursor\");\nfunction rootIndent() {\n  return {\n    value: \"\",\n    length: 0,\n    queue: []\n  };\n}\nfunction makeIndent(ind, options8) {\n  return generateInd(ind, {\n    type: \"indent\"\n  }, options8);\n}\nfunction makeAlign(indent2, widthOrDoc, options8) {\n  if (widthOrDoc === Number.NEGATIVE_INFINITY) {\n    return indent2.root || rootIndent();\n  }\n  if (widthOrDoc < 0) {\n    return generateInd(indent2, {\n      type: \"dedent\"\n    }, options8);\n  }\n  if (!widthOrDoc) {\n    return indent2;\n  }\n  if (widthOrDoc.type === \"root\") {\n    return {\n      ...indent2,\n      root: indent2\n    };\n  }\n  const alignType = typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";\n  return generateInd(indent2, {\n    type: alignType,\n    n: widthOrDoc\n  }, options8);\n}\nfunction generateInd(ind, newPart, options8) {\n  const queue = newPart.type === \"dedent\" ? ind.queue.slice(0, -1) : [...ind.queue, newPart];\n  let value = \"\";\n  let length = 0;\n  let lastTabs = 0;\n  let lastSpaces = 0;\n  for (const part of queue) {\n    switch (part.type) {\n      case \"indent\":\n        flush();\n        if (options8.useTabs) {\n          addTabs(1);\n        } else {\n          addSpaces(options8.tabWidth);\n        }\n        break;\n      case \"stringAlign\":\n        flush();\n        value += part.n;\n        length += part.n.length;\n        break;\n      case \"numberAlign\":\n        lastTabs += 1;\n        lastSpaces += part.n;\n        break;\n      default:\n        throw new Error(`Unexpected type '${part.type}'`);\n    }\n  }\n  flushSpaces();\n  return {\n    ...ind,\n    value,\n    length,\n    queue\n  };\n  function addTabs(count) {\n    value += \"\t\".repeat(count);\n    length += options8.tabWidth * count;\n  }\n  function addSpaces(count) {\n    value += \" \".repeat(count);\n    length += count;\n  }\n  function flush() {\n    if (options8.useTabs) {\n      flushTabs();\n    } else {\n      flushSpaces();\n    }\n  }\n  function flushTabs() {\n    if (lastTabs > 0) {\n      addTabs(lastTabs);\n    }\n    resetLast();\n  }\n  function flushSpaces() {\n    if (lastSpaces > 0) {\n      addSpaces(lastSpaces);\n    }\n    resetLast();\n  }\n  function resetLast() {\n    lastTabs = 0;\n    lastSpaces = 0;\n  }\n}\nfunction trim(out) {\n  let trimCount = 0;\n  let cursorCount = 0;\n  let outIndex = out.length;\n  outer:\n    while (outIndex--) {\n      const last = out[outIndex];\n      if (last === CURSOR_PLACEHOLDER) {\n        cursorCount++;\n        continue;\n      }\n      if (false) {\n        throw new Error(`Unexpected value in trim: '${typeof last}'`);\n      }\n      for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {\n        const char = last[charIndex];\n        if (char === \" \" || char === \"\t\") {\n          trimCount++;\n        } else {\n          out[outIndex] = last.slice(0, charIndex + 1);\n          break outer;\n        }\n      }\n    }\n  if (trimCount > 0 || cursorCount > 0) {\n    out.length = outIndex + 1;\n    while (cursorCount-- > 0) {\n      out.push(CURSOR_PLACEHOLDER);\n    }\n  }\n  return trimCount;\n}\nfunction fits(next, restCommands, width, hasLineSuffix, groupModeMap, mustBeFlat) {\n  if (width === Number.POSITIVE_INFINITY) {\n    return true;\n  }\n  let restIdx = restCommands.length;\n  const cmds = [next];\n  const out = [];\n  while (width >= 0) {\n    if (cmds.length === 0) {\n      if (restIdx === 0) {\n        return true;\n      }\n      cmds.push(restCommands[--restIdx]);\n      continue;\n    }\n    const {\n      mode,\n      doc: doc2\n    } = cmds.pop();\n    switch (get_doc_type_default(doc2)) {\n      case DOC_TYPE_STRING:\n        out.push(doc2);\n        width -= get_string_width_default(doc2);\n        break;\n      case DOC_TYPE_ARRAY:\n      case DOC_TYPE_FILL: {\n        const parts = getDocParts(doc2);\n        for (let i = parts.length - 1; i >= 0; i--) {\n          cmds.push({\n            mode,\n            doc: parts[i]\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_INDENT:\n      case DOC_TYPE_ALIGN:\n      case DOC_TYPE_INDENT_IF_BREAK:\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          mode,\n          doc: doc2.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        width += trim(out);\n        break;\n      case DOC_TYPE_GROUP: {\n        if (mustBeFlat && doc2.break) {\n          return false;\n        }\n        const groupMode = doc2.break ? MODE_BREAK : mode;\n        const contents = doc2.expandedStates && groupMode === MODE_BREAK ? at_default(\n          /* isOptionalObject*/\n          false,\n          doc2.expandedStates,\n          -1\n        ) : doc2.contents;\n        cmds.push({\n          mode: groupMode,\n          doc: contents\n        });\n        break;\n      }\n      case DOC_TYPE_IF_BREAK: {\n        const groupMode = doc2.groupId ? groupModeMap[doc2.groupId] || MODE_FLAT : mode;\n        const contents = groupMode === MODE_BREAK ? doc2.breakContents : doc2.flatContents;\n        if (contents) {\n          cmds.push({\n            mode,\n            doc: contents\n          });\n        }\n        break;\n      }\n      case DOC_TYPE_LINE:\n        if (mode === MODE_BREAK || doc2.hard) {\n          return true;\n        }\n        if (!doc2.soft) {\n          out.push(\" \");\n          width--;\n        }\n        break;\n      case DOC_TYPE_LINE_SUFFIX:\n        hasLineSuffix = true;\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (hasLineSuffix) {\n          return false;\n        }\n        break;\n    }\n  }\n  return false;\n}\nfunction printDocToString(doc2, options8) {\n  const groupModeMap = {};\n  const width = options8.printWidth;\n  const newLine = convertEndOfLineToChars(options8.endOfLine);\n  let pos2 = 0;\n  const cmds = [{\n    ind: rootIndent(),\n    mode: MODE_BREAK,\n    doc: doc2\n  }];\n  const out = [];\n  let shouldRemeasure = false;\n  const lineSuffix2 = [];\n  let printedCursorCount = 0;\n  propagateBreaks(doc2);\n  while (cmds.length > 0) {\n    const {\n      ind,\n      mode,\n      doc: doc3\n    } = cmds.pop();\n    switch (get_doc_type_default(doc3)) {\n      case DOC_TYPE_STRING: {\n        const formatted = newLine !== \"\\n\" ? string_replace_all_default(\n          /* isOptionalObject*/\n          false,\n          doc3,\n          \"\\n\",\n          newLine\n        ) : doc3;\n        out.push(formatted);\n        if (cmds.length > 0) {\n          pos2 += get_string_width_default(formatted);\n        }\n        break;\n      }\n      case DOC_TYPE_ARRAY:\n        for (let i = doc3.length - 1; i >= 0; i--) {\n          cmds.push({\n            ind,\n            mode,\n            doc: doc3[i]\n          });\n        }\n        break;\n      case DOC_TYPE_CURSOR:\n        if (printedCursorCount >= 2) {\n          throw new Error(\"There are too many 'cursor' in doc.\");\n        }\n        out.push(CURSOR_PLACEHOLDER);\n        printedCursorCount++;\n        break;\n      case DOC_TYPE_INDENT:\n        cmds.push({\n          ind: makeIndent(ind, options8),\n          mode,\n          doc: doc3.contents\n        });\n        break;\n      case DOC_TYPE_ALIGN:\n        cmds.push({\n          ind: makeAlign(ind, doc3.n, options8),\n          mode,\n          doc: doc3.contents\n        });\n        break;\n      case DOC_TYPE_TRIM:\n        pos2 -= trim(out);\n        break;\n      case DOC_TYPE_GROUP:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!shouldRemeasure) {\n              cmds.push({\n                ind,\n                mode: doc3.break ? MODE_BREAK : MODE_FLAT,\n                doc: doc3.contents\n              });\n              break;\n            }\n          case MODE_BREAK: {\n            shouldRemeasure = false;\n            const next = {\n              ind,\n              mode: MODE_FLAT,\n              doc: doc3.contents\n            };\n            const rem = width - pos2;\n            const hasLineSuffix = lineSuffix2.length > 0;\n            if (!doc3.break && fits(next, cmds, rem, hasLineSuffix, groupModeMap)) {\n              cmds.push(next);\n            } else {\n              if (doc3.expandedStates) {\n                const mostExpanded = at_default(\n                  /* isOptionalObject*/\n                  false,\n                  doc3.expandedStates,\n                  -1\n                );\n                if (doc3.break) {\n                  cmds.push({\n                    ind,\n                    mode: MODE_BREAK,\n                    doc: mostExpanded\n                  });\n                  break;\n                } else {\n                  for (let i = 1; i < doc3.expandedStates.length + 1; i++) {\n                    if (i >= doc3.expandedStates.length) {\n                      cmds.push({\n                        ind,\n                        mode: MODE_BREAK,\n                        doc: mostExpanded\n                      });\n                      break;\n                    } else {\n                      const state = doc3.expandedStates[i];\n                      const cmd = {\n                        ind,\n                        mode: MODE_FLAT,\n                        doc: state\n                      };\n                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {\n                        cmds.push(cmd);\n                        break;\n                      }\n                    }\n                  }\n                }\n              } else {\n                cmds.push({\n                  ind,\n                  mode: MODE_BREAK,\n                  doc: doc3.contents\n                });\n              }\n            }\n            break;\n          }\n        }\n        if (doc3.id) {\n          groupModeMap[doc3.id] = at_default(\n            /* isOptionalObject*/\n            false,\n            cmds,\n            -1\n          ).mode;\n        }\n        break;\n      case DOC_TYPE_FILL: {\n        const rem = width - pos2;\n        const {\n          parts\n        } = doc3;\n        if (parts.length === 0) {\n          break;\n        }\n        const [content, whitespace] = parts;\n        const contentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: content\n        };\n        const contentBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: content\n        };\n        const contentFits = fits(contentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (parts.length === 1) {\n          if (contentFits) {\n            cmds.push(contentFlatCmd);\n          } else {\n            cmds.push(contentBreakCmd);\n          }\n          break;\n        }\n        const whitespaceFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: whitespace\n        };\n        const whitespaceBreakCmd = {\n          ind,\n          mode: MODE_BREAK,\n          doc: whitespace\n        };\n        if (parts.length === 2) {\n          if (contentFits) {\n            cmds.push(whitespaceFlatCmd, contentFlatCmd);\n          } else {\n            cmds.push(whitespaceBreakCmd, contentBreakCmd);\n          }\n          break;\n        }\n        parts.splice(0, 2);\n        const remainingCmd = {\n          ind,\n          mode,\n          doc: fill(parts)\n        };\n        const secondContent = parts[0];\n        const firstAndSecondContentFlatCmd = {\n          ind,\n          mode: MODE_FLAT,\n          doc: [content, whitespace, secondContent]\n        };\n        const firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], rem, lineSuffix2.length > 0, groupModeMap, true);\n        if (firstAndSecondContentFits) {\n          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);\n        } else if (contentFits) {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);\n        } else {\n          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);\n        }\n        break;\n      }\n      case DOC_TYPE_IF_BREAK:\n      case DOC_TYPE_INDENT_IF_BREAK: {\n        const groupMode = doc3.groupId ? groupModeMap[doc3.groupId] : mode;\n        if (groupMode === MODE_BREAK) {\n          const breakContents = doc3.type === DOC_TYPE_IF_BREAK ? doc3.breakContents : doc3.negate ? doc3.contents : indent(doc3.contents);\n          if (breakContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: breakContents\n            });\n          }\n        }\n        if (groupMode === MODE_FLAT) {\n          const flatContents = doc3.type === DOC_TYPE_IF_BREAK ? doc3.flatContents : doc3.negate ? indent(doc3.contents) : doc3.contents;\n          if (flatContents) {\n            cmds.push({\n              ind,\n              mode,\n              doc: flatContents\n            });\n          }\n        }\n        break;\n      }\n      case DOC_TYPE_LINE_SUFFIX:\n        lineSuffix2.push({\n          ind,\n          mode,\n          doc: doc3.contents\n        });\n        break;\n      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:\n        if (lineSuffix2.length > 0) {\n          cmds.push({\n            ind,\n            mode,\n            doc: hardlineWithoutBreakParent\n          });\n        }\n        break;\n      case DOC_TYPE_LINE:\n        switch (mode) {\n          case MODE_FLAT:\n            if (!doc3.hard) {\n              if (!doc3.soft) {\n                out.push(\" \");\n                pos2 += 1;\n              }\n              break;\n            } else {\n              shouldRemeasure = true;\n            }\n          case MODE_BREAK:\n            if (lineSuffix2.length > 0) {\n              cmds.push({\n                ind,\n                mode,\n                doc: doc3\n              }, ...lineSuffix2.reverse());\n              lineSuffix2.length = 0;\n              break;\n            }\n            if (doc3.literal) {\n              if (ind.root) {\n                out.push(newLine, ind.root.value);\n                pos2 = ind.root.length;\n              } else {\n                out.push(newLine);\n                pos2 = 0;\n              }\n            } else {\n              pos2 -= trim(out);\n              out.push(newLine + ind.value);\n              pos2 = ind.length;\n            }\n            break;\n        }\n        break;\n      case DOC_TYPE_LABEL:\n        cmds.push({\n          ind,\n          mode,\n          doc: doc3.contents\n        });\n        break;\n      case DOC_TYPE_BREAK_PARENT:\n        break;\n      default:\n        throw new invalid_doc_error_default(doc3);\n    }\n    if (cmds.length === 0 && lineSuffix2.length > 0) {\n      cmds.push(...lineSuffix2.reverse());\n      lineSuffix2.length = 0;\n    }\n  }\n  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);\n  if (cursorPlaceholderIndex !== -1) {\n    const otherCursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER, cursorPlaceholderIndex + 1);\n    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");\n    const aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join(\"\");\n    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");\n    return {\n      formatted: beforeCursor + aroundCursor + afterCursor,\n      cursorNodeStart: beforeCursor.length,\n      cursorNodeText: aroundCursor\n    };\n  }\n  return {\n    formatted: out.join(\"\")\n  };\n}\n\n// src/utils/get-alignment-size.js\nfunction getAlignmentSize(text, tabWidth, startIndex = 0) {\n  let size = 0;\n  for (let i = startIndex; i < text.length; ++i) {\n    if (text[i] === \"\t\") {\n      size = size + tabWidth - size % tabWidth;\n    } else {\n      size++;\n    }\n  }\n  return size;\n}\nvar get_alignment_size_default = getAlignmentSize;\n\n// src/common/ast-path.js\nvar _getNodeStackIndex, getNodeStackIndex_fn, _getAncestors, getAncestors_fn;\nvar AstPath = class {\n  constructor(value) {\n    __privateAdd(this, _getNodeStackIndex);\n    __privateAdd(this, _getAncestors);\n    this.stack = [value];\n  }\n  /** @type {string | null} */\n  get key() {\n    const {\n      stack: stack2,\n      siblings\n    } = this;\n    return at_default(\n      /* isOptionalObject*/\n      false,\n      stack2,\n      siblings === null ? -2 : -4\n    ) ?? null;\n  }\n  /** @type {number | null} */\n  get index() {\n    return this.siblings === null ? null : at_default(\n      /* isOptionalObject*/\n      false,\n      this.stack,\n      -2\n    );\n  }\n  /** @type {object} */\n  get node() {\n    return at_default(\n      /* isOptionalObject*/\n      false,\n      this.stack,\n      -1\n    );\n  }\n  /** @type {object | null} */\n  get parent() {\n    return this.getNode(1);\n  }\n  /** @type {object | null} */\n  get grandparent() {\n    return this.getNode(2);\n  }\n  /** @type {boolean} */\n  get isInArray() {\n    return this.siblings !== null;\n  }\n  /** @type {object[] | null} */\n  get siblings() {\n    const {\n      stack: stack2\n    } = this;\n    const maybeArray = at_default(\n      /* isOptionalObject*/\n      false,\n      stack2,\n      -3\n    );\n    return Array.isArray(maybeArray) ? maybeArray : null;\n  }\n  /** @type {object | null} */\n  get next() {\n    const {\n      siblings\n    } = this;\n    return siblings === null ? null : siblings[this.index + 1];\n  }\n  /** @type {object | null} */\n  get previous() {\n    const {\n      siblings\n    } = this;\n    return siblings === null ? null : siblings[this.index - 1];\n  }\n  /** @type {boolean} */\n  get isFirst() {\n    return this.index === 0;\n  }\n  /** @type {boolean} */\n  get isLast() {\n    const {\n      siblings,\n      index\n    } = this;\n    return siblings !== null && index === siblings.length - 1;\n  }\n  /** @type {boolean} */\n  get isRoot() {\n    return this.stack.length === 1;\n  }\n  /** @type {object} */\n  get root() {\n    return this.stack[0];\n  }\n  /** @type {object[]} */\n  get ancestors() {\n    return [...__privateMethod(this, _getAncestors, getAncestors_fn).call(this)];\n  }\n  // The name of the current property is always the penultimate element of\n  // this.stack, and always a string/number/symbol.\n  getName() {\n    const {\n      stack: stack2\n    } = this;\n    const {\n      length\n    } = stack2;\n    if (length > 1) {\n      return at_default(\n        /* isOptionalObject*/\n        false,\n        stack2,\n        -2\n      );\n    }\n    return null;\n  }\n  // The value of the current property is always the final element of\n  // this.stack.\n  getValue() {\n    return at_default(\n      /* isOptionalObject*/\n      false,\n      this.stack,\n      -1\n    );\n  }\n  getNode(count = 0) {\n    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count);\n    return stackIndex === -1 ? null : this.stack[stackIndex];\n  }\n  getParentNode(count = 0) {\n    return this.getNode(count + 1);\n  }\n  // Temporarily push properties named by string arguments given after the\n  // callback function onto this.stack, then call the callback with a\n  // reference to this (modified) AstPath object. Note that the stack will\n  // be restored to its original state after the callback is finished, so it\n  // is probably a mistake to retain a reference to the path.\n  call(callback, ...names) {\n    const {\n      stack: stack2\n    } = this;\n    const {\n      length\n    } = stack2;\n    let value = at_default(\n      /* isOptionalObject*/\n      false,\n      stack2,\n      -1\n    );\n    for (const name of names) {\n      value = value[name];\n      stack2.push(name, value);\n    }\n    try {\n      return callback(this);\n    } finally {\n      stack2.length = length;\n    }\n  }\n  callParent(callback, count = 0) {\n    const stackIndex = __privateMethod(this, _getNodeStackIndex, getNodeStackIndex_fn).call(this, count + 1);\n    const parentValues = this.stack.splice(stackIndex + 1);\n    try {\n      return callback(this);\n    } finally {\n      this.stack.push(...parentValues);\n    }\n  }\n  // Similar to AstPath.prototype.call, except that the value obtained by\n  // accessing this.getValue()[name1][name2]... should be array. The\n  // callback will be called with a reference to this path object for each\n  // element of the array.\n  each(callback, ...names) {\n    const {\n      stack: stack2\n    } = this;\n    const {\n      length\n    } = stack2;\n    let value = at_default(\n      /* isOptionalObject*/\n      false,\n      stack2,\n      -1\n    );\n    for (const name of names) {\n      value = value[name];\n      stack2.push(name, value);\n    }\n    try {\n      for (let i = 0; i < value.length; ++i) {\n        stack2.push(i, value[i]);\n        callback(this, i, value);\n        stack2.length -= 2;\n      }\n    } finally {\n      stack2.length = length;\n    }\n  }\n  // Similar to AstPath.prototype.each, except that the results of the\n  // callback function invocations are stored in an array and returned at\n  // the end of the iteration.\n  map(callback, ...names) {\n    const result = [];\n    this.each((path13, index, value) => {\n      result[index] = callback(path13, index, value);\n    }, ...names);\n    return result;\n  }\n  /**\n   * @param {...(\n   *   | ((node: any, name: string | null, number: number | null) => boolean)\n   *   | undefined\n   * )} predicates\n   */\n  match(...predicates) {\n    let stackPointer = this.stack.length - 1;\n    let name = null;\n    let node = this.stack[stackPointer--];\n    for (const predicate of predicates) {\n      if (node === void 0) {\n        return false;\n      }\n      let number = null;\n      if (typeof name === \"number\") {\n        number = name;\n        name = this.stack[stackPointer--];\n        node = this.stack[stackPointer--];\n      }\n      if (predicate && !predicate(node, name, number)) {\n        return false;\n      }\n      name = this.stack[stackPointer--];\n      node = this.stack[stackPointer--];\n    }\n    return true;\n  }\n  /**\n   * Traverses the ancestors of the current node heading toward the tree root\n   * until it finds a node that matches the provided predicate function. Will\n   * return the first matching ancestor. If no such node exists, returns undefined.\n   * @param {(node: any) => boolean} predicate\n   * @internal Unstable API. Don't use in plugins for now.\n   */\n  findAncestor(predicate) {\n    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this)) {\n      if (predicate(node)) {\n        return node;\n      }\n    }\n  }\n  /**\n   * Traverses the ancestors of the current node heading toward the tree root\n   * until it finds a node that matches the provided predicate function.\n   * returns true if matched node found.\n   * @param {(node: any) => boolean} predicate\n   * @returns {boolean}\n   * @internal Unstable API. Don't use in plugins for now.\n   */\n  hasAncestor(predicate) {\n    for (const node of __privateMethod(this, _getAncestors, getAncestors_fn).call(this)) {\n      if (predicate(node)) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n_getNodeStackIndex = new WeakSet();\ngetNodeStackIndex_fn = function(count) {\n  const {\n    stack: stack2\n  } = this;\n  for (let i = stack2.length - 1; i >= 0; i -= 2) {\n    if (!Array.isArray(stack2[i]) && --count < 0) {\n      return i;\n    }\n  }\n  return -1;\n};\n_getAncestors = new WeakSet();\ngetAncestors_fn = function* () {\n  const {\n    stack: stack2\n  } = this;\n  for (let index = stack2.length - 3; index >= 0; index -= 2) {\n    const value = stack2[index];\n    if (!Array.isArray(value)) {\n      yield value;\n    }\n  }\n};\nvar ast_path_default = AstPath;\n\n// src/main/comments/attach.js\nimport assert4 from \"assert\";\n\n// src/utils/is-object.js\nfunction isObject2(object) {\n  return object !== null && typeof object === \"object\";\n}\nvar is_object_default = isObject2;\n\n// src/utils/ast-utils.js\nfunction* getChildren(node, options8) {\n  const { getVisitorKeys, filter: filter2 = () => true } = options8;\n  const isMatchedNode = (node2) => is_object_default(node2) && filter2(node2);\n  for (const key2 of getVisitorKeys(node)) {\n    const value = node[key2];\n    if (Array.isArray(value)) {\n      for (const child of value) {\n        if (isMatchedNode(child)) {\n          yield child;\n        }\n      }\n    } else if (isMatchedNode(value)) {\n      yield value;\n    }\n  }\n}\nfunction* getDescendants(node, options8) {\n  const queue = [node];\n  for (let index = 0; index < queue.length; index++) {\n    const node2 = queue[index];\n    for (const child of getChildren(node2, options8)) {\n      yield child;\n      queue.push(child);\n    }\n  }\n}\n\n// src/utils/skip.js\nfunction skip(characters) {\n  return (text, startIndex, options8) => {\n    const backwards = Boolean(options8 == null ? void 0 : options8.backwards);\n    if (startIndex === false) {\n      return false;\n    }\n    const { length } = text;\n    let cursor2 = startIndex;\n    while (cursor2 >= 0 && cursor2 < length) {\n      const character = text.charAt(cursor2);\n      if (characters instanceof RegExp) {\n        if (!characters.test(character)) {\n          return cursor2;\n        }\n      } else if (!characters.includes(character)) {\n        return cursor2;\n      }\n      backwards ? cursor2-- : cursor2++;\n    }\n    if (cursor2 === -1 || cursor2 === length) {\n      return cursor2;\n    }\n    return false;\n  };\n}\nvar skipWhitespace = skip(/\\s/);\nvar skipSpaces = skip(\" \t\");\nvar skipToLineEnd = skip(\",; \t\");\nvar skipEverythingButNewLine = skip(/[^\\n\\r]/);\n\n// src/utils/skip-newline.js\nfunction skipNewline(text, startIndex, options8) {\n  const backwards = Boolean(options8 == null ? void 0 : options8.backwards);\n  if (startIndex === false) {\n    return false;\n  }\n  const character = text.charAt(startIndex);\n  if (backwards) {\n    if (text.charAt(startIndex - 1) === \"\\r\" && character === \"\\n\") {\n      return startIndex - 2;\n    }\n    if (character === \"\\n\" || character === \"\\r\" || character === \"\\u2028\" || character === \"\\u2029\") {\n      return startIndex - 1;\n    }\n  } else {\n    if (character === \"\\r\" && text.charAt(startIndex + 1) === \"\\n\") {\n      return startIndex + 2;\n    }\n    if (character === \"\\n\" || character === \"\\r\" || character === \"\\u2028\" || character === \"\\u2029\") {\n      return startIndex + 1;\n    }\n  }\n  return startIndex;\n}\nvar skip_newline_default = skipNewline;\n\n// src/utils/has-newline.js\nfunction hasNewline(text, startIndex, options8 = {}) {\n  const idx = skipSpaces(\n    text,\n    options8.backwards ? startIndex - 1 : startIndex,\n    options8\n  );\n  const idx2 = skip_newline_default(text, idx, options8);\n  return idx !== idx2;\n}\nvar has_newline_default = hasNewline;\n\n// src/utils/is-non-empty-array.js\nfunction isNonEmptyArray(object) {\n  return Array.isArray(object) && object.length > 0;\n}\nvar is_non_empty_array_default = isNonEmptyArray;\n\n// src/main/create-get-visitor-keys-function.js\nvar nonTraversableKeys = /* @__PURE__ */ new Set([\n  \"tokens\",\n  \"comments\",\n  \"parent\",\n  \"enclosingNode\",\n  \"precedingNode\",\n  \"followingNode\"\n]);\nvar defaultGetVisitorKeys = (node) => Object.keys(node).filter((key2) => !nonTraversableKeys.has(key2));\nfunction createGetVisitorKeysFunction(printerGetVisitorKeys) {\n  return printerGetVisitorKeys ? (node) => printerGetVisitorKeys(node, nonTraversableKeys) : defaultGetVisitorKeys;\n}\nvar create_get_visitor_keys_function_default = createGetVisitorKeysFunction;\n\n// src/main/comments/utils.js\nfunction describeNodeForDebugging(node) {\n  const nodeType = node.type || node.kind || \"(unknown type)\";\n  let nodeName = String(\n    node.name || node.id && (typeof node.id === \"object\" ? node.id.name : node.id) || node.key && (typeof node.key === \"object\" ? node.key.name : node.key) || node.value && (typeof node.value === \"object\" ? \"\" : String(node.value)) || node.operator || \"\"\n  );\n  if (nodeName.length > 20) {\n    nodeName = nodeName.slice(0, 19) + \"\\u2026\";\n  }\n  return nodeType + (nodeName ? \" \" + nodeName : \"\");\n}\nfunction addCommentHelper(node, comment) {\n  const comments = node.comments ?? (node.comments = []);\n  comments.push(comment);\n  comment.printed = false;\n  comment.nodeDescription = describeNodeForDebugging(node);\n}\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment, marker) {\n  comment.leading = false;\n  comment.trailing = false;\n  if (marker) {\n    comment.marker = marker;\n  }\n  addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\n\n// src/main/comments/attach.js\nvar childNodesCache = /* @__PURE__ */ new WeakMap();\nfunction getSortedChildNodes(node, options8) {\n  if (childNodesCache.has(node)) {\n    return childNodesCache.get(node);\n  }\n  const {\n    printer: {\n      getCommentChildNodes,\n      canAttachComment,\n      getVisitorKeys: printerGetVisitorKeys\n    },\n    locStart,\n    locEnd\n  } = options8;\n  if (!canAttachComment) {\n    return [];\n  }\n  const childNodes = ((getCommentChildNodes == null ? void 0 : getCommentChildNodes(node, options8)) ?? [\n    ...getChildren(node, {\n      getVisitorKeys: create_get_visitor_keys_function_default(printerGetVisitorKeys)\n    })\n  ]).flatMap(\n    (node2) => canAttachComment(node2) ? [node2] : getSortedChildNodes(node2, options8)\n  );\n  childNodes.sort(\n    (nodeA, nodeB) => locStart(nodeA) - locStart(nodeB) || locEnd(nodeA) - locEnd(nodeB)\n  );\n  childNodesCache.set(node, childNodes);\n  return childNodes;\n}\nfunction decorateComment(node, comment, options8, enclosingNode) {\n  const { locStart, locEnd } = options8;\n  const commentStart = locStart(comment);\n  const commentEnd = locEnd(comment);\n  const childNodes = getSortedChildNodes(node, options8);\n  let precedingNode;\n  let followingNode;\n  let left = 0;\n  let right = childNodes.length;\n  while (left < right) {\n    const middle = left + right >> 1;\n    const child = childNodes[middle];\n    const start = locStart(child);\n    const end = locEnd(child);\n    if (start <= commentStart && commentEnd <= end) {\n      return decorateComment(child, comment, options8, child);\n    }\n    if (end <= commentStart) {\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n    if (commentEnd <= start) {\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n  if ((enclosingNode == null ? void 0 : enclosingNode.type) === \"TemplateLiteral\") {\n    const { quasis } = enclosingNode;\n    const commentIndex = findExpressionIndexForComment(\n      quasis,\n      comment,\n      options8\n    );\n    if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options8) !== commentIndex) {\n      precedingNode = null;\n    }\n    if (followingNode && findExpressionIndexForComment(quasis, followingNode, options8) !== commentIndex) {\n      followingNode = null;\n    }\n  }\n  return { enclosingNode, precedingNode, followingNode };\n}\nvar returnFalse = () => false;\nfunction attachComments(ast, options8) {\n  const { comments } = ast;\n  delete ast.comments;\n  if (!is_non_empty_array_default(comments) || !options8.printer.canAttachComment) {\n    return;\n  }\n  const tiesToBreak = [];\n  const {\n    locStart,\n    locEnd,\n    printer: {\n      experimentalFeatures: {\n        // TODO: Make this as default behavior\n        avoidAstMutation = false\n      } = {},\n      handleComments = {}\n    },\n    originalText: text\n  } = options8;\n  const {\n    ownLine: handleOwnLineComment = returnFalse,\n    endOfLine: handleEndOfLineComment = returnFalse,\n    remaining: handleRemainingComment = returnFalse\n  } = handleComments;\n  const decoratedComments = comments.map((comment, index) => ({\n    ...decorateComment(ast, comment, options8),\n    comment,\n    text,\n    options: options8,\n    ast,\n    isLastComment: comments.length - 1 === index\n  }));\n  for (const [index, context] of decoratedComments.entries()) {\n    const {\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode,\n      text: text2,\n      options: options9,\n      ast: ast2,\n      isLastComment\n    } = context;\n    if (options9.parser === \"json\" || options9.parser === \"json5\" || options9.parser === \"jsonc\" || options9.parser === \"__js_expression\" || options9.parser === \"__ts_expression\" || options9.parser === \"__vue_expression\" || options9.parser === \"__vue_ts_expression\") {\n      if (locStart(comment) - locStart(ast2) <= 0) {\n        addLeadingComment(ast2, comment);\n        continue;\n      }\n      if (locEnd(comment) - locEnd(ast2) >= 0) {\n        addTrailingComment(ast2, comment);\n        continue;\n      }\n    }\n    let args;\n    if (avoidAstMutation) {\n      args = [context];\n    } else {\n      comment.enclosingNode = enclosingNode;\n      comment.precedingNode = precedingNode;\n      comment.followingNode = followingNode;\n      args = [comment, text2, options9, ast2, isLastComment];\n    }\n    if (isOwnLineComment(text2, options9, decoratedComments, index)) {\n      comment.placement = \"ownLine\";\n      if (handleOwnLineComment(...args)) {\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        addDanglingComment(ast2, comment);\n      }\n    } else if (isEndOfLineComment(text2, options9, decoratedComments, index)) {\n      comment.placement = \"endOfLine\";\n      if (handleEndOfLineComment(...args)) {\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        addDanglingComment(ast2, comment);\n      }\n    } else {\n      comment.placement = \"remaining\";\n      if (handleRemainingComment(...args)) {\n      } else if (precedingNode && followingNode) {\n        const tieCount = tiesToBreak.length;\n        if (tieCount > 0) {\n          const lastTie = tiesToBreak[tieCount - 1];\n          if (lastTie.followingNode !== followingNode) {\n            breakTies(tiesToBreak, options9);\n          }\n        }\n        tiesToBreak.push(context);\n      } else if (precedingNode) {\n        addTrailingComment(precedingNode, comment);\n      } else if (followingNode) {\n        addLeadingComment(followingNode, comment);\n      } else if (enclosingNode) {\n        addDanglingComment(enclosingNode, comment);\n      } else {\n        addDanglingComment(ast2, comment);\n      }\n    }\n  }\n  breakTies(tiesToBreak, options8);\n  if (!avoidAstMutation) {\n    for (const comment of comments) {\n      delete comment.precedingNode;\n      delete comment.enclosingNode;\n      delete comment.followingNode;\n    }\n  }\n}\nvar isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);\nfunction isOwnLineComment(text, options8, decoratedComments, commentIndex) {\n  const { comment, precedingNode } = decoratedComments[commentIndex];\n  const { locStart, locEnd } = options8;\n  let start = locStart(comment);\n  if (precedingNode) {\n    for (let index = commentIndex - 1; index >= 0; index--) {\n      const { comment: comment2, precedingNode: currentCommentPrecedingNode } = decoratedComments[index];\n      if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment2), start))) {\n        break;\n      }\n      start = locStart(comment2);\n    }\n  }\n  return has_newline_default(text, start, { backwards: true });\n}\nfunction isEndOfLineComment(text, options8, decoratedComments, commentIndex) {\n  const { comment, followingNode } = decoratedComments[commentIndex];\n  const { locStart, locEnd } = options8;\n  let end = locEnd(comment);\n  if (followingNode) {\n    for (let index = commentIndex + 1; index < decoratedComments.length; index++) {\n      const { comment: comment2, followingNode: currentCommentFollowingNode } = decoratedComments[index];\n      if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment2)))) {\n        break;\n      }\n      end = locEnd(comment2);\n    }\n  }\n  return has_newline_default(text, end);\n}\nfunction breakTies(tiesToBreak, options8) {\n  var _a, _b;\n  const tieCount = tiesToBreak.length;\n  if (tieCount === 0) {\n    return;\n  }\n  const { precedingNode, followingNode } = tiesToBreak[0];\n  let gapEndPos = options8.locStart(followingNode);\n  let indexOfFirstLeadingComment;\n  for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    const {\n      comment,\n      precedingNode: currentCommentPrecedingNode,\n      followingNode: currentCommentFollowingNode\n    } = tiesToBreak[indexOfFirstLeadingComment - 1];\n    assert4.strictEqual(currentCommentPrecedingNode, precedingNode);\n    assert4.strictEqual(currentCommentFollowingNode, followingNode);\n    const gap = options8.originalText.slice(options8.locEnd(comment), gapEndPos);\n    if (((_b = (_a = options8.printer).isGap) == null ? void 0 : _b.call(_a, gap, options8)) ?? /^[\\s(]*$/.test(gap)) {\n      gapEndPos = options8.locStart(comment);\n    } else {\n      break;\n    }\n  }\n  for (const [i, { comment }] of tiesToBreak.entries()) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(precedingNode, comment);\n    } else {\n      addLeadingComment(followingNode, comment);\n    }\n  }\n  for (const node of [precedingNode, followingNode]) {\n    if (node.comments && node.comments.length > 1) {\n      node.comments.sort((a, b) => options8.locStart(a) - options8.locStart(b));\n    }\n  }\n  tiesToBreak.length = 0;\n}\nfunction findExpressionIndexForComment(quasis, comment, options8) {\n  const startPos = options8.locStart(comment) - 1;\n  for (let i = 1; i < quasis.length; ++i) {\n    if (startPos < options8.locStart(quasis[i])) {\n      return i - 1;\n    }\n  }\n  return 0;\n}\n\n// src/utils/is-previous-line-empty.js\nfunction isPreviousLineEmpty(text, startIndex) {\n  let idx = startIndex - 1;\n  idx = skipSpaces(text, idx, { backwards: true });\n  idx = skip_newline_default(text, idx, { backwards: true });\n  idx = skipSpaces(text, idx, { backwards: true });\n  const idx2 = skip_newline_default(text, idx, { backwards: true });\n  return idx !== idx2;\n}\nvar is_previous_line_empty_default = isPreviousLineEmpty;\n\n// src/main/comments/print.js\nfunction printComment(path13, options8) {\n  const comment = path13.node;\n  comment.printed = true;\n  return options8.printer.printComment(path13, options8);\n}\nfunction printLeadingComment(path13, options8) {\n  var _a;\n  const comment = path13.node;\n  const parts = [printComment(path13, options8)];\n  const { printer, originalText, locStart, locEnd } = options8;\n  const isBlock = (_a = printer.isBlockComment) == null ? void 0 : _a.call(printer, comment);\n  if (isBlock) {\n    const lineBreak = has_newline_default(originalText, locEnd(comment)) ? has_newline_default(originalText, locStart(comment), {\n      backwards: true\n    }) ? hardline : line2 : \" \";\n    parts.push(lineBreak);\n  } else {\n    parts.push(hardline);\n  }\n  const index = skip_newline_default(\n    originalText,\n    skipSpaces(originalText, locEnd(comment))\n  );\n  if (index !== false && has_newline_default(originalText, index)) {\n    parts.push(hardline);\n  }\n  return parts;\n}\nfunction printTrailingComment(path13, options8, previousComment) {\n  var _a;\n  const comment = path13.node;\n  const printed = printComment(path13, options8);\n  const { printer, originalText, locStart } = options8;\n  const isBlock = (_a = printer.isBlockComment) == null ? void 0 : _a.call(printer, comment);\n  if ((previousComment == null ? void 0 : previousComment.hasLineSuffix) && !(previousComment == null ? void 0 : previousComment.isBlock) || has_newline_default(originalText, locStart(comment), { backwards: true })) {\n    const isLineBeforeEmpty = is_previous_line_empty_default(\n      originalText,\n      locStart(comment)\n    );\n    return {\n      doc: lineSuffix([hardline, isLineBeforeEmpty ? hardline : \"\", printed]),\n      isBlock,\n      hasLineSuffix: true\n    };\n  }\n  if (!isBlock || (previousComment == null ? void 0 : previousComment.hasLineSuffix)) {\n    return {\n      doc: [lineSuffix([\" \", printed]), breakParent],\n      isBlock,\n      hasLineSuffix: true\n    };\n  }\n  return { doc: [\" \", printed], isBlock, hasLineSuffix: false };\n}\nfunction printCommentsSeparately(path13, options8) {\n  const value = path13.node;\n  if (!value) {\n    return {};\n  }\n  const ignored = options8[Symbol.for(\"printedComments\")];\n  const comments = (value.comments || []).filter(\n    (comment) => !ignored.has(comment)\n  );\n  if (comments.length === 0) {\n    return { leading: \"\", trailing: \"\" };\n  }\n  const leadingParts = [];\n  const trailingParts = [];\n  let printedTrailingComment;\n  path13.each(() => {\n    const comment = path13.node;\n    if (ignored == null ? void 0 : ignored.has(comment)) {\n      return;\n    }\n    const { leading, trailing } = comment;\n    if (leading) {\n      leadingParts.push(printLeadingComment(path13, options8));\n    } else if (trailing) {\n      printedTrailingComment = printTrailingComment(\n        path13,\n        options8,\n        printedTrailingComment\n      );\n      trailingParts.push(printedTrailingComment.doc);\n    }\n  }, \"comments\");\n  return { leading: leadingParts, trailing: trailingParts };\n}\nfunction printComments(path13, doc2, options8) {\n  const { leading, trailing } = printCommentsSeparately(path13, options8);\n  if (!leading && !trailing) {\n    return doc2;\n  }\n  return inheritLabel(doc2, (doc3) => [leading, doc3, trailing]);\n}\nfunction ensureAllCommentsPrinted(options8) {\n  const {\n    [Symbol.for(\"comments\")]: comments,\n    [Symbol.for(\"printedComments\")]: printedComments\n  } = options8;\n  for (const comment of comments) {\n    if (!comment.printed && !printedComments.has(comment)) {\n      throw new Error(\n        'Comment \"' + comment.value.trim() + '\" was not printed. Please report this error!'\n      );\n    }\n    delete comment.printed;\n  }\n}\n\n// src/main/create-print-pre-check-function.js\nfunction createPrintPreCheckFunction(options8) {\n  if (true) {\n    return () => {\n    };\n  }\n  const getVisitorKeys = create_get_visitor_keys_function_default(\n    options8.printer.getVisitorKeys\n  );\n  return function(path13) {\n    if (path13.isRoot) {\n      return;\n    }\n    const { key: key2, parent } = path13;\n    const visitorKeys = getVisitorKeys(parent);\n    if (visitorKeys.includes(key2)) {\n      return;\n    }\n    throw Object.assign(new Error(\"Calling `print()` on non-node object.\"), {\n      parentNode: parent,\n      allowedProperties: visitorKeys,\n      printingProperty: key2,\n      printingValue: path13.node,\n      pathStack: path13.stack.length > 5 ? [\"...\", ...path13.stack.slice(-5)] : [...path13.stack]\n    });\n  };\n}\nvar create_print_pre_check_function_default = createPrintPreCheckFunction;\n\n// src/main/core-options.evaluate.js\nvar core_options_evaluate_default = {\n  \"cursorOffset\": {\n    \"category\": \"Special\",\n    \"type\": \"int\",\n    \"default\": -1,\n    \"range\": {\n      \"start\": -1,\n      \"end\": Infinity,\n      \"step\": 1\n    },\n    \"description\": \"Print (to stderr) where a cursor at the given position would move to after formatting.\",\n    \"cliCategory\": \"Editor\"\n  },\n  \"endOfLine\": {\n    \"category\": \"Global\",\n    \"type\": \"choice\",\n    \"default\": \"lf\",\n    \"description\": \"Which end of line characters to apply.\",\n    \"choices\": [\n      {\n        \"value\": \"lf\",\n        \"description\": \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\"\n      },\n      {\n        \"value\": \"crlf\",\n        \"description\": \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\"\n      },\n      {\n        \"value\": \"cr\",\n        \"description\": \"Carriage Return character only (\\\\r), used very rarely\"\n      },\n      {\n        \"value\": \"auto\",\n        \"description\": \"Maintain existing\\n(mixed values within one file are normalised by looking at what's used after the first line)\"\n      }\n    ]\n  },\n  \"filepath\": {\n    \"category\": \"Special\",\n    \"type\": \"path\",\n    \"description\": \"Specify the input filepath. This will be used to do parser inference.\",\n    \"cliName\": \"stdin-filepath\",\n    \"cliCategory\": \"Other\",\n    \"cliDescription\": \"Path to the file to pretend that stdin comes from.\"\n  },\n  \"insertPragma\": {\n    \"category\": \"Special\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Insert @format pragma into file's first docblock comment.\",\n    \"cliCategory\": \"Other\"\n  },\n  \"parser\": {\n    \"category\": \"Global\",\n    \"type\": \"choice\",\n    \"default\": void 0,\n    \"description\": \"Which parser to use.\",\n    \"exception\": (value) => typeof value === \"string\" || typeof value === \"function\",\n    \"choices\": [\n      {\n        \"value\": \"flow\",\n        \"description\": \"Flow\"\n      },\n      {\n        \"value\": \"babel\",\n        \"description\": \"JavaScript\"\n      },\n      {\n        \"value\": \"babel-flow\",\n        \"description\": \"Flow\"\n      },\n      {\n        \"value\": \"babel-ts\",\n        \"description\": \"TypeScript\"\n      },\n      {\n        \"value\": \"typescript\",\n        \"description\": \"TypeScript\"\n      },\n      {\n        \"value\": \"acorn\",\n        \"description\": \"JavaScript\"\n      },\n      {\n        \"value\": \"espree\",\n        \"description\": \"JavaScript\"\n      },\n      {\n        \"value\": \"meriyah\",\n        \"description\": \"JavaScript\"\n      },\n      {\n        \"value\": \"css\",\n        \"description\": \"CSS\"\n      },\n      {\n        \"value\": \"less\",\n        \"description\": \"Less\"\n      },\n      {\n        \"value\": \"scss\",\n        \"description\": \"SCSS\"\n      },\n      {\n        \"value\": \"json\",\n        \"description\": \"JSON\"\n      },\n      {\n        \"value\": \"json5\",\n        \"description\": \"JSON5\"\n      },\n      {\n        \"value\": \"jsonc\",\n        \"description\": \"JSON with Comments\"\n      },\n      {\n        \"value\": \"json-stringify\",\n        \"description\": \"JSON.stringify\"\n      },\n      {\n        \"value\": \"graphql\",\n        \"description\": \"GraphQL\"\n      },\n      {\n        \"value\": \"markdown\",\n        \"description\": \"Markdown\"\n      },\n      {\n        \"value\": \"mdx\",\n        \"description\": \"MDX\"\n      },\n      {\n        \"value\": \"vue\",\n        \"description\": \"Vue\"\n      },\n      {\n        \"value\": \"yaml\",\n        \"description\": \"YAML\"\n      },\n      {\n        \"value\": \"glimmer\",\n        \"description\": \"Ember / Handlebars\"\n      },\n      {\n        \"value\": \"html\",\n        \"description\": \"HTML\"\n      },\n      {\n        \"value\": \"angular\",\n        \"description\": \"Angular\"\n      },\n      {\n        \"value\": \"lwc\",\n        \"description\": \"Lightning Web Components\"\n      }\n    ]\n  },\n  \"plugins\": {\n    \"type\": \"path\",\n    \"array\": true,\n    \"default\": [\n      {\n        \"value\": []\n      }\n    ],\n    \"category\": \"Global\",\n    \"description\": \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",\n    \"exception\": (value) => typeof value === \"string\" || typeof value === \"object\",\n    \"cliName\": \"plugin\",\n    \"cliCategory\": \"Config\"\n  },\n  \"printWidth\": {\n    \"category\": \"Global\",\n    \"type\": \"int\",\n    \"default\": 80,\n    \"description\": \"The line length where Prettier will try wrap.\",\n    \"range\": {\n      \"start\": 0,\n      \"end\": Infinity,\n      \"step\": 1\n    }\n  },\n  \"rangeEnd\": {\n    \"category\": \"Special\",\n    \"type\": \"int\",\n    \"default\": Infinity,\n    \"range\": {\n      \"start\": 0,\n      \"end\": Infinity,\n      \"step\": 1\n    },\n    \"description\": \"Format code ending at a given character offset (exclusive).\\nThe range will extend forwards to the end of the selected statement.\",\n    \"cliCategory\": \"Editor\"\n  },\n  \"rangeStart\": {\n    \"category\": \"Special\",\n    \"type\": \"int\",\n    \"default\": 0,\n    \"range\": {\n      \"start\": 0,\n      \"end\": Infinity,\n      \"step\": 1\n    },\n    \"description\": \"Format code starting at a given character offset.\\nThe range will extend backwards to the start of the first line containing the selected statement.\",\n    \"cliCategory\": \"Editor\"\n  },\n  \"requirePragma\": {\n    \"category\": \"Special\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Require either '@prettier' or '@format' to be present in the file's first docblock comment\\nin order for it to be formatted.\",\n    \"cliCategory\": \"Other\"\n  },\n  \"tabWidth\": {\n    \"type\": \"int\",\n    \"category\": \"Global\",\n    \"default\": 2,\n    \"description\": \"Number of spaces per indentation level.\",\n    \"range\": {\n      \"start\": 0,\n      \"end\": Infinity,\n      \"step\": 1\n    }\n  },\n  \"useTabs\": {\n    \"category\": \"Global\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Indent with tabs instead of spaces.\"\n  },\n  \"embeddedLanguageFormatting\": {\n    \"category\": \"Global\",\n    \"type\": \"choice\",\n    \"default\": \"auto\",\n    \"description\": \"Control how Prettier formats quoted code embedded in the file.\",\n    \"choices\": [\n      {\n        \"value\": \"auto\",\n        \"description\": \"Format embedded code if Prettier can automatically identify it.\"\n      },\n      {\n        \"value\": \"off\",\n        \"description\": \"Never automatically format embedded code.\"\n      }\n    ]\n  }\n};\n\n// src/main/support.js\nfunction getSupportInfo({\n  plugins = [],\n  showDeprecated = false\n} = {}) {\n  const languages2 = plugins.flatMap((plugin) => plugin.languages ?? []);\n  const options8 = [];\n  for (const option of normalizeOptionSettings(Object.assign({}, ...plugins.map(({\n    options: options9\n  }) => options9), core_options_evaluate_default))) {\n    if (!showDeprecated && option.deprecated) {\n      continue;\n    }\n    if (Array.isArray(option.choices)) {\n      if (!showDeprecated) {\n        option.choices = option.choices.filter((choice) => !choice.deprecated);\n      }\n      if (option.name === \"parser\") {\n        option.choices = [...option.choices, ...collectParsersFromLanguages(option.choices, languages2, plugins)];\n      }\n    }\n    option.pluginDefaults = Object.fromEntries(plugins.filter((plugin) => {\n      var _a;\n      return ((_a = plugin.defaultOptions) == null ? void 0 : _a[option.name]) !== void 0;\n    }).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]]));\n    options8.push(option);\n  }\n  return {\n    languages: languages2,\n    options: options8\n  };\n}\nfunction* collectParsersFromLanguages(parserChoices, languages2, plugins) {\n  const existingParsers = new Set(parserChoices.map((choice) => choice.value));\n  for (const language of languages2) {\n    if (language.parsers) {\n      for (const parserName of language.parsers) {\n        if (!existingParsers.has(parserName)) {\n          existingParsers.add(parserName);\n          const plugin = plugins.find((plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName));\n          let description = language.name;\n          if (plugin == null ? void 0 : plugin.name) {\n            description += ` (plugin: ${plugin.name})`;\n          }\n          yield {\n            value: parserName,\n            description\n          };\n        }\n      }\n    }\n  }\n}\nfunction normalizeOptionSettings(settings) {\n  const options8 = [];\n  for (const [name, originalOption] of Object.entries(settings)) {\n    const option = {\n      name,\n      ...originalOption\n    };\n    if (Array.isArray(option.default)) {\n      option.default = at_default(\n        /* isOptionalObject*/\n        false,\n        option.default,\n        -1\n      ).value;\n    }\n    options8.push(option);\n  }\n  return options8;\n}\n\n// src/main/normalize-options.js\nvar hasDeprecationWarned;\nfunction normalizeOptions(options8, optionInfos, {\n  logger = false,\n  isCLI = false,\n  passThrough = false,\n  FlagSchema,\n  descriptor\n} = {}) {\n  if (isCLI) {\n    if (!FlagSchema) {\n      throw new Error(\"'FlagSchema' option is required.\");\n    }\n    if (!descriptor) {\n      throw new Error(\"'descriptor' option is required.\");\n    }\n  } else {\n    descriptor = apiDescriptor;\n  }\n  const unknown = !passThrough ? (key2, value, options9) => {\n    const {\n      _,\n      ...schemas2\n    } = options9.schemas;\n    return levenUnknownHandler(key2, value, {\n      ...options9,\n      schemas: schemas2\n    });\n  } : Array.isArray(passThrough) ? (key2, value) => !passThrough.includes(key2) ? void 0 : {\n    [key2]: value\n  } : (key2, value) => ({\n    [key2]: value\n  });\n  const schemas = optionInfosToSchemas(optionInfos, {\n    isCLI,\n    FlagSchema\n  });\n  const normalizer = new Normalizer(schemas, {\n    logger,\n    unknown,\n    descriptor\n  });\n  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;\n  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {\n    normalizer._hasDeprecationWarned = hasDeprecationWarned;\n  }\n  const normalized = normalizer.normalize(options8);\n  if (shouldSuppressDuplicateDeprecationWarnings) {\n    hasDeprecationWarned = normalizer._hasDeprecationWarned;\n  }\n  return normalized;\n}\nfunction optionInfosToSchemas(optionInfos, {\n  isCLI,\n  FlagSchema\n}) {\n  const schemas = [];\n  if (isCLI) {\n    schemas.push(AnySchema.create({\n      name: \"_\"\n    }));\n  }\n  for (const optionInfo of optionInfos) {\n    schemas.push(optionInfoToSchema(optionInfo, {\n      isCLI,\n      optionInfos,\n      FlagSchema\n    }));\n    if (optionInfo.alias && isCLI) {\n      schemas.push(AliasSchema.create({\n        // @ts-expect-error\n        name: optionInfo.alias,\n        sourceName: optionInfo.name\n      }));\n    }\n  }\n  return schemas;\n}\nfunction optionInfoToSchema(optionInfo, {\n  isCLI,\n  optionInfos,\n  FlagSchema\n}) {\n  const {\n    name\n  } = optionInfo;\n  const parameters = {\n    name\n  };\n  let SchemaConstructor;\n  const handlers = {};\n  switch (optionInfo.type) {\n    case \"int\":\n      SchemaConstructor = IntegerSchema;\n      if (isCLI) {\n        parameters.preprocess = Number;\n      }\n      break;\n    case \"string\":\n      SchemaConstructor = StringSchema;\n      break;\n    case \"choice\":\n      SchemaConstructor = ChoiceSchema;\n      parameters.choices = optionInfo.choices.map((choiceInfo) => (choiceInfo == null ? void 0 : choiceInfo.redirect) ? {\n        ...choiceInfo,\n        redirect: {\n          to: {\n            key: optionInfo.name,\n            value: choiceInfo.redirect\n          }\n        }\n      } : choiceInfo);\n      break;\n    case \"boolean\":\n      SchemaConstructor = BooleanSchema;\n      break;\n    case \"flag\":\n      SchemaConstructor = FlagSchema;\n      parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));\n      break;\n    case \"path\":\n      SchemaConstructor = StringSchema;\n      break;\n    default:\n      throw new Error(`Unexpected type ${optionInfo.type}`);\n  }\n  if (optionInfo.exception) {\n    parameters.validate = (value, schema2, utils) => optionInfo.exception(value) || schema2.validate(value, utils);\n  } else {\n    parameters.validate = (value, schema2, utils) => value === void 0 || schema2.validate(value, utils);\n  }\n  if (optionInfo.redirect) {\n    handlers.redirect = (value) => !value ? void 0 : {\n      to: {\n        key: optionInfo.redirect.option,\n        value: optionInfo.redirect.value\n      }\n    };\n  }\n  if (optionInfo.deprecated) {\n    handlers.deprecated = true;\n  }\n  if (isCLI && !optionInfo.array) {\n    const originalPreprocess = parameters.preprocess || ((x) => x);\n    parameters.preprocess = (value, schema2, utils) => schema2.preprocess(originalPreprocess(Array.isArray(value) ? at_default(\n      /* isOptionalObject*/\n      false,\n      value,\n      -1\n    ) : value), utils);\n  }\n  return optionInfo.array ? ArraySchema.create({\n    ...isCLI ? {\n      preprocess: (v) => Array.isArray(v) ? v : [v]\n    } : {},\n    ...handlers,\n    // @ts-expect-error\n    valueSchema: SchemaConstructor.create(parameters)\n  }) : SchemaConstructor.create({\n    ...parameters,\n    ...handlers\n  });\n}\nvar normalize_options_default = normalizeOptions;\n\n// scripts/build/shims/array-find-last.js\nvar arrayFindLast = (isOptionalObject, array2, callback) => {\n  if (isOptionalObject && (array2 === void 0 || array2 === null)) {\n    return;\n  }\n  if (array2.findLast) {\n    return array2.findLast(callback);\n  }\n  for (let index = array2.length - 1; index >= 0; index--) {\n    const element = array2[index];\n    if (callback(element, index, array2)) {\n      return element;\n    }\n  }\n};\nvar array_find_last_default = arrayFindLast;\n\n// src/main/parser-and-printer.js\nfunction getParserPluginByParserName(plugins, parserName) {\n  if (!parserName) {\n    throw new Error(\"parserName is required.\");\n  }\n  const plugin = array_find_last_default(\n    /* isOptionalObject*/\n    false,\n    plugins,\n    (plugin2) => plugin2.parsers && Object.prototype.hasOwnProperty.call(plugin2.parsers, parserName)\n  );\n  if (plugin) {\n    return plugin;\n  }\n  let message = `Couldn't resolve parser \"${parserName}\".`;\n  if (false) {\n    message += \" Plugins must be explicitly added to the standalone bundle.\";\n  }\n  throw new ConfigError(message);\n}\nfunction getPrinterPluginByAstFormat(plugins, astFormat) {\n  if (!astFormat) {\n    throw new Error(\"astFormat is required.\");\n  }\n  const plugin = array_find_last_default(\n    /* isOptionalObject*/\n    false,\n    plugins,\n    (plugin2) => plugin2.printers && Object.prototype.hasOwnProperty.call(plugin2.printers, astFormat)\n  );\n  if (plugin) {\n    return plugin;\n  }\n  let message = `Couldn't find plugin for AST format \"${astFormat}\".`;\n  if (false) {\n    message += \" Plugins must be explicitly added to the standalone bundle.\";\n  }\n  throw new ConfigError(message);\n}\nfunction resolveParser({\n  plugins,\n  parser\n}) {\n  const plugin = getParserPluginByParserName(plugins, parser);\n  return initParser(plugin, parser);\n}\nfunction initParser(plugin, parserName) {\n  const parserOrParserInitFunction = plugin.parsers[parserName];\n  return typeof parserOrParserInitFunction === \"function\" ? parserOrParserInitFunction() : parserOrParserInitFunction;\n}\nfunction initPrinter(plugin, astFormat) {\n  const printerOrPrinterInitFunction = plugin.printers[astFormat];\n  return typeof printerOrPrinterInitFunction === \"function\" ? printerOrPrinterInitFunction() : printerOrPrinterInitFunction;\n}\n\n// src/main/normalize-format-options.js\nvar formatOptionsHiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: void 0,\n  locStart: null,\n  locEnd: null\n};\nasync function normalizeFormatOptions(options8, opts = {}) {\n  var _a;\n  const rawOptions = { ...options8 };\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      throw new UndefinedParserError(\n        \"No parser and no file path given, couldn't infer a parser.\"\n      );\n    } else {\n      rawOptions.parser = infer_parser_default(rawOptions, {\n        physicalFile: rawOptions.filepath\n      });\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\n          `No parser could be inferred for file \"${rawOptions.filepath}\".`\n        );\n      }\n    }\n  }\n  const supportOptions = getSupportInfo({\n    plugins: options8.plugins,\n    showDeprecated: true\n  }).options;\n  const defaults = {\n    ...formatOptionsHiddenDefaults,\n    ...Object.fromEntries(\n      supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])\n    )\n  };\n  const parserPlugin = getParserPluginByParserName(\n    rawOptions.plugins,\n    rawOptions.parser\n  );\n  const parser = await initParser(parserPlugin, rawOptions.parser);\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n  const printerPlugin = ((_a = parserPlugin.printers) == null ? void 0 : _a[parser.astFormat]) ? parserPlugin : getPrinterPluginByAstFormat(rawOptions.plugins, parser.astFormat);\n  const printer = await initPrinter(printerPlugin, parser.astFormat);\n  rawOptions.printer = printer;\n  const pluginDefaults = printerPlugin.defaultOptions ? Object.fromEntries(\n    Object.entries(printerPlugin.defaultOptions).filter(\n      ([, value]) => value !== void 0\n    )\n  ) : {};\n  const mixedDefaults = { ...defaults, ...pluginDefaults };\n  for (const [k, value] of Object.entries(mixedDefaults)) {\n    if (rawOptions[k] === null || rawOptions[k] === void 0) {\n      rawOptions[k] = value;\n    }\n  }\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n  return normalize_options_default(rawOptions, supportOptions, {\n    passThrough: Object.keys(formatOptionsHiddenDefaults),\n    ...opts\n  });\n}\nvar normalize_format_options_default = normalizeFormatOptions;\n\n// src/main/parse.js\nvar import_code_frame2 = __toESM(require_lib3(), 1);\nasync function parse4(originalText, options8) {\n  const parser = await resolveParser(options8);\n  const text = parser.preprocess ? parser.preprocess(originalText, options8) : originalText;\n  options8.originalText = text;\n  let ast;\n  try {\n    ast = await parser.parse(\n      text,\n      options8,\n      // TODO: remove the third argument in v4\n      // The duplicated argument is passed as intended, see #10156\n      options8\n    );\n  } catch (error) {\n    handleParseError(error, originalText);\n  }\n  return { text, ast };\n}\nfunction handleParseError(error, text) {\n  const { loc } = error;\n  if (loc) {\n    const codeFrame = (0, import_code_frame2.codeFrameColumns)(text, loc, { highlightCode: true });\n    error.message += \"\\n\" + codeFrame;\n    error.codeFrame = codeFrame;\n    throw error;\n  }\n  throw error;\n}\nvar parse_default = parse4;\n\n// src/main/multiparser.js\nasync function printEmbeddedLanguages(path13, genericPrint, options8, printAstToDoc2, embeds) {\n  const {\n    embeddedLanguageFormatting,\n    printer: {\n      embed,\n      hasPrettierIgnore = () => false,\n      getVisitorKeys: printerGetVisitorKeys\n    }\n  } = options8;\n  if (!embed || embeddedLanguageFormatting !== \"auto\") {\n    return;\n  }\n  if (embed.length > 2) {\n    throw new Error(\n      \"printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed\"\n    );\n  }\n  const getVisitorKeys = create_get_visitor_keys_function_default(\n    embed.getVisitorKeys ?? printerGetVisitorKeys\n  );\n  const embedCallResults = [];\n  recurse();\n  const originalPathStack = path13.stack;\n  for (const { print, node, pathStack } of embedCallResults) {\n    try {\n      path13.stack = pathStack;\n      const doc2 = await print(textToDocForEmbed, genericPrint, path13, options8);\n      if (doc2) {\n        embeds.set(node, doc2);\n      }\n    } catch (error) {\n      if (process.env.PRETTIER_DEBUG) {\n        throw error;\n      }\n    }\n  }\n  path13.stack = originalPathStack;\n  function textToDocForEmbed(text, partialNextOptions) {\n    return textToDoc(text, partialNextOptions, options8, printAstToDoc2);\n  }\n  function recurse() {\n    const { node } = path13;\n    if (node === null || typeof node !== \"object\" || hasPrettierIgnore(path13)) {\n      return;\n    }\n    for (const key2 of getVisitorKeys(node)) {\n      if (Array.isArray(node[key2])) {\n        path13.each(recurse, key2);\n      } else {\n        path13.call(recurse, key2);\n      }\n    }\n    const result = embed(path13, options8);\n    if (!result) {\n      return;\n    }\n    if (typeof result === \"function\") {\n      embedCallResults.push({\n        print: result,\n        node,\n        pathStack: [...path13.stack]\n      });\n      return;\n    }\n    if (false) {\n      throw new Error(\n        \"`embed` should return an async function instead of Promise.\"\n      );\n    }\n    embeds.set(node, result);\n  }\n}\nasync function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc2) {\n  const options8 = await normalize_format_options_default(\n    {\n      ...parentOptions,\n      ...partialNextOptions,\n      parentParser: parentOptions.parser,\n      originalText: text\n    },\n    { passThrough: true }\n  );\n  const { ast } = await parse_default(text, options8);\n  const doc2 = await printAstToDoc2(ast, options8);\n  return stripTrailingHardline(doc2);\n}\n\n// src/main/print-ignored.js\nfunction printIgnored(path13, options8) {\n  const {\n    originalText,\n    [Symbol.for(\"comments\")]: comments,\n    locStart,\n    locEnd,\n    [Symbol.for(\"printedComments\")]: printedComments\n  } = options8;\n  const { node } = path13;\n  const start = locStart(node);\n  const end = locEnd(node);\n  for (const comment of comments) {\n    if (locStart(comment) >= start && locEnd(comment) <= end) {\n      printedComments.add(comment);\n    }\n  }\n  return originalText.slice(start, end);\n}\nvar print_ignored_default = printIgnored;\n\n// src/main/ast-to-doc.js\nasync function printAstToDoc(ast, options8) {\n  ({ ast } = await prepareToPrint(ast, options8));\n  const cache3 = /* @__PURE__ */ new Map();\n  const path13 = new ast_path_default(ast);\n  const ensurePrintingNode = create_print_pre_check_function_default(options8);\n  const embeds = /* @__PURE__ */ new Map();\n  await printEmbeddedLanguages(path13, mainPrint, options8, printAstToDoc, embeds);\n  const doc2 = await callPluginPrintFunction(\n    path13,\n    options8,\n    mainPrint,\n    void 0,\n    embeds\n  );\n  ensureAllCommentsPrinted(options8);\n  return doc2;\n  function mainPrint(selector, args) {\n    if (selector === void 0 || selector === path13) {\n      return mainPrintInternal(args);\n    }\n    if (Array.isArray(selector)) {\n      return path13.call(() => mainPrintInternal(args), ...selector);\n    }\n    return path13.call(() => mainPrintInternal(args), selector);\n  }\n  function mainPrintInternal(args) {\n    ensurePrintingNode(path13);\n    const value = path13.node;\n    if (value === void 0 || value === null) {\n      return \"\";\n    }\n    const shouldCache = value && typeof value === \"object\" && args === void 0;\n    if (shouldCache && cache3.has(value)) {\n      return cache3.get(value);\n    }\n    const doc3 = callPluginPrintFunction(path13, options8, mainPrint, args, embeds);\n    if (shouldCache) {\n      cache3.set(value, doc3);\n    }\n    return doc3;\n  }\n}\nfunction callPluginPrintFunction(path13, options8, printPath, args, embeds) {\n  var _a;\n  const { node } = path13;\n  const { printer } = options8;\n  let doc2;\n  if ((_a = printer.hasPrettierIgnore) == null ? void 0 : _a.call(printer, path13)) {\n    doc2 = print_ignored_default(path13, options8);\n  } else if (embeds.has(node)) {\n    doc2 = embeds.get(node);\n  } else {\n    doc2 = printer.print(path13, options8, printPath, args);\n  }\n  if (node === options8.cursorNode) {\n    doc2 = inheritLabel(doc2, (doc3) => [cursor, doc3, cursor]);\n  }\n  if (printer.printComment && (!printer.willPrintOwnComments || !printer.willPrintOwnComments(path13, options8))) {\n    doc2 = printComments(path13, doc2, options8);\n  }\n  return doc2;\n}\nasync function prepareToPrint(ast, options8) {\n  const comments = ast.comments ?? [];\n  options8[Symbol.for(\"comments\")] = comments;\n  options8[Symbol.for(\"tokens\")] = ast.tokens ?? [];\n  options8[Symbol.for(\"printedComments\")] = /* @__PURE__ */ new Set();\n  attachComments(ast, options8);\n  const {\n    printer: { preprocess }\n  } = options8;\n  ast = preprocess ? await preprocess(ast, options8) : ast;\n  return { ast, comments };\n}\n\n// src/main/get-cursor-node.js\nfunction getCursorNode(ast, options8) {\n  const { cursorOffset, locStart, locEnd } = options8;\n  const getVisitorKeys = create_get_visitor_keys_function_default(\n    options8.printer.getVisitorKeys\n  );\n  const nodeContainsCursor = (node) => locStart(node) <= cursorOffset && locEnd(node) >= cursorOffset;\n  let cursorNode = ast;\n  for (const node of getDescendants(ast, {\n    getVisitorKeys,\n    filter: nodeContainsCursor\n  })) {\n    cursorNode = node;\n  }\n  return cursorNode;\n}\nvar get_cursor_node_default = getCursorNode;\n\n// src/main/massage-ast.js\nfunction massageAst(ast, options8) {\n  const {\n    printer: {\n      massageAstNode: cleanFunction,\n      getVisitorKeys: printerGetVisitorKeys\n    }\n  } = options8;\n  if (!cleanFunction) {\n    return ast;\n  }\n  const getVisitorKeys = create_get_visitor_keys_function_default(printerGetVisitorKeys);\n  const ignoredProperties = cleanFunction.ignoredProperties ?? /* @__PURE__ */ new Set();\n  return recurse(ast);\n  function recurse(node, parent) {\n    if (!(node !== null && typeof node === \"object\")) {\n      return node;\n    }\n    if (Array.isArray(node)) {\n      return node.map((child) => recurse(child, parent)).filter(Boolean);\n    }\n    const newObj = {};\n    const childrenKeys = new Set(getVisitorKeys(node));\n    for (const key2 in node) {\n      if (!Object.prototype.hasOwnProperty.call(node, key2) || ignoredProperties.has(key2)) {\n        continue;\n      }\n      if (childrenKeys.has(key2)) {\n        newObj[key2] = recurse(node[key2], node);\n      } else {\n        newObj[key2] = node[key2];\n      }\n    }\n    const result = cleanFunction(node, newObj, parent);\n    if (result === null) {\n      return;\n    }\n    return result ?? newObj;\n  }\n}\nvar massage_ast_default = massageAst;\n\n// src/main/range-util.js\nimport assert5 from \"assert\";\nvar isJsonParser = ({ parser }) => parser === \"json\" || parser === \"json5\" || parser === \"jsonc\" || parser === \"json-stringify\";\nfunction findCommonAncestor(startNodeAndParents, endNodeAndParents) {\n  const startNodeAndAncestors = [\n    startNodeAndParents.node,\n    ...startNodeAndParents.parentNodes\n  ];\n  const endNodeAndAncestors = /* @__PURE__ */ new Set([\n    endNodeAndParents.node,\n    ...endNodeAndParents.parentNodes\n  ]);\n  return startNodeAndAncestors.find(\n    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)\n  );\n}\nfunction dropRootParents(parents) {\n  let lastParentIndex = parents.length - 1;\n  for (; ; ) {\n    const parent = parents[lastParentIndex];\n    if ((parent == null ? void 0 : parent.type) === \"Program\" || (parent == null ? void 0 : parent.type) === \"File\") {\n      lastParentIndex--;\n    } else {\n      break;\n    }\n  }\n  return parents.slice(0, lastParentIndex + 1);\n}\nfunction findSiblingAncestors(startNodeAndParents, endNodeAndParents, { locStart, locEnd }) {\n  let resultStartNode = startNodeAndParents.node;\n  let resultEndNode = endNodeAndParents.node;\n  if (resultStartNode === resultEndNode) {\n    return {\n      startNode: resultStartNode,\n      endNode: resultEndNode\n    };\n  }\n  const startNodeStart = locStart(startNodeAndParents.node);\n  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {\n    if (locStart(endParent) >= startNodeStart) {\n      resultEndNode = endParent;\n    } else {\n      break;\n    }\n  }\n  const endNodeEnd = locEnd(endNodeAndParents.node);\n  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {\n    if (locEnd(startParent) <= endNodeEnd) {\n      resultStartNode = startParent;\n    } else {\n      break;\n    }\n    if (resultStartNode === resultEndNode) {\n      break;\n    }\n  }\n  return {\n    startNode: resultStartNode,\n    endNode: resultEndNode\n  };\n}\nfunction findNodeAtOffset(node, offset, options8, predicate, parentNodes = [], type2) {\n  const { locStart, locEnd } = options8;\n  const start = locStart(node);\n  const end = locEnd(node);\n  if (offset > end || offset < start || type2 === \"rangeEnd\" && offset === start || type2 === \"rangeStart\" && offset === end) {\n    return;\n  }\n  for (const childNode of getSortedChildNodes(node, options8)) {\n    const childResult = findNodeAtOffset(\n      childNode,\n      offset,\n      options8,\n      predicate,\n      [node, ...parentNodes],\n      type2\n    );\n    if (childResult) {\n      return childResult;\n    }\n  }\n  if (!predicate || predicate(node, parentNodes[0])) {\n    return {\n      node,\n      parentNodes\n    };\n  }\n}\nfunction isJsSourceElement(type2, parentType) {\n  return parentType !== \"DeclareExportDeclaration\" && type2 !== \"TypeParameterDeclaration\" && (type2 === \"Directive\" || type2 === \"TypeAlias\" || type2 === \"TSExportAssignment\" || type2.startsWith(\"Declare\") || type2.startsWith(\"TSDeclare\") || type2.endsWith(\"Statement\") || type2.endsWith(\"Declaration\"));\n}\nvar jsonSourceElements = /* @__PURE__ */ new Set([\n  \"JsonRoot\",\n  \"ObjectExpression\",\n  \"ArrayExpression\",\n  \"StringLiteral\",\n  \"NumericLiteral\",\n  \"BooleanLiteral\",\n  \"NullLiteral\",\n  \"UnaryExpression\",\n  \"TemplateLiteral\"\n]);\nvar graphqlSourceElements = /* @__PURE__ */ new Set([\n  \"OperationDefinition\",\n  \"FragmentDefinition\",\n  \"VariableDefinition\",\n  \"TypeExtensionDefinition\",\n  \"ObjectTypeDefinition\",\n  \"FieldDefinition\",\n  \"DirectiveDefinition\",\n  \"EnumTypeDefinition\",\n  \"EnumValueDefinition\",\n  \"InputValueDefinition\",\n  \"InputObjectTypeDefinition\",\n  \"SchemaDefinition\",\n  \"OperationTypeDefinition\",\n  \"InterfaceTypeDefinition\",\n  \"UnionTypeDefinition\",\n  \"ScalarTypeDefinition\"\n]);\nfunction isSourceElement(opts, node, parentNode) {\n  if (!node) {\n    return false;\n  }\n  switch (opts.parser) {\n    case \"flow\":\n    case \"babel\":\n    case \"babel-flow\":\n    case \"babel-ts\":\n    case \"typescript\":\n    case \"acorn\":\n    case \"espree\":\n    case \"meriyah\":\n    case \"__babel_estree\":\n      return isJsSourceElement(node.type, parentNode == null ? void 0 : parentNode.type);\n    case \"json\":\n    case \"json5\":\n    case \"jsonc\":\n    case \"json-stringify\":\n      return jsonSourceElements.has(node.type);\n    case \"graphql\":\n      return graphqlSourceElements.has(node.kind);\n    case \"vue\":\n      return node.tag !== \"root\";\n  }\n  return false;\n}\nfunction calculateRange(text, opts, ast) {\n  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;\n  assert5.ok(end > start);\n  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);\n  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;\n  if (!isAllWhitespace) {\n    start += firstNonWhitespaceCharacterIndex;\n    for (; end > start; --end) {\n      if (/\\S/.test(text[end - 1])) {\n        break;\n      }\n    }\n  }\n  const startNodeAndParents = findNodeAtOffset(\n    ast,\n    start,\n    opts,\n    (node, parentNode) => isSourceElement(opts, node, parentNode),\n    [],\n    \"rangeStart\"\n  );\n  const endNodeAndParents = (\n    // No need find Node at `end`, it will be the same as `startNodeAndParents`\n    isAllWhitespace ? startNodeAndParents : findNodeAtOffset(\n      ast,\n      end,\n      opts,\n      (node) => isSourceElement(opts, node),\n      [],\n      \"rangeEnd\"\n    )\n  );\n  if (!startNodeAndParents || !endNodeAndParents) {\n    return {\n      rangeStart: 0,\n      rangeEnd: 0\n    };\n  }\n  let startNode;\n  let endNode;\n  if (isJsonParser(opts)) {\n    const commonAncestor = findCommonAncestor(\n      startNodeAndParents,\n      endNodeAndParents\n    );\n    startNode = commonAncestor;\n    endNode = commonAncestor;\n  } else {\n    ({ startNode, endNode } = findSiblingAncestors(\n      startNodeAndParents,\n      endNodeAndParents,\n      opts\n    ));\n  }\n  return {\n    rangeStart: Math.min(locStart(startNode), locStart(endNode)),\n    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode))\n  };\n}\n\n// src/main/core.js\nvar BOM = \"\\uFEFF\";\nvar CURSOR = Symbol(\"cursor\");\nasync function coreFormat(originalText, opts, addAlignmentSize = 0) {\n  if (!originalText || originalText.trim().length === 0) {\n    return {\n      formatted: \"\",\n      cursorOffset: -1,\n      comments: []\n    };\n  }\n  const {\n    ast,\n    text\n  } = await parse_default(originalText, opts);\n  if (opts.cursorOffset >= 0) {\n    opts.cursorNode = get_cursor_node_default(ast, opts);\n  }\n  let doc2 = await printAstToDoc(ast, opts, addAlignmentSize);\n  if (addAlignmentSize > 0) {\n    doc2 = addAlignmentToDoc([hardline, doc2], addAlignmentSize, opts.tabWidth);\n  }\n  const result = printDocToString(doc2, opts);\n  if (addAlignmentSize > 0) {\n    const trimmed = result.formatted.trim();\n    if (result.cursorNodeStart !== void 0) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n  const comments = opts[Symbol.for(\"comments\")];\n  if (opts.cursorOffset >= 0) {\n    let oldCursorNodeStart;\n    let oldCursorNodeText;\n    let cursorOffsetRelativeToOldCursorNode;\n    let newCursorNodeStart;\n    let newCursorNodeText;\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,\n        comments\n      };\n    }\n    const oldCursorNodeCharArray = oldCursorNodeText.split(\"\");\n    oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n    const newCursorNodeCharArray = newCursorNodeText.split(\"\");\n    const cursorNodeDiff = (0, import_diff.diffArrays)(oldCursorNodeCharArray, newCursorNodeCharArray);\n    let cursorOffset = newCursorNodeStart;\n    for (const entry of cursorNodeDiff) {\n      if (entry.removed) {\n        if (entry.value.includes(CURSOR)) {\n          break;\n        }\n      } else {\n        cursorOffset += entry.count;\n      }\n    }\n    return {\n      formatted: result.formatted,\n      cursorOffset,\n      comments\n    };\n  }\n  return {\n    formatted: result.formatted,\n    cursorOffset: -1,\n    comments\n  };\n}\nasync function formatRange(originalText, opts) {\n  const {\n    ast,\n    text\n  } = await parse_default(originalText, opts);\n  const {\n    rangeStart,\n    rangeEnd\n  } = calculateRange(text, opts, ast);\n  const rangeString = text.slice(rangeStart, rangeEnd);\n  const rangeStart2 = Math.min(rangeStart, text.lastIndexOf(\"\\n\", rangeStart) + 1);\n  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];\n  const alignmentSize = get_alignment_size_default(indentString, opts.tabWidth);\n  const rangeResult = await coreFormat(rangeString, {\n    ...opts,\n    rangeStart: 0,\n    rangeEnd: Number.POSITIVE_INFINITY,\n    // Track the cursor offset only if it's within our range\n    cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,\n    // Always use `lf` to format, we'll replace it later\n    endOfLine: \"lf\"\n  }, alignmentSize);\n  const rangeTrimmed = rangeResult.formatted.trimEnd();\n  let {\n    cursorOffset\n  } = opts;\n  if (cursorOffset > rangeEnd) {\n    cursorOffset += rangeTrimmed.length - rangeString.length;\n  } else if (rangeResult.cursorOffset >= 0) {\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  }\n  let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);\n  if (opts.endOfLine !== \"lf\") {\n    const eol = convertEndOfLineToChars(opts.endOfLine);\n    if (cursorOffset >= 0 && eol === \"\\r\\n\") {\n      cursorOffset += countEndOfLineChars(formatted.slice(0, cursorOffset), \"\\n\");\n    }\n    formatted = string_replace_all_default(\n      /* isOptionalObject*/\n      false,\n      formatted,\n      \"\\n\",\n      eol\n    );\n  }\n  return {\n    formatted,\n    cursorOffset,\n    comments: rangeResult.comments\n  };\n}\nfunction ensureIndexInText(text, index, defaultValue) {\n  if (typeof index !== \"number\" || Number.isNaN(index) || index < 0 || index > text.length) {\n    return defaultValue;\n  }\n  return index;\n}\nfunction normalizeIndexes(text, options8) {\n  let {\n    cursorOffset,\n    rangeStart,\n    rangeEnd\n  } = options8;\n  cursorOffset = ensureIndexInText(text, cursorOffset, -1);\n  rangeStart = ensureIndexInText(text, rangeStart, 0);\n  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);\n  return {\n    ...options8,\n    cursorOffset,\n    rangeStart,\n    rangeEnd\n  };\n}\nfunction normalizeInputAndOptions(text, options8) {\n  let {\n    cursorOffset,\n    rangeStart,\n    rangeEnd,\n    endOfLine\n  } = normalizeIndexes(text, options8);\n  const hasBOM = text.charAt(0) === BOM;\n  if (hasBOM) {\n    text = text.slice(1);\n    cursorOffset--;\n    rangeStart--;\n    rangeEnd--;\n  }\n  if (endOfLine === \"auto\") {\n    endOfLine = guessEndOfLine(text);\n  }\n  if (text.includes(\"\\r\")) {\n    const countCrlfBefore = (index) => countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");\n    cursorOffset -= countCrlfBefore(cursorOffset);\n    rangeStart -= countCrlfBefore(rangeStart);\n    rangeEnd -= countCrlfBefore(rangeEnd);\n    text = normalizeEndOfLine(text);\n  }\n  return {\n    hasBOM,\n    text,\n    options: normalizeIndexes(text, {\n      ...options8,\n      cursorOffset,\n      rangeStart,\n      rangeEnd,\n      endOfLine\n    })\n  };\n}\nasync function hasPragma(text, options8) {\n  const selectedParser = await resolveParser(options8);\n  return !selectedParser.hasPragma || selectedParser.hasPragma(text);\n}\nasync function formatWithCursor(originalText, originalOptions) {\n  let {\n    hasBOM,\n    text,\n    options: options8\n  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));\n  if (options8.rangeStart >= options8.rangeEnd && text !== \"\" || options8.requirePragma && !await hasPragma(text, options8)) {\n    return {\n      formatted: originalText,\n      cursorOffset: originalOptions.cursorOffset,\n      comments: []\n    };\n  }\n  let result;\n  if (options8.rangeStart > 0 || options8.rangeEnd < text.length) {\n    result = await formatRange(text, options8);\n  } else {\n    if (!options8.requirePragma && options8.insertPragma && options8.printer.insertPragma && !await hasPragma(text, options8)) {\n      text = options8.printer.insertPragma(text);\n    }\n    result = await coreFormat(text, options8);\n  }\n  if (hasBOM) {\n    result.formatted = BOM + result.formatted;\n    if (result.cursorOffset >= 0) {\n      result.cursorOffset++;\n    }\n  }\n  return result;\n}\nasync function parse5(originalText, originalOptions, devOptions) {\n  const {\n    text,\n    options: options8\n  } = normalizeInputAndOptions(originalText, await normalize_format_options_default(originalOptions));\n  const parsed = await parse_default(text, options8);\n  if (devOptions) {\n    if (devOptions.preprocessForPrint) {\n      parsed.ast = await prepareToPrint(parsed.ast, options8);\n    }\n    if (devOptions.massage) {\n      parsed.ast = massage_ast_default(parsed.ast, options8);\n    }\n  }\n  return parsed;\n}\nasync function formatAst(ast, options8) {\n  options8 = await normalize_format_options_default(options8);\n  const doc2 = await printAstToDoc(ast, options8);\n  return printDocToString(doc2, options8);\n}\nasync function formatDoc(doc2, options8) {\n  const text = printDocToDebug(doc2);\n  const {\n    formatted\n  } = await formatWithCursor(text, {\n    ...options8,\n    parser: \"__js_expression\"\n  });\n  return formatted;\n}\nasync function printToDoc(originalText, options8) {\n  options8 = await normalize_format_options_default(options8);\n  const {\n    ast\n  } = await parse_default(originalText, options8);\n  return printAstToDoc(ast, options8);\n}\nasync function printDocToString2(doc2, options8) {\n  return printDocToString(doc2, await normalize_format_options_default(options8));\n}\n\n// src/main/option-categories.js\nvar option_categories_exports = {};\n__export(option_categories_exports, {\n  CATEGORY_CONFIG: () => CATEGORY_CONFIG,\n  CATEGORY_EDITOR: () => CATEGORY_EDITOR,\n  CATEGORY_FORMAT: () => CATEGORY_FORMAT,\n  CATEGORY_GLOBAL: () => CATEGORY_GLOBAL,\n  CATEGORY_OTHER: () => CATEGORY_OTHER,\n  CATEGORY_OUTPUT: () => CATEGORY_OUTPUT,\n  CATEGORY_SPECIAL: () => CATEGORY_SPECIAL\n});\nvar CATEGORY_CONFIG = \"Config\";\nvar CATEGORY_EDITOR = \"Editor\";\nvar CATEGORY_FORMAT = \"Format\";\nvar CATEGORY_OTHER = \"Other\";\nvar CATEGORY_OUTPUT = \"Output\";\nvar CATEGORY_GLOBAL = \"Global\";\nvar CATEGORY_SPECIAL = \"Special\";\n\n// src/plugins/builtin-plugins-proxy.js\nvar builtin_plugins_proxy_exports = {};\n__export(builtin_plugins_proxy_exports, {\n  languages: () => languages,\n  options: () => options7,\n  parsers: () => parsers,\n  printers: () => printers\n});\n\n// src/language-css/languages.evaluate.js\nvar languages_evaluate_default = [\n  {\n    \"linguistLanguageId\": 50,\n    \"name\": \"CSS\",\n    \"type\": \"markup\",\n    \"tmScope\": \"source.css\",\n    \"aceMode\": \"css\",\n    \"codemirrorMode\": \"css\",\n    \"codemirrorMimeType\": \"text/css\",\n    \"color\": \"#563d7c\",\n    \"extensions\": [\n      \".css\",\n      \".wxss\"\n    ],\n    \"parsers\": [\n      \"css\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"css\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 262764437,\n    \"name\": \"PostCSS\",\n    \"type\": \"markup\",\n    \"color\": \"#dc3a0c\",\n    \"tmScope\": \"source.postcss\",\n    \"group\": \"CSS\",\n    \"extensions\": [\n      \".pcss\",\n      \".postcss\"\n    ],\n    \"aceMode\": \"text\",\n    \"parsers\": [\n      \"css\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"postcss\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 198,\n    \"name\": \"Less\",\n    \"type\": \"markup\",\n    \"color\": \"#1d365d\",\n    \"aliases\": [\n      \"less-css\"\n    ],\n    \"extensions\": [\n      \".less\"\n    ],\n    \"tmScope\": \"source.css.less\",\n    \"aceMode\": \"less\",\n    \"codemirrorMode\": \"css\",\n    \"codemirrorMimeType\": \"text/css\",\n    \"parsers\": [\n      \"less\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"less\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 329,\n    \"name\": \"SCSS\",\n    \"type\": \"markup\",\n    \"color\": \"#c6538c\",\n    \"tmScope\": \"source.css.scss\",\n    \"aceMode\": \"scss\",\n    \"codemirrorMode\": \"css\",\n    \"codemirrorMimeType\": \"text/x-scss\",\n    \"extensions\": [\n      \".scss\"\n    ],\n    \"parsers\": [\n      \"scss\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"scss\"\n    ]\n  }\n];\n\n// src/common/common-options.evaluate.js\nvar common_options_evaluate_default = {\n  \"bracketSpacing\": {\n    \"category\": \"Common\",\n    \"type\": \"boolean\",\n    \"default\": true,\n    \"description\": \"Print spaces between brackets.\",\n    \"oppositeDescription\": \"Do not print spaces between brackets.\"\n  },\n  \"singleQuote\": {\n    \"category\": \"Common\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Use single quotes instead of double quotes.\"\n  },\n  \"proseWrap\": {\n    \"category\": \"Common\",\n    \"type\": \"choice\",\n    \"default\": \"preserve\",\n    \"description\": \"How to wrap prose.\",\n    \"choices\": [\n      {\n        \"value\": \"always\",\n        \"description\": \"Wrap prose if it exceeds the print width.\"\n      },\n      {\n        \"value\": \"never\",\n        \"description\": \"Do not wrap prose.\"\n      },\n      {\n        \"value\": \"preserve\",\n        \"description\": \"Wrap prose as-is.\"\n      }\n    ]\n  },\n  \"bracketSameLine\": {\n    \"category\": \"Common\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Put > of opening tags on the last line instead of on a new line.\"\n  },\n  \"singleAttributePerLine\": {\n    \"category\": \"Common\",\n    \"type\": \"boolean\",\n    \"default\": false,\n    \"description\": \"Enforce single attribute per line in HTML, Vue and JSX.\"\n  }\n};\n\n// src/language-css/options.js\nvar options = {\n  singleQuote: common_options_evaluate_default.singleQuote\n};\nvar options_default = options;\n\n// src/language-graphql/languages.evaluate.js\nvar languages_evaluate_default2 = [\n  {\n    \"linguistLanguageId\": 139,\n    \"name\": \"GraphQL\",\n    \"type\": \"data\",\n    \"color\": \"#e10098\",\n    \"extensions\": [\n      \".graphql\",\n      \".gql\",\n      \".graphqls\"\n    ],\n    \"tmScope\": \"source.graphql\",\n    \"aceMode\": \"text\",\n    \"parsers\": [\n      \"graphql\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"graphql\"\n    ]\n  }\n];\n\n// src/language-graphql/options.js\nvar options2 = {\n  bracketSpacing: common_options_evaluate_default.bracketSpacing\n};\nvar options_default2 = options2;\n\n// src/language-handlebars/languages.evaluate.js\nvar languages_evaluate_default3 = [\n  {\n    \"linguistLanguageId\": 155,\n    \"name\": \"Handlebars\",\n    \"type\": \"markup\",\n    \"color\": \"#f7931e\",\n    \"aliases\": [\n      \"hbs\",\n      \"htmlbars\"\n    ],\n    \"extensions\": [\n      \".handlebars\",\n      \".hbs\"\n    ],\n    \"tmScope\": \"text.html.handlebars\",\n    \"aceMode\": \"handlebars\",\n    \"parsers\": [\n      \"glimmer\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"handlebars\"\n    ]\n  }\n];\n\n// src/language-html/languages.evaluate.js\nvar languages_evaluate_default4 = [\n  {\n    \"linguistLanguageId\": 146,\n    \"name\": \"Angular\",\n    \"type\": \"markup\",\n    \"tmScope\": \"text.html.basic\",\n    \"aceMode\": \"html\",\n    \"codemirrorMode\": \"htmlmixed\",\n    \"codemirrorMimeType\": \"text/html\",\n    \"color\": \"#e34c26\",\n    \"aliases\": [\n      \"xhtml\"\n    ],\n    \"extensions\": [\n      \".component.html\"\n    ],\n    \"parsers\": [\n      \"angular\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"html\"\n    ],\n    \"filenames\": []\n  },\n  {\n    \"linguistLanguageId\": 146,\n    \"name\": \"HTML\",\n    \"type\": \"markup\",\n    \"tmScope\": \"text.html.basic\",\n    \"aceMode\": \"html\",\n    \"codemirrorMode\": \"htmlmixed\",\n    \"codemirrorMimeType\": \"text/html\",\n    \"color\": \"#e34c26\",\n    \"aliases\": [\n      \"xhtml\"\n    ],\n    \"extensions\": [\n      \".html\",\n      \".hta\",\n      \".htm\",\n      \".html.hl\",\n      \".inc\",\n      \".xht\",\n      \".xhtml\",\n      \".mjml\"\n    ],\n    \"parsers\": [\n      \"html\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"html\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 146,\n    \"name\": \"Lightning Web Components\",\n    \"type\": \"markup\",\n    \"tmScope\": \"text.html.basic\",\n    \"aceMode\": \"html\",\n    \"codemirrorMode\": \"htmlmixed\",\n    \"codemirrorMimeType\": \"text/html\",\n    \"color\": \"#e34c26\",\n    \"aliases\": [\n      \"xhtml\"\n    ],\n    \"extensions\": [],\n    \"parsers\": [\n      \"lwc\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"html\"\n    ],\n    \"filenames\": []\n  },\n  {\n    \"linguistLanguageId\": 391,\n    \"name\": \"Vue\",\n    \"type\": \"markup\",\n    \"color\": \"#41b883\",\n    \"extensions\": [\n      \".vue\"\n    ],\n    \"tmScope\": \"text.html.vue\",\n    \"aceMode\": \"html\",\n    \"parsers\": [\n      \"vue\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"vue\"\n    ]\n  }\n];\n\n// src/language-html/options.js\nvar CATEGORY_HTML = \"HTML\";\nvar options3 = {\n  bracketSameLine: common_options_evaluate_default.bracketSameLine,\n  htmlWhitespaceSensitivity: {\n    category: CATEGORY_HTML,\n    type: \"choice\",\n    default: \"css\",\n    description: \"How to handle whitespaces in HTML.\",\n    choices: [\n      {\n        value: \"css\",\n        description: \"Respect the default value of CSS display property.\"\n      },\n      {\n        value: \"strict\",\n        description: \"Whitespaces are considered sensitive.\"\n      },\n      {\n        value: \"ignore\",\n        description: \"Whitespaces are considered insensitive.\"\n      }\n    ]\n  },\n  singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine,\n  vueIndentScriptAndStyle: {\n    category: CATEGORY_HTML,\n    type: \"boolean\",\n    default: false,\n    description: \"Indent script and style tags in Vue files.\"\n  }\n};\nvar options_default3 = options3;\n\n// src/language-js/languages.evaluate.js\nvar languages_evaluate_default5 = [\n  {\n    \"linguistLanguageId\": 183,\n    \"name\": \"JavaScript\",\n    \"type\": \"programming\",\n    \"tmScope\": \"source.js\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"text/javascript\",\n    \"color\": \"#f1e05a\",\n    \"aliases\": [\n      \"js\",\n      \"node\"\n    ],\n    \"extensions\": [\n      \".js\",\n      \"._js\",\n      \".bones\",\n      \".cjs\",\n      \".es\",\n      \".es6\",\n      \".frag\",\n      \".gs\",\n      \".jake\",\n      \".javascript\",\n      \".jsb\",\n      \".jscad\",\n      \".jsfl\",\n      \".jslib\",\n      \".jsm\",\n      \".jspre\",\n      \".jss\",\n      \".mjs\",\n      \".njs\",\n      \".pac\",\n      \".sjs\",\n      \".ssjs\",\n      \".xsjs\",\n      \".xsjslib\",\n      \".wxs\"\n    ],\n    \"filenames\": [\n      \"Jakefile\"\n    ],\n    \"interpreters\": [\n      \"chakra\",\n      \"d8\",\n      \"gjs\",\n      \"js\",\n      \"node\",\n      \"nodejs\",\n      \"qjs\",\n      \"rhino\",\n      \"v8\",\n      \"v8-shell\",\n      \"zx\"\n    ],\n    \"parsers\": [\n      \"babel\",\n      \"acorn\",\n      \"espree\",\n      \"meriyah\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"flow\",\n      \"typescript\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"javascript\",\n      \"mongo\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 183,\n    \"name\": \"Flow\",\n    \"type\": \"programming\",\n    \"tmScope\": \"source.js\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"text/javascript\",\n    \"color\": \"#f1e05a\",\n    \"aliases\": [],\n    \"extensions\": [\n      \".js.flow\"\n    ],\n    \"filenames\": [],\n    \"interpreters\": [\n      \"chakra\",\n      \"d8\",\n      \"gjs\",\n      \"js\",\n      \"node\",\n      \"nodejs\",\n      \"qjs\",\n      \"rhino\",\n      \"v8\",\n      \"v8-shell\"\n    ],\n    \"parsers\": [\n      \"flow\",\n      \"babel-flow\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"javascript\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 183,\n    \"name\": \"JSX\",\n    \"type\": \"programming\",\n    \"tmScope\": \"source.js.jsx\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"jsx\",\n    \"codemirrorMimeType\": \"text/jsx\",\n    \"color\": void 0,\n    \"aliases\": void 0,\n    \"extensions\": [\n      \".jsx\"\n    ],\n    \"filenames\": void 0,\n    \"interpreters\": void 0,\n    \"parsers\": [\n      \"babel\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"flow\",\n      \"typescript\",\n      \"espree\",\n      \"meriyah\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"javascriptreact\"\n    ],\n    \"group\": \"JavaScript\"\n  },\n  {\n    \"linguistLanguageId\": 378,\n    \"name\": \"TypeScript\",\n    \"type\": \"programming\",\n    \"color\": \"#3178c6\",\n    \"aliases\": [\n      \"ts\"\n    ],\n    \"interpreters\": [\n      \"deno\",\n      \"ts-node\"\n    ],\n    \"extensions\": [\n      \".ts\",\n      \".cts\",\n      \".mts\"\n    ],\n    \"tmScope\": \"source.ts\",\n    \"aceMode\": \"typescript\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"application/typescript\",\n    \"parsers\": [\n      \"typescript\",\n      \"babel-ts\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"typescript\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 94901924,\n    \"name\": \"TSX\",\n    \"type\": \"programming\",\n    \"color\": \"#3178c6\",\n    \"group\": \"TypeScript\",\n    \"extensions\": [\n      \".tsx\"\n    ],\n    \"tmScope\": \"source.tsx\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"jsx\",\n    \"codemirrorMimeType\": \"text/jsx\",\n    \"parsers\": [\n      \"typescript\",\n      \"babel-ts\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"typescriptreact\"\n    ]\n  }\n];\n\n// src/language-js/options.js\nvar CATEGORY_JAVASCRIPT = \"JavaScript\";\nvar options4 = {\n  arrowParens: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"always\",\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\"\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\"\n      }\n    ]\n  },\n  bracketSameLine: common_options_evaluate_default.bracketSameLine,\n  bracketSpacing: common_options_evaluate_default.bracketSpacing,\n  jsxBracketSameLine: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    description: \"Put > on the last line instead of at a new line.\",\n    deprecated: \"2.4.0\"\n  },\n  semi: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription: \"Do not print semicolons, except at the beginning of lines which may need them.\"\n  },\n  experimentalTernaries: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use curious ternaries, with the question mark after the condition.\",\n    oppositeDescription: \"Default behavior of ternaries; keep question marks on the same line as the consequent.\"\n  },\n  singleQuote: common_options_evaluate_default.singleQuote,\n  jsxSingleQuote: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\"\n  },\n  quoteProps: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\"\n      },\n      {\n        value: \"consistent\",\n        description: \"If at least one property in an object requires quotes, quote all properties.\"\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\"\n      }\n    ]\n  },\n  trailingComma: {\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"all\",\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"all\",\n        description: \"Trailing commas wherever possible (including function arguments).\"\n      },\n      {\n        value: \"es5\",\n        description: \"Trailing commas where valid in ES5 (objects, arrays, etc.)\"\n      },\n      { value: \"none\", description: \"No trailing commas.\" }\n    ]\n  },\n  singleAttributePerLine: common_options_evaluate_default.singleAttributePerLine\n};\nvar options_default4 = options4;\n\n// src/language-json/languages.evaluate.js\nvar languages_evaluate_default6 = [\n  {\n    \"linguistLanguageId\": 174,\n    \"name\": \"JSON.stringify\",\n    \"type\": \"data\",\n    \"color\": \"#292929\",\n    \"tmScope\": \"source.json\",\n    \"aceMode\": \"json\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"application/json\",\n    \"aliases\": [\n      \"geojson\",\n      \"jsonl\",\n      \"topojson\"\n    ],\n    \"extensions\": [\n      \".importmap\"\n    ],\n    \"filenames\": [\n      \"package.json\",\n      \"package-lock.json\",\n      \"composer.json\"\n    ],\n    \"parsers\": [\n      \"json-stringify\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"json\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 174,\n    \"name\": \"JSON\",\n    \"type\": \"data\",\n    \"color\": \"#292929\",\n    \"tmScope\": \"source.json\",\n    \"aceMode\": \"json\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"application/json\",\n    \"aliases\": [\n      \"geojson\",\n      \"jsonl\",\n      \"topojson\"\n    ],\n    \"extensions\": [\n      \".json\",\n      \".4DForm\",\n      \".4DProject\",\n      \".avsc\",\n      \".geojson\",\n      \".gltf\",\n      \".har\",\n      \".ice\",\n      \".JSON-tmLanguage\",\n      \".mcmeta\",\n      \".tfstate\",\n      \".tfstate.backup\",\n      \".topojson\",\n      \".webapp\",\n      \".webmanifest\",\n      \".yy\",\n      \".yyp\"\n    ],\n    \"filenames\": [\n      \".all-contributorsrc\",\n      \".arcconfig\",\n      \".auto-changelog\",\n      \".c8rc\",\n      \".htmlhintrc\",\n      \".imgbotconfig\",\n      \".nycrc\",\n      \".tern-config\",\n      \".tern-project\",\n      \".watchmanconfig\",\n      \"Pipfile.lock\",\n      \"composer.lock\",\n      \"flake.lock\",\n      \"mcmod.info\",\n      \".babelrc\",\n      \".jscsrc\",\n      \".jshintrc\",\n      \".jslintrc\",\n      \".swcrc\"\n    ],\n    \"parsers\": [\n      \"json\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"json\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 423,\n    \"name\": \"JSON with Comments\",\n    \"type\": \"data\",\n    \"color\": \"#292929\",\n    \"group\": \"JSON\",\n    \"tmScope\": \"source.js\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"text/javascript\",\n    \"aliases\": [\n      \"jsonc\"\n    ],\n    \"extensions\": [\n      \".jsonc\",\n      \".code-snippets\",\n      \".code-workspace\",\n      \".sublime-build\",\n      \".sublime-commands\",\n      \".sublime-completions\",\n      \".sublime-keymap\",\n      \".sublime-macro\",\n      \".sublime-menu\",\n      \".sublime-mousemap\",\n      \".sublime-project\",\n      \".sublime-settings\",\n      \".sublime-theme\",\n      \".sublime-workspace\",\n      \".sublime_metrics\",\n      \".sublime_session\"\n    ],\n    \"filenames\": [],\n    \"parsers\": [\n      \"jsonc\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"jsonc\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 175,\n    \"name\": \"JSON5\",\n    \"type\": \"data\",\n    \"color\": \"#267CB9\",\n    \"extensions\": [\n      \".json5\"\n    ],\n    \"tmScope\": \"source.js\",\n    \"aceMode\": \"javascript\",\n    \"codemirrorMode\": \"javascript\",\n    \"codemirrorMimeType\": \"application/json\",\n    \"parsers\": [\n      \"json5\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"json5\"\n    ]\n  }\n];\n\n// src/language-markdown/languages.evaluate.js\nvar languages_evaluate_default7 = [\n  {\n    \"linguistLanguageId\": 222,\n    \"name\": \"Markdown\",\n    \"type\": \"prose\",\n    \"color\": \"#083fa1\",\n    \"aliases\": [\n      \"md\",\n      \"pandoc\"\n    ],\n    \"aceMode\": \"markdown\",\n    \"codemirrorMode\": \"gfm\",\n    \"codemirrorMimeType\": \"text/x-gfm\",\n    \"wrap\": true,\n    \"extensions\": [\n      \".md\",\n      \".livemd\",\n      \".markdown\",\n      \".mdown\",\n      \".mdwn\",\n      \".mkd\",\n      \".mkdn\",\n      \".mkdown\",\n      \".ronn\",\n      \".scd\",\n      \".workbook\"\n    ],\n    \"filenames\": [\n      \"contents.lr\",\n      \"README\"\n    ],\n    \"tmScope\": \"text.md\",\n    \"parsers\": [\n      \"markdown\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"markdown\"\n    ]\n  },\n  {\n    \"linguistLanguageId\": 222,\n    \"name\": \"MDX\",\n    \"type\": \"prose\",\n    \"color\": \"#083fa1\",\n    \"aliases\": [\n      \"md\",\n      \"pandoc\"\n    ],\n    \"aceMode\": \"markdown\",\n    \"codemirrorMode\": \"gfm\",\n    \"codemirrorMimeType\": \"text/x-gfm\",\n    \"wrap\": true,\n    \"extensions\": [\n      \".mdx\"\n    ],\n    \"filenames\": [],\n    \"tmScope\": \"text.md\",\n    \"parsers\": [\n      \"mdx\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"mdx\"\n    ]\n  }\n];\n\n// src/language-markdown/options.js\nvar options5 = {\n  proseWrap: common_options_evaluate_default.proseWrap,\n  singleQuote: common_options_evaluate_default.singleQuote\n};\nvar options_default5 = options5;\n\n// src/language-yaml/languages.evaluate.js\nvar languages_evaluate_default8 = [\n  {\n    \"linguistLanguageId\": 407,\n    \"name\": \"YAML\",\n    \"type\": \"data\",\n    \"color\": \"#cb171e\",\n    \"tmScope\": \"source.yaml\",\n    \"aliases\": [\n      \"yml\"\n    ],\n    \"extensions\": [\n      \".yml\",\n      \".mir\",\n      \".reek\",\n      \".rviz\",\n      \".sublime-syntax\",\n      \".syntax\",\n      \".yaml\",\n      \".yaml-tmlanguage\",\n      \".yaml.sed\",\n      \".yml.mysql\"\n    ],\n    \"filenames\": [\n      \".clang-format\",\n      \".clang-tidy\",\n      \".gemrc\",\n      \"CITATION.cff\",\n      \"glide.lock\",\n      \".prettierrc\",\n      \".stylelintrc\",\n      \".lintstagedrc\"\n    ],\n    \"aceMode\": \"yaml\",\n    \"codemirrorMode\": \"yaml\",\n    \"codemirrorMimeType\": \"text/x-yaml\",\n    \"parsers\": [\n      \"yaml\"\n    ],\n    \"vscodeLanguageIds\": [\n      \"yaml\",\n      \"ansible\",\n      \"home-assistant\"\n    ]\n  }\n];\n\n// src/language-yaml/options.js\nvar options6 = {\n  bracketSpacing: common_options_evaluate_default.bracketSpacing,\n  singleQuote: common_options_evaluate_default.singleQuote,\n  proseWrap: common_options_evaluate_default.proseWrap\n};\nvar options_default6 = options6;\n\n// src/plugins/builtin-plugins-proxy.js\nfunction createParsersAndPrinters(modules) {\n  const parsers2 = /* @__PURE__ */ Object.create(null);\n  const printers2 = /* @__PURE__ */ Object.create(null);\n  for (const {\n    importPlugin: importPlugin2,\n    parsers: parserNames = [],\n    printers: printerNames = []\n  } of modules) {\n    const loadPlugin2 = async () => {\n      const plugin = await importPlugin2();\n      Object.assign(parsers2, plugin.parsers);\n      Object.assign(printers2, plugin.printers);\n      return plugin;\n    };\n    for (const parserName of parserNames) {\n      parsers2[parserName] = async () => (await loadPlugin2()).parsers[parserName];\n    }\n    for (const printerName of printerNames) {\n      printers2[printerName] = async () => (await loadPlugin2()).printers[printerName];\n    }\n  }\n  return { parsers: parsers2, printers: printers2 };\n}\nvar options7 = {\n  ...options_default,\n  ...options_default2,\n  ...options_default3,\n  ...options_default4,\n  ...options_default5,\n  ...options_default6\n};\nvar languages = [\n  ...languages_evaluate_default,\n  ...languages_evaluate_default2,\n  ...languages_evaluate_default3,\n  ...languages_evaluate_default4,\n  ...languages_evaluate_default5,\n  ...languages_evaluate_default6,\n  ...languages_evaluate_default7,\n  ...languages_evaluate_default8\n];\nvar { parsers, printers } = createParsersAndPrinters([\n  {\n    importPlugin: () => import(\"./plugins/acorn.mjs\"),\n    parsers: [\"acorn\", \"espree\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/angular.mjs\"),\n    parsers: [\n      \"__ng_action\",\n      \"__ng_binding\",\n      \"__ng_interpolation\",\n      \"__ng_directive\"\n    ]\n  },\n  {\n    importPlugin: () => import(\"./plugins/babel.mjs\"),\n    parsers: [\n      \"babel\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"__js_expression\",\n      \"__ts_expression\",\n      \"__vue_expression\",\n      \"__vue_ts_expression\",\n      \"__vue_event_binding\",\n      \"__vue_ts_event_binding\",\n      \"__babel_estree\",\n      \"json\",\n      \"json5\",\n      \"jsonc\",\n      \"json-stringify\"\n    ]\n  },\n  {\n    importPlugin: () => import(\"./plugins/estree.mjs\"),\n    printers: [\"estree\", \"estree-json\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/flow.mjs\"),\n    parsers: [\"flow\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/glimmer.mjs\"),\n    parsers: [\"glimmer\"],\n    printers: [\"glimmer\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/graphql.mjs\"),\n    parsers: [\"graphql\"],\n    printers: [\"graphql\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/html.mjs\"),\n    parsers: [\"html\", \"angular\", \"vue\", \"lwc\"],\n    printers: [\"html\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/markdown.mjs\"),\n    parsers: [\"markdown\", \"mdx\", \"remark\"],\n    printers: [\"mdast\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/meriyah.mjs\"),\n    parsers: [\"meriyah\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/postcss.mjs\"),\n    parsers: [\"css\", \"less\", \"scss\"],\n    printers: [\"postcss\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/typescript.mjs\"),\n    parsers: [\"typescript\"]\n  },\n  {\n    importPlugin: () => import(\"./plugins/yaml.mjs\"),\n    parsers: [\"yaml\"],\n    printers: [\"yaml\"]\n  }\n]);\n\n// src/main/plugins/load-builtin-plugins.js\nfunction loadBuiltinPlugins() {\n  return [builtin_plugins_proxy_exports];\n}\nvar load_builtin_plugins_default = loadBuiltinPlugins;\n\n// src/main/plugins/load-plugin.js\nimport path12 from \"path\";\nimport { pathToFileURL as pathToFileURL5 } from \"url\";\n\n// src/utils/import-from-directory.js\nimport path11 from \"path\";\nfunction importFromDirectory(specifier, directory) {\n  return import_from_file_default(specifier, path11.join(directory, \"noop.js\"));\n}\nvar import_from_directory_default = importFromDirectory;\n\n// src/main/plugins/load-plugin.js\nasync function importPlugin(name, cwd) {\n  if (path12.isAbsolute(name)) {\n    return import(pathToFileURL5(name).href);\n  }\n  try {\n    return await import(pathToFileURL5(path12.resolve(name)).href);\n  } catch {\n    return import_from_directory_default(name, cwd);\n  }\n}\nasync function loadPluginWithoutCache(plugin, cwd) {\n  const module = await importPlugin(plugin, cwd);\n  return { name: plugin, ...module.default ?? module };\n}\nvar cache2 = /* @__PURE__ */ new Map();\nfunction loadPlugin(plugin) {\n  if (typeof plugin !== \"string\") {\n    return plugin;\n  }\n  const cwd = process.cwd();\n  const cacheKey = JSON.stringify({ name: plugin, cwd });\n  if (!cache2.has(cacheKey)) {\n    cache2.set(cacheKey, loadPluginWithoutCache(plugin, cwd));\n  }\n  return cache2.get(cacheKey);\n}\nfunction clearCache2() {\n  cache2.clear();\n}\n\n// src/main/plugins/load-plugins.js\nfunction loadPlugins(plugins = []) {\n  return Promise.all(plugins.map((plugin) => loadPlugin(plugin)));\n}\nvar load_plugins_default = loadPlugins;\n\n// src/utils/object-omit.js\nfunction omit(object, keys) {\n  keys = new Set(keys);\n  return Object.fromEntries(\n    Object.entries(object).filter(([key2]) => !keys.has(key2))\n  );\n}\nvar object_omit_default = omit;\n\n// src/index.js\nimport * as doc from \"./doc.mjs\";\n\n// src/main/version.evaluate.cjs\nvar version_evaluate_default = \"3.2.5\";\n\n// src/utils/public.js\nvar public_exports = {};\n__export(public_exports, {\n  addDanglingComment: () => addDanglingComment,\n  addLeadingComment: () => addLeadingComment,\n  addTrailingComment: () => addTrailingComment,\n  getAlignmentSize: () => get_alignment_size_default,\n  getIndentSize: () => get_indent_size_default,\n  getMaxContinuousCount: () => get_max_continuous_count_default,\n  getNextNonSpaceNonCommentCharacter: () => get_next_non_space_non_comment_character_default,\n  getNextNonSpaceNonCommentCharacterIndex: () => getNextNonSpaceNonCommentCharacterIndex2,\n  getStringWidth: () => get_string_width_default,\n  hasNewline: () => has_newline_default,\n  hasNewlineInRange: () => has_newline_in_range_default,\n  hasSpaces: () => has_spaces_default,\n  isNextLineEmpty: () => isNextLineEmpty2,\n  isNextLineEmptyAfterIndex: () => is_next_line_empty_default,\n  isPreviousLineEmpty: () => isPreviousLineEmpty2,\n  makeString: () => make_string_default,\n  skip: () => skip,\n  skipEverythingButNewLine: () => skipEverythingButNewLine,\n  skipInlineComment: () => skip_inline_comment_default,\n  skipNewline: () => skip_newline_default,\n  skipSpaces: () => skipSpaces,\n  skipToLineEnd: () => skipToLineEnd,\n  skipTrailingComment: () => skip_trailing_comment_default,\n  skipWhitespace: () => skipWhitespace\n});\n\n// src/utils/skip-inline-comment.js\nfunction skipInlineComment(text, startIndex) {\n  if (startIndex === false) {\n    return false;\n  }\n  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"*\") {\n    for (let i = startIndex + 2; i < text.length; ++i) {\n      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {\n        return i + 2;\n      }\n    }\n  }\n  return startIndex;\n}\nvar skip_inline_comment_default = skipInlineComment;\n\n// src/utils/skip-trailing-comment.js\nfunction skipTrailingComment(text, startIndex) {\n  if (startIndex === false) {\n    return false;\n  }\n  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"/\") {\n    return skipEverythingButNewLine(text, startIndex);\n  }\n  return startIndex;\n}\nvar skip_trailing_comment_default = skipTrailingComment;\n\n// src/utils/get-next-non-space-non-comment-character-index.js\nfunction getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {\n  let oldIdx = null;\n  let nextIdx = startIndex;\n  while (nextIdx !== oldIdx) {\n    oldIdx = nextIdx;\n    nextIdx = skipSpaces(text, nextIdx);\n    nextIdx = skip_inline_comment_default(text, nextIdx);\n    nextIdx = skip_trailing_comment_default(text, nextIdx);\n    nextIdx = skip_newline_default(text, nextIdx);\n  }\n  return nextIdx;\n}\nvar get_next_non_space_non_comment_character_index_default = getNextNonSpaceNonCommentCharacterIndex;\n\n// src/utils/is-next-line-empty.js\nfunction isNextLineEmpty(text, startIndex) {\n  let oldIdx = null;\n  let idx = startIndex;\n  while (idx !== oldIdx) {\n    oldIdx = idx;\n    idx = skipToLineEnd(text, idx);\n    idx = skip_inline_comment_default(text, idx);\n    idx = skipSpaces(text, idx);\n  }\n  idx = skip_trailing_comment_default(text, idx);\n  idx = skip_newline_default(text, idx);\n  return idx !== false && has_newline_default(text, idx);\n}\nvar is_next_line_empty_default = isNextLineEmpty;\n\n// src/utils/get-indent-size.js\nfunction getIndentSize(value, tabWidth) {\n  const lastNewlineIndex = value.lastIndexOf(\"\\n\");\n  if (lastNewlineIndex === -1) {\n    return 0;\n  }\n  return get_alignment_size_default(\n    // All the leading whitespaces\n    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],\n    tabWidth\n  );\n}\nvar get_indent_size_default = getIndentSize;\n\n// node_modules/escape-string-regexp/index.js\nfunction escapeStringRegexp(string) {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n}\n\n// src/utils/get-max-continuous-count.js\nfunction getMaxContinuousCount(text, searchString) {\n  const results = text.match(\n    new RegExp(`(${escapeStringRegexp(searchString)})+`, \"g\")\n  );\n  if (results === null) {\n    return 0;\n  }\n  return results.reduce(\n    (maxCount, result) => Math.max(maxCount, result.length / searchString.length),\n    0\n  );\n}\nvar get_max_continuous_count_default = getMaxContinuousCount;\n\n// src/utils/get-next-non-space-non-comment-character.js\nfunction getNextNonSpaceNonCommentCharacter(text, startIndex) {\n  const index = get_next_non_space_non_comment_character_index_default(text, startIndex);\n  return index === false ? \"\" : text.charAt(index);\n}\nvar get_next_non_space_non_comment_character_default = getNextNonSpaceNonCommentCharacter;\n\n// src/utils/has-newline-in-range.js\nfunction hasNewlineInRange(text, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; ++i) {\n    if (text.charAt(i) === \"\\n\") {\n      return true;\n    }\n  }\n  return false;\n}\nvar has_newline_in_range_default = hasNewlineInRange;\n\n// src/utils/has-spaces.js\nfunction hasSpaces(text, startIndex, options8 = {}) {\n  const idx = skipSpaces(\n    text,\n    options8.backwards ? startIndex - 1 : startIndex,\n    options8\n  );\n  return idx !== startIndex;\n}\nvar has_spaces_default = hasSpaces;\n\n// src/utils/make-string.js\nfunction makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {\n  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';\n  const regex = /\\\\(.)|([\"'])/gs;\n  const raw = string_replace_all_default(\n    /* isOptionalObject*/\n    false,\n    rawText,\n    regex,\n    (match, escaped, quote) => {\n      if (escaped === otherQuote) {\n        return escaped;\n      }\n      if (quote === enclosingQuote) {\n        return \"\\\\\" + quote;\n      }\n      if (quote) {\n        return quote;\n      }\n      return unescapeUnnecessaryEscapes && /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped) ? escaped : \"\\\\\" + escaped;\n    }\n  );\n  return enclosingQuote + raw + enclosingQuote;\n}\nvar make_string_default = makeString;\n\n// src/utils/public.js\nfunction legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n  return get_next_non_space_non_comment_character_index_default(\n    text,\n    locEnd(node)\n  );\n}\nfunction getNextNonSpaceNonCommentCharacterIndex2(text, startIndex) {\n  return arguments.length === 2 || typeof startIndex === \"number\" ? get_next_non_space_non_comment_character_index_default(text, startIndex) : (\n    // @ts-expect-error -- expected\n    // eslint-disable-next-line prefer-rest-params\n    legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments)\n  );\n}\nfunction legacyIsPreviousLineEmpty(text, node, locStart) {\n  return is_previous_line_empty_default(text, locStart(node));\n}\nfunction isPreviousLineEmpty2(text, startIndex) {\n  return arguments.length === 2 || typeof startIndex === \"number\" ? is_previous_line_empty_default(text, startIndex) : (\n    // @ts-expect-error -- expected\n    // eslint-disable-next-line prefer-rest-params\n    legacyIsPreviousLineEmpty(...arguments)\n  );\n}\nfunction legacyIsNextLineEmpty(text, node, locEnd) {\n  return is_next_line_empty_default(text, locEnd(node));\n}\nfunction isNextLineEmpty2(text, startIndex) {\n  return arguments.length === 2 || typeof startIndex === \"number\" ? is_next_line_empty_default(text, startIndex) : (\n    // @ts-expect-error -- expected\n    // eslint-disable-next-line prefer-rest-params\n    legacyIsNextLineEmpty(...arguments)\n  );\n}\n\n// src/index.js\nfunction withPlugins(fn, optionsArgumentIndex = 1) {\n  return async (...args) => {\n    const options8 = args[optionsArgumentIndex] ?? {};\n    const { plugins = [] } = options8;\n    args[optionsArgumentIndex] = {\n      ...options8,\n      plugins: (await Promise.all([\n        load_builtin_plugins_default(),\n        // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too\n        load_plugins_default(plugins)\n      ])).flat()\n    };\n    return fn(...args);\n  };\n}\nvar formatWithCursor2 = withPlugins(formatWithCursor);\nasync function format2(text, options8) {\n  const { formatted } = await formatWithCursor2(text, {\n    ...options8,\n    cursorOffset: -1\n  });\n  return formatted;\n}\nasync function check(text, options8) {\n  return await format2(text, options8) === text;\n}\nasync function clearCache3() {\n  clearCache();\n  clearCache2();\n}\nvar getFileInfo2 = withPlugins(get_file_info_default);\nvar getSupportInfo2 = withPlugins(getSupportInfo, 0);\nvar sharedWithCli = {\n  errors: errors_exports,\n  optionCategories: option_categories_exports,\n  createIsIgnoredFunction,\n  formatOptionsHiddenDefaults,\n  normalizeOptions: normalize_options_default,\n  getSupportInfoWithoutPlugins: getSupportInfo,\n  normalizeOptionSettings,\n  vnopts: {\n    ChoiceSchema,\n    apiDescriptor\n  },\n  fastGlob: import_fast_glob.default,\n  utils: {\n    isNonEmptyArray: is_non_empty_array_default,\n    partition: partition_default,\n    omit: object_omit_default\n  },\n  mockable: mockable_default\n};\nvar debugApis = {\n  parse: withPlugins(parse5),\n  formatAST: withPlugins(formatAst),\n  formatDoc: withPlugins(formatDoc),\n  printToDoc: withPlugins(printToDoc),\n  printDocToString: withPlugins(printDocToString2),\n  mockable: mockable_default\n};\n\n// with-default-export:src/index.js\nvar src_default = src_exports;\nexport {\n  debugApis as __debug,\n  sharedWithCli as __internal,\n  check,\n  clearCache3 as clearConfigCache,\n  src_default as default,\n  doc,\n  format2 as format,\n  formatWithCursor2 as formatWithCursor,\n  getFileInfo2 as getFileInfo,\n  getSupportInfo2 as getSupportInfo,\n  resolveConfig,\n  resolveConfigFile,\n  public_exports as util,\n  version_evaluate_default as version\n};\n"],"names":[],"sourceRoot":""}